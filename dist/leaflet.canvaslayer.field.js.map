{"version":3,"sources":["webpack:///leaflet.canvaslayer.field.js","webpack:///webpack/bootstrap 0bcbaaf1c252f301c32f","webpack:///./Cell.js","webpack:///./Field.js","webpack:///./ScalarField.js","webpack:///./Vector.js","webpack:///./VectorField.js","webpack:///./control/L.Control.ColorBar.js","webpack:///./layer/L.CanvasLayer.Field.js","webpack:///./layer/L.CanvasLayer.ScalarField.js","webpack:///./layer/L.CanvasLayer.SimpleLonLat.js","webpack:///./layer/L.CanvasLayer.VectorFieldAnim.js","webpack:///./layer/L.CanvasLayer.js","webpack:///../~/@turf/inside/index.js","webpack:///../~/@turf/invariant/index.js","webpack:///./_main.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","Cell","center","xSize","ySize","arguments","undefined","this","anotherCell","equals","_equalValues","anotherValue","type","constructor","Number","Vector","u","v","halfX","halfY","cLat","lat","cLng","lng","ul","L","latLng","lr","latLngBounds","__WEBPACK_IMPORTED_MODULE_0__Cell__","__WEBPACK_IMPORTED_MODULE_1__turf_inside__","__WEBPACK_IMPORTED_MODULE_1__turf_inside___default","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","push","err","Array","isArray","Field","params","nCols","nRows","width","height","xllCorner","yllCorner","xurCorner","yurCorner","cellXSize","cellYSize","grid","isContinuous","longitudeNeedsToBeWrapped","_inFilter","_spatialMask","range","_calculateRange","stride","cells","j","_lonLatAtIndexes2","_lonLatAtIndexes","_lonLatAtIndexes3","lon","_valueAtIndexes","f","_updateRange","_getWrappedLongitudes2","_getWrappedLongitudes","_getWrappedLongitudes3","xmin","xmax","_pointInMask","_pointInExtent","_getWrappedLongitudes4","_getWrappedLongitudes5","longitudeIn","latitudeIn","pt","geometry","coordinates","properties","poly","contains","notContains","_getDecimalIndexes2","_getDecimalIndexes","_getDecimalIndexes3","interpolatedValueAtIndexes","indexes","_getFourSurroundingIndexes","_indexes","fi","ci","fj","cj","values","_getFourSurroundingValues","_values","g00","g10","g01","g11","_doInterpolation","Math","floor","_clampColumnIndex","_clampRowIndex","row","_isValid","_getDecimalIndexes4","_getDecimalIndexes5","ii","jj","valueAt","hasValue","included","hasValueAt","random","x","_longitudeAtX","y","_latitudeAtY","halfXPixel","halfYPixel","maxCol","maxRow","_toConsumableArray","arr2","from","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0__Field__","ScalarField","_Field","_this","getPrototypeOf","zs","_buildGrid","asc","scaleFactor","lines","split","_checkIsValidASCIIGridHeader","cellSize","parseFloat","match","parseInt","noDataValue","toUpperCase","replace","trim","line","forEach","it","upperCasesLines","map","lin","parameters","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","expected","indexOf","return","data","bandIndex","multipleFromGeoTIFF","bandIndexes","tiff","GeoTIFF","parse","image","getImage","rasters","readRasters","tiepoint","getTiePoints","fileDirectory","getFileDirectory","_fileDirectory$ModelP","ModelPixelScale","xScale","yScale","keys","GDAL_NODATA","noData","z","getWidth","getHeight","_arrayTo2d","array","filter","d3","min","max","rx","ry","sqrt","verticalAngle","atan2","inDegrees","PI","directionTo","__WEBPACK_IMPORTED_MODULE_0__Vector__","__WEBPACK_IMPORTED_MODULE_1__Field__","__WEBPACK_IMPORTED_MODULE_2__ScalarField__","VectorField","us","vs","ascU","ascV","fromASCIIGrid","_paramsFromScalarFields","gtU","gtV","fromGeoTIFF","geotiffData","bandIndexesForUV","_ScalarField$multiple","_ScalarField$multiple2","_getFunctionFor","_applyOnField","func","numCells","_arraysTo2d","valid","vectors","getCells","magnitudes","magnitude","a","b","Control","ColorBar","extend","options","position","margin","background","textColor","steps","decimals","units","title","labels","labelFontSize","labelTextPosition","initialize","color","Util","setOptions","onAdd","_map","div","DomUtil","style","padding","DomEvent","addListener","stopPropagation","preventDefault","backgroundColor","cursor","innerHTML","palette","document","createElement","select","append","attr","text","svg","_createSvgIn","_appendColorBarTo","_appendLabelsTo","spaceForLabels","colorPerValue","_getColorPerValue","w","groupBars","buckets","selectAll","enter","hex","toFixed","_this2","positionPerLabelValue","_getPositionPerLabelValue","_this3","_range","delta","xPositionFor","scaleLinear","domain","control","colorBar","CanvasLayer","mouseMoveCursor","noValue","opacity","onClick","onMouseMove","inFilter","field","_visible","setData","getEvents","events","zoomstart","_hideCanvas","bind","zoomend","_showCanvas","onLayerDidMount","_enableIdentify","_ensureCanvasAlignment","show","hide","_disableIdentify","isVisible","_canvas","visibility","on","_onClick","_onMouseMove","off","topLeft","containerPointToLayerPoint","setPosition","onLayerWillUnmount","needRedraw","_field","onDrawLayer","viewInfo","setFilter","fire","setOpacity","_updateOpacity","getBounds","bb","extent","southWest","northEast","e","_queryValue","_changeCursorOn","_options$mouseMoveCur","getContainer","latlng","_getDrawingContext","g","getContext","clearRect","interpolate","vectorSize","arrowDirection","scalarField","_defaultColorScale","chroma","scale","setColor","_getRendererMethod","_drawImage","_drawArrows","Error","_ensureColor","ctx","img","createImageData","_prepareImageIn","putImageData","pos","pointCoords","containerPointToLatLng","_getColorFor","_color$rgba","rgba","_color$rgba2","R","G","B","A","bounds","_pixelBounds","pixelSize","strokeStyle","currentBounds","_field$_lonLatAtIndex","_field$_lonLatAtIndex2","cell","_drawArrow","northWest","latLngToContainerPoint","getNorthWest","southEast","getSouthEast","projected","size","save","translate","rotationRads","rotate","beginPath","moveTo","lineTo","stroke","restore","canvasLayer","SimpleLonLat","points","canvas","fillStyle","point","layer","fillRect","fill","closePath","xs","ys","apply","ymin","ymax","simpleLonLat","lonslats","VectorFieldAnim","paths","fade","duration","maxAge","velocityScale","vectorField","timer","_stopAnimation","_moveParticles","par","age","randomPosition","vector","xt","yt","_drawParticles","prev","globalCompositeOperation","lineWidth","_drawParticle","_prepareParticlePaths","source","pA","pB","_randomAge","stop","vectorFieldAnim","Layer","_frame","_delegate","delegate","del","requestAnimFrame","drawLayer","_onLayerDidResize","resizeEvent","newSize","_onLayerDidMove","resize","moveend","zoomAnimation","Browser","any3d","zoomanim","_animateZoom","tiles","getSize","animated","addClass","_panes","overlayPane","appendChild","onRemove","getPanes","removeChild","addTo","addLayer","LatLonToMercator","latlon","log","tan","zoom","getZoom","getCenter","corner","getZoomScale","offset","_latLngToNewLayerPoint","setTransform","inRing","ring","ignoreBoundary","isInside","slice","xi","yi","xj","yj","inBBox","bbox","invariant","getCoord","getCoords","polygon","polys","insidePoly","inHole","k","obj","containsNumber","geojsonType","featureOf","feature","collectionOf","featureCollection","features","getGeom","geojson","geometries","getGeomType","geom","__WEBPACK_IMPORTED_MODULE_0__Vector_js__","__WEBPACK_IMPORTED_MODULE_1__Cell_js__","__WEBPACK_IMPORTED_MODULE_2__Field_js__","__WEBPACK_IMPORTED_MODULE_3__ScalarField_js__","__WEBPACK_IMPORTED_MODULE_4__VectorField_js__","window","console"],"mappings":"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","file":"leaflet.canvaslayer.field.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 13);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *  Simple regular cell in a raster\n */\nvar Cell = function () {\n    /**\n     * A simple cell with a numerical value\n     * @param {L.LatLng} center\n     * @param {Number|Vector} value\n     * @param {Number} xSize\n     * @param {Number} ySize\n     */\n    function Cell(center, value, xSize) {\n        var ySize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : xSize;\n\n        _classCallCheck(this, Cell);\n\n        this.center = center;\n        this.value = value;\n        this.xSize = xSize;\n        this.ySize = ySize;\n    }\n\n    _createClass(Cell, [{\n        key: \"equals\",\n        value: function equals(anotherCell) {\n            return this.center.equals(anotherCell.center) && this._equalValues(this.value, anotherCell.value) && this.xSize === anotherCell.xSize && this.ySize === anotherCell.ySize;\n        }\n    }, {\n        key: \"_equalValues\",\n        value: function _equalValues(value, anotherValue) {\n            var type = value.constructor.name;\n            var answerFor = {\n                Number: value === anotherValue,\n                Vector: value.u === anotherValue.u && value.v === anotherValue.v\n            };\n            return answerFor[type];\n        }\n\n        /**\n         * Bounds for the cell\n         * @returns {LatLngBounds}\n         */\n\n    }, {\n        key: \"getBounds\",\n        value: function getBounds() {\n            var halfX = this.xSize / 2.0;\n            var halfY = this.ySize / 2.0;\n            var cLat = this.center.lat;\n            var cLng = this.center.lng;\n            var ul = L.latLng([cLat + halfY, cLng - halfX]);\n            var lr = L.latLng([cLat - halfY, cLng + halfX]);\n\n            return L.latLngBounds(L.latLng(lr.lat, ul.lng), L.latLng(ul.lat, lr.lng));\n        }\n    }]);\n\n    return Cell;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Cell);\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Cell__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__turf_inside__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__turf_inside___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__turf_inside__);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n/**\n *  Abstract class for a set of values (Vector | Scalar)\n *  assigned to a regular 2D-grid (lon-lat), aka 'a Raster source'\n */\n\nvar Field = function () {\n    function Field(params) {\n        _classCallCheck(this, Field);\n\n        this.params = params;\n\n        this.nCols = params['nCols'];\n        this.nRows = params['nRows'];\n\n        // alias\n        this.width = params['nCols'];\n        this.height = params['nRows'];\n\n        // ll = lower-left\n        this.xllCorner = params['xllCorner'];\n        this.yllCorner = params['yllCorner'];\n\n        // ur = upper-right\n        this.xurCorner = params['xllCorner'] + params['nCols'] * params['cellXSize'];\n        this.yurCorner = params['yllCorner'] + params['nRows'] * params['cellYSize'];\n\n        this.cellXSize = params['cellXSize'];\n        this.cellYSize = params['cellYSize'];\n\n        this.grid = null; // to be defined by subclasses\n        this.isContinuous = this.xurCorner - this.xllCorner >= 360;\n        this.longitudeNeedsToBeWrapped = this.xurCorner > 180; // [0, 360] --> [-180, 180]\n\n        this._inFilter = null;\n        this._spatialMask = null;\n    }\n\n    /**\n     * Builds a grid with a value at each point (either Vector or Number)\n     * Original params must include the required input values, following\n     * x-ascending & y-descending order (same as in ASCIIGrid)\n     * @abstract\n     * @private\n     * @returns {Array.<Array.<Vector|Number>>} - grid[row][column]--> Vector|Number\n     */\n\n\n    _createClass(Field, [{\n        key: '_buildGrid',\n        value: function _buildGrid() {\n            throw new TypeError('Must be overriden');\n        }\n    }, {\n        key: '_updateRange',\n        value: function _updateRange() {\n            this.range = this._calculateRange();\n        }\n\n        /**\n         * Number of cells in the grid (rows * cols)\n         * @returns {Number}\n         */\n\n    }, {\n        key: 'numCells',\n        value: function numCells() {\n            return this.nRows * this.nCols;\n        }\n\n        /**\n         * A list with every cell\n         * @returns {Array<Cell>} - cells (x-ascending & y-descending order)\n         */\n\n    }, {\n        key: 'getCells',\n        value: function getCells() {\n            var stride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n            var cells = [];\n            for (var j = 0; j < this.nRows; j = j + stride) {\n                for (var i = 0; i < this.nCols; i = i + stride) {\n                    var _lonLatAtIndexes2 = this._lonLatAtIndexes(i, j),\n                        _lonLatAtIndexes3 = _slicedToArray(_lonLatAtIndexes2, 2),\n                        lon = _lonLatAtIndexes3[0],\n                        lat = _lonLatAtIndexes3[1];\n\n                    var center = L.latLng(lat, lon);\n                    var value = this._valueAtIndexes(i, j);\n                    var c = new __WEBPACK_IMPORTED_MODULE_0__Cell__[\"a\" /* default */](center, value, this.cellXSize, this.cellYSize);\n                    cells.push(c); // <<\n                }\n            }\n            return cells;\n        }\n\n        /**\n         * Apply a filter function to field values\n         * @param   {Function} f - boolean function\n         */\n\n    }, {\n        key: 'setFilter',\n        value: function setFilter(f) {\n            this._inFilter = f;\n            this._updateRange();\n        }\n\n        /**\n         * Apply a spatial mask to field values\n         * @param {L.GeoJSON} m \n         */\n\n    }, {\n        key: 'setSpatialMask',\n        value: function setSpatialMask(m) {\n            this._spatialMask = m;\n        }\n\n        /**\n         * Grid extent\n         * @returns {Number[]} [xmin, ymin, xmax, ymax]\n         */\n\n    }, {\n        key: 'extent',\n        value: function extent() {\n            var _getWrappedLongitudes2 = this._getWrappedLongitudes(),\n                _getWrappedLongitudes3 = _slicedToArray(_getWrappedLongitudes2, 2),\n                xmin = _getWrappedLongitudes3[0],\n                xmax = _getWrappedLongitudes3[1];\n\n            return [xmin, this.yllCorner, xmax, this.yurCorner];\n        }\n\n        /**\n         * [xmin, xmax] in [-180, 180] range\n         */\n\n    }, {\n        key: '_getWrappedLongitudes',\n        value: function _getWrappedLongitudes() {\n            var xmin = this.xllCorner;\n            var xmax = this.xurCorner;\n\n            if (this.longitudeNeedsToBeWrapped) {\n                if (this.isContinuous) {\n                    xmin = -180;\n                    xmax = 180;\n                } else {\n                    // not sure about this (just one particular case, but others...?)\n                    xmax = this.xurCorner - 360;\n                    xmin = this.xllCorner - 360;\n                    /* eslint-disable no-console */\n                    // console.warn(`are these xmin: ${xmin} & xmax: ${xmax} OK?`);\n                    // TODO: Better throw an exception on no-controlled situations.\n                    /* eslint-enable no-console */\n                }\n            }\n            return [xmin, xmax];\n        }\n\n        /**\n         * Returns whether or not the grid contains the point, considering\n         * the spatialMask if it has been previously set\n         * @param   {Number} lon - longitude\n         * @param   {Number} lat - latitude\n         * @returns {Boolean}\n         */\n\n    }, {\n        key: 'contains',\n        value: function contains(lon, lat) {\n            if (this._spatialMask) {\n                return this._pointInMask(lon, lat);\n            }\n            return this._pointInExtent(lon, lat);\n        }\n\n        /**\n         * Checks if coordinates are inside the Extent (considering wrapped longitudes if needed)\n         * @param {Number} lon \n         * @param {Number} lat \n         */\n\n    }, {\n        key: '_pointInExtent',\n        value: function _pointInExtent(lon, lat) {\n            var _getWrappedLongitudes4 = this._getWrappedLongitudes(),\n                _getWrappedLongitudes5 = _slicedToArray(_getWrappedLongitudes4, 2),\n                xmin = _getWrappedLongitudes5[0],\n                xmax = _getWrappedLongitudes5[1];\n\n            var longitudeIn = lon >= xmin && lon <= xmax;\n            var latitudeIn = lat >= this.yllCorner && lat <= this.yurCorner;\n            return longitudeIn && latitudeIn;\n        }\n\n        /**\n         * Check if coordinates are inside the spatialMask (Point in Polygon analysis)\n         * @param {Number} lon \n         * @param {Number} lat \n         */\n\n    }, {\n        key: '_pointInMask',\n        value: function _pointInMask(lon, lat) {\n            var pt = {\n                type: 'Feature',\n                geometry: {\n                    type: 'Point',\n                    coordinates: [lon, lat] // geojson, lon-lat order !\n                },\n                properties: {}\n            };\n            var poly = this._spatialMask;\n            return __WEBPACK_IMPORTED_MODULE_1__turf_inside___default()(pt, poly);\n        }\n\n        /**\n         * Returns if the grid doesn't contain the point\n         * @param   {Number} lon - longitude\n         * @param   {Number} lat - latitude\n         * @returns {Boolean}\n         */\n\n    }, {\n        key: 'notContains',\n        value: function notContains(lon, lat) {\n            return !this.contains(lon, lat);\n        }\n\n        /**\n         * Interpolated value at lon-lat coordinates (bilinear method)\n         * @param   {Number} longitude\n         * @param   {Number} latitude\n         * @returns {Vector|Number} [u, v, magnitude]\n         *                          \n         * Source: https://github.com/cambecc/earth > product.js\n         */\n\n    }, {\n        key: 'interpolatedValueAt',\n        value: function interpolatedValueAt(lon, lat) {\n            if (this.notContains(lon, lat)) return null;\n\n            var _getDecimalIndexes2 = this._getDecimalIndexes(lon, lat),\n                _getDecimalIndexes3 = _slicedToArray(_getDecimalIndexes2, 2),\n                i = _getDecimalIndexes3[0],\n                j = _getDecimalIndexes3[1];\n\n            return this.interpolatedValueAtIndexes(i, j);\n        }\n\n        /**\n         * Interpolated value at i-j indexes (bilinear method)\n         * @param   {Number} i\n         * @param   {Number} j\n         * @returns {Vector|Number} [u, v, magnitude]\n         *\n         * Source: https://github.com/cambecc/earth > product.js\n         */\n\n    }, {\n        key: 'interpolatedValueAtIndexes',\n        value: function interpolatedValueAtIndexes(i, j) {\n            //         1      2           After converting  and  to fractional grid indexes i and j, we find the\n            //        fi  i   ci          four points 'G' that enclose point (i, j). These points are at the four\n            //         | =1.4 |           corners specified by the floor and ceiling of i and j. For example, given\n            //      ---G--|---G--- fj 8   i = 1.4 and j = 8.3, the four surrounding grid points are (1, 8), (2, 8),\n            //    j ___|_ .   |           (1, 9) and (2, 9).\n            //  =8.3   |      |\n            //      ---G------G--- cj 9   Note that for wrapped grids, the first column is duplicated as the last\n            //         |      |           column, so the index ci can be used without taking a modulo.\n\n            var indexes = this._getFourSurroundingIndexes(i, j);\n\n            var _indexes = _slicedToArray(indexes, 4),\n                fi = _indexes[0],\n                ci = _indexes[1],\n                fj = _indexes[2],\n                cj = _indexes[3];\n\n            var values = this._getFourSurroundingValues(fi, ci, fj, cj);\n            if (values) {\n                var _values = _slicedToArray(values, 4),\n                    g00 = _values[0],\n                    g10 = _values[1],\n                    g01 = _values[2],\n                    g11 = _values[3];\n\n                return this._doInterpolation(i - fi, j - fj, g00, g10, g01, g11);\n            }\n            return null;\n        }\n\n        /**\n         * Get decimal indexes\n         * @private\n         * @param {Number} lon\n         * @param {Number} lat\n         * @returns {Array}    [[Description]]\n         */\n\n    }, {\n        key: '_getDecimalIndexes',\n        value: function _getDecimalIndexes(lon, lat) {\n            if (this.longitudeNeedsToBeWrapped && lon < this.xllCorner) {\n                lon = lon + 360;\n            }\n            var i = (lon - this.xllCorner) / this.cellXSize;\n            var j = (this.yurCorner - lat) / this.cellYSize;\n            return [i, j];\n        }\n\n        /**\n         * Get surrounding indexes (integer), clampling on borders\n         * @private\n         * @param   {Number} i - decimal index\n         * @param   {Number} j - decimal index\n         * @returns {Array} [fi, ci, fj, cj]\n         */\n\n    }, {\n        key: '_getFourSurroundingIndexes',\n        value: function _getFourSurroundingIndexes(i, j) {\n            var fi = Math.floor(i);\n            var ci = fi + 1;\n            // duplicate colum to simplify interpolation logic (wrapped value)\n            if (this.isContinuous && ci >= this.nCols) {\n                ci = 0;\n            }\n            ci = this._clampColumnIndex(ci);\n\n            var fj = this._clampRowIndex(Math.floor(j));\n            var cj = this._clampRowIndex(fj + 1);\n\n            return [fi, ci, fj, cj];\n        }\n\n        /**\n         * Get four surrounding values or null if not available,\n         * from 4 integer indexes\n         * @private\n         * @param   {Number} fi\n         * @param   {Number} ci\n         * @param   {Number} fj\n         * @param   {Number} cj\n         * @returns {Array} \n         */\n\n    }, {\n        key: '_getFourSurroundingValues',\n        value: function _getFourSurroundingValues(fi, ci, fj, cj) {\n            var row;\n            if (row = this.grid[fj]) {\n                // upper row ^^\n                var g00 = row[fi]; // << left\n                var g10 = row[ci]; // right >>\n                if (this._isValid(g00) && this._isValid(g10) && (row = this.grid[cj])) {\n                    // lower row vv\n                    var g01 = row[fi]; // << left\n                    var g11 = row[ci]; // right >>\n                    if (this._isValid(g01) && this._isValid(g11)) {\n                        return [g00, g10, g01, g11]; // 4 values found!\n                    }\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Nearest value at lon-lat coordinates\n         * @param   {Number} longitude\n         * @param   {Number} latitude\n         * @returns {Vector|Number}\n         */\n\n    }, {\n        key: 'valueAt',\n        value: function valueAt(lon, lat) {\n            if (this.notContains(lon, lat)) return null;\n\n            var _getDecimalIndexes4 = this._getDecimalIndexes(lon, lat),\n                _getDecimalIndexes5 = _slicedToArray(_getDecimalIndexes4, 2),\n                i = _getDecimalIndexes5[0],\n                j = _getDecimalIndexes5[1];\n\n            var ii = Math.floor(i);\n            var jj = Math.floor(j);\n\n            var ci = this._clampColumnIndex(ii);\n            var cj = this._clampRowIndex(jj);\n\n            var value = this._valueAtIndexes(ci, cj);\n            if (this._inFilter) {\n                if (!this._inFilter(value)) return null;\n            }\n\n            return value;\n        }\n\n        /**\n         * Returns whether or not the field has a value at the point\n         * @param   {Number} lon - longitude\n         * @param   {Number} lat - latitude\n         * @returns {Boolean}\n         */\n\n    }, {\n        key: 'hasValueAt',\n        value: function hasValueAt(lon, lat) {\n            var value = this.valueAt(lon, lat);\n            var hasValue = value !== null;\n\n            var included = true;\n            if (this._inFilter) {\n                included = this._inFilter(value);\n            }\n            return hasValue && included;\n        }\n\n        /**\n         * Returns if the grid has no value at the point\n         * @param   {Number} lon - longitude\n         * @param   {Number} lat - latitude\n         * @returns {Boolean}\n         */\n\n    }, {\n        key: 'notHasValueAt',\n        value: function notHasValueAt(lon, lat) {\n            return !this.hasValueAt(lon, lat);\n        }\n\n        /**\n         * Gives a random position to 'o' inside the grid\n         * @param {Object} [o] - an object (eg. a particle)\n         * @returns {{x: Number, y: Number}} - object with x, y (lon, lat)\n         */\n\n    }, {\n        key: 'randomPosition',\n        value: function randomPosition() {\n            var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            var i = Math.random() * this.nCols | 0;\n            var j = Math.random() * this.nRows | 0;\n\n            o.x = this._longitudeAtX(i);\n            o.y = this._latitudeAtY(j);\n\n            return o;\n        }\n\n        /**\n         * Value for grid indexes\n         * @param   {Number} i - column index (integer)\n         * @param   {Number} j - row index (integer)\n         * @returns {Vector|Number}\n         */\n\n    }, {\n        key: '_valueAtIndexes',\n        value: function _valueAtIndexes(i, j) {\n            return this.grid[j][i]; // <-- j,i !!\n        }\n\n        /**\n         * Lon-Lat for grid indexes\n         * @param   {Number} i - column index (integer)\n         * @param   {Number} j - row index (integer)\n         * @returns {Number[]} [lon, lat]\n         */\n\n    }, {\n        key: '_lonLatAtIndexes',\n        value: function _lonLatAtIndexes(i, j) {\n            var lon = this._longitudeAtX(i);\n            var lat = this._latitudeAtY(j);\n\n            return [lon, lat];\n        }\n\n        /**\n         * Longitude for grid-index\n         * @param   {Number} i - column index (integer)\n         * @returns {Number} longitude at the center of the cell\n         */\n\n    }, {\n        key: '_longitudeAtX',\n        value: function _longitudeAtX(i) {\n            var halfXPixel = this.cellXSize / 2.0;\n            var lon = this.xllCorner + halfXPixel + i * this.cellXSize;\n            if (this.longitudeNeedsToBeWrapped) {\n                lon = lon > 180 ? lon - 360 : lon;\n            }\n            return lon;\n        }\n\n        /**\n         * Latitude for grid-index\n         * @param   {Number} j - row index (integer)\n         * @returns {Number} latitude at the center of the cell\n         */\n\n    }, {\n        key: '_latitudeAtY',\n        value: function _latitudeAtY(j) {\n            var halfYPixel = this.cellYSize / 2.0;\n            return this.yurCorner - halfYPixel - j * this.cellYSize;\n        }\n\n        /**\n         * Apply the interpolation\n         * @abstract\n         * @private\n         */\n        /* eslint-disable no-unused-vars */\n\n    }, {\n        key: '_doInterpolation',\n        value: function _doInterpolation(x, y, g00, g10, g01, g11) {\n            throw new TypeError('Must be overriden');\n        }\n        /* eslint-disable no-unused-vars */\n\n        /**\n         * Check the column index is inside the field,\n         * adjusting to min or max when needed\n         * @private\n         * @param   {Number} ii - index\n         * @returns {Number} i - inside the allowed indexes\n         */\n\n    }, {\n        key: '_clampColumnIndex',\n        value: function _clampColumnIndex(ii) {\n            var i = ii;\n            if (ii < 0) {\n                i = 0;\n            }\n            var maxCol = this.nCols - 1;\n            if (ii > maxCol) {\n                i = maxCol;\n            }\n            return i;\n        }\n\n        /**\n         * Check the row index is inside the field,\n         * adjusting to min or max when needed\n         * @private\n         * @param   {Number} jj index\n         * @returns {Number} j - inside the allowed indexes\n         */\n\n    }, {\n        key: '_clampRowIndex',\n        value: function _clampRowIndex(jj) {\n            var j = jj;\n            if (jj < 0) {\n                j = 0;\n            }\n            var maxRow = this.nRows - 1;\n            if (jj > maxRow) {\n                j = maxRow;\n            }\n            return j;\n        }\n\n        /**\n         * Is valid (not 'null' nor 'undefined')\n         * @private\n         * @param   {Object} x object\n         * @returns {Boolean}\n         */\n\n    }, {\n        key: '_isValid',\n        value: function _isValid(x) {\n            return x !== null && x !== undefined;\n        }\n    }]);\n\n    return Field;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Field);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Field__ = __webpack_require__(1);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n/**\n * Scalar Field\n */\n\nvar ScalarField = function (_Field) {\n    _inherits(ScalarField, _Field);\n\n    _createClass(ScalarField, null, [{\n        key: 'fromASCIIGrid',\n\n        /**\n         * Creates a ScalarField from the content of an ASCIIGrid file\n         * @param   {String}   asc\n         * @returns {ScalarField}\n         */\n        value: function fromASCIIGrid(asc) {\n            var scaleFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n            //console.time('ScalarField from ASC');\n\n            var lines = asc.split('\\n');\n\n            // Header\n            ScalarField._checkIsValidASCIIGridHeader(lines);\n\n            var n = /-?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/; // any number\n\n            var cellSize = parseFloat(lines[4].match(n)); // right now, no different x-y size is allowed\n            var p = {\n                nCols: parseInt(lines[0].match(n)),\n                nRows: parseInt(lines[1].match(n)),\n                xllCorner: parseFloat(lines[2].match(n)),\n                yllCorner: parseFloat(lines[3].match(n)),\n                cellXSize: cellSize,\n                cellYSize: cellSize\n            };\n            var noDataValue = lines[5].toUpperCase().replace('NODATA_VALUE', '').trim();\n\n            // Data (left-right and top-down)\n            var zs = []; // TODO Consider using TypedArray (& manage NO_DATA)\n            for (var i = 6; i < lines.length; i++) {\n                var line = lines[i].trim();\n                if (line === '') break;\n\n                var items = line.split(' ');\n                items.forEach(function (it) {\n                    var v = it !== noDataValue ? parseFloat(it * scaleFactor) : null;\n                    zs.push(v);\n                });\n            }\n            p.zs = zs;\n\n            //console.timeEnd('ScalarField from ASC');\n            return new ScalarField(p);\n        }\n    }, {\n        key: '_checkIsValidASCIIGridHeader',\n        value: function _checkIsValidASCIIGridHeader(lines) {\n            var upperCasesLines = lines.map(function (lin) {\n                return lin.toUpperCase();\n            });\n\n            var parameters = ['NCOLS', 'NROWS', 'XLLCORNER', 'YLLCORNER', 'CELLSIZE', 'NODATA_VALUE'];\n\n            var i = 0;\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = parameters[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var expected = _step.value;\n\n                    var line = upperCasesLines[i];\n                    var found = line.indexOf(expected) != -1;\n                    if (!found) {\n                        throw 'Not valid ASCIIGrid: expected \\'' + expected + '\\' at line \\'' + line + '\\' [lin. n\\xBA ' + i + ']';\n                    }\n                    i++;\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Creates a ScalarField from the content of a GeoTIFF file\n         * @param   {ArrayBuffer}   data\n         * @param   {Number}   bandIndex\n         * @returns {ScalarField}\n         */\n\n    }, {\n        key: 'fromGeoTIFF',\n        value: function fromGeoTIFF(data) {\n            var bandIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n            return ScalarField.multipleFromGeoTIFF(data, [bandIndex])[0];\n        }\n\n        /**\n         * Creates a ScalarField array (one per band) from the content of a GeoTIFF file\n         * @param   {ArrayBuffer}   data\n         * @param   {Array}   bandIndexes - if not provided all bands are returned\n         * @returns {Array.<ScalarField>}\n         */\n\n    }, {\n        key: 'multipleFromGeoTIFF',\n        value: function multipleFromGeoTIFF(data, bandIndexes) {\n            //console.time('ScalarField from GeoTIFF');\n\n            var tiff = GeoTIFF.parse(data); // geotiff.js\n            var image = tiff.getImage();\n            var rasters = image.readRasters();\n            var tiepoint = image.getTiePoints()[0];\n            var fileDirectory = image.getFileDirectory();\n\n            var _fileDirectory$ModelP = _slicedToArray(fileDirectory.ModelPixelScale, 2),\n                xScale = _fileDirectory$ModelP[0],\n                yScale = _fileDirectory$ModelP[1];\n\n            if (typeof bandIndexes === 'undefined' || bandIndexes.length === 0) {\n                bandIndexes = [].concat(_toConsumableArray(Array(rasters.length).keys()));\n            }\n\n            var scalarFields = [];\n            scalarFields = bandIndexes.map(function (bandIndex) {\n                var zs = rasters[bandIndex]; // left-right and top-down order\n\n                if (fileDirectory.GDAL_NODATA) {\n                    var noData = parseFloat(fileDirectory.GDAL_NODATA);\n                    // console.log(noData);\n                    var simpleZS = Array.from(zs); // to simple array, so null is allowed | TODO efficiency??\n                    zs = simpleZS.map(function (z) {\n                        return z === noData ? null : z;\n                    });\n                }\n\n                var p = {\n                    nCols: image.getWidth(),\n                    nRows: image.getHeight(),\n                    xllCorner: tiepoint.x,\n                    yllCorner: tiepoint.y - image.getHeight() * yScale,\n                    cellXSize: xScale,\n                    cellYSize: yScale,\n                    zs: zs\n                };\n                return new ScalarField(p);\n            });\n\n            //console.timeEnd('ScalarField from GeoTIFF');\n            return scalarFields;\n        }\n    }]);\n\n    function ScalarField(params) {\n        _classCallCheck(this, ScalarField);\n\n        var _this = _possibleConstructorReturn(this, (ScalarField.__proto__ || Object.getPrototypeOf(ScalarField)).call(this, params));\n\n        _this.zs = params['zs'];\n\n        _this.grid = _this._buildGrid();\n        _this._updateRange();\n        //console.log(`ScalarField created (${this.nCols} x ${this.nRows})`);\n        return _this;\n    }\n\n    /**\n     * Builds a grid with a Number at each point, from an array\n     * 'zs' following x-ascending & y-descending order\n     * (same as in ASCIIGrid)\n     * @private\n     * @returns {Array.<Array.<Number>>} - grid[row][column]--> Number\n     */\n\n\n    _createClass(ScalarField, [{\n        key: '_buildGrid',\n        value: function _buildGrid() {\n            var grid = this._arrayTo2d(this.zs, this.nRows, this.nCols);\n            return grid;\n        }\n    }, {\n        key: '_arrayTo2d',\n        value: function _arrayTo2d(array, nRows, nCols) {\n            var grid = [];\n            var p = 0;\n            for (var j = 0; j < nRows; j++) {\n                var row = [];\n                for (var i = 0; i < nCols; i++, p++) {\n                    var z = array[p];\n                    row[i] = this._isValid(z) ? z : null; // <<<\n                }\n                grid[j] = row;\n            }\n            return grid;\n        }\n    }, {\n        key: '_newDataArrays',\n        value: function _newDataArrays(params) {\n            params['zs'] = [];\n        }\n    }, {\n        key: '_pushValueToArrays',\n        value: function _pushValueToArrays(params, value) {\n            params['zs'].push(value);\n        }\n    }, {\n        key: '_makeNewFrom',\n        value: function _makeNewFrom(params) {\n            return new ScalarField(params);\n        }\n\n        /**\n         * Calculate min & max values\n         * @private\n         * @returns {Array} - [min, max]\n         */\n\n    }, {\n        key: '_calculateRange',\n        value: function _calculateRange() {\n            var data = this.zs;\n            if (this._inFilter) {\n                data = data.filter(this._inFilter);\n            }\n            return [d3.min(data), d3.max(data)];\n        }\n\n        /**\n         * Bilinear interpolation for Number\n         * https://en.wikipedia.org/wiki/Bilinear_interpolation\n         * @param   {Number} x\n         * @param   {Number} y\n         * @param   {Number} g00\n         * @param   {Number} g10\n         * @param   {Number} g01\n         * @param   {Number} g11\n         * @returns {Number}\n         */\n\n    }, {\n        key: '_doInterpolation',\n        value: function _doInterpolation(x, y, g00, g10, g01, g11) {\n            var rx = 1 - x;\n            var ry = 1 - y;\n            return g00 * rx * ry + g10 * x * ry + g01 * rx * y + g11 * x * y;\n        }\n    }]);\n\n    return ScalarField;\n}(__WEBPACK_IMPORTED_MODULE_0__Field__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ScalarField);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *  2D Vector\n */\nvar Vector = function () {\n    function Vector(u, v) {\n        _classCallCheck(this, Vector);\n\n        this.u = u;\n        this.v = v;\n    }\n\n    /**\n     * Magnitude\n     * @returns {Number}\n     */\n\n\n    _createClass(Vector, [{\n        key: \"magnitude\",\n        value: function magnitude() {\n            return Math.sqrt(this.u * this.u + this.v * this.v);\n        }\n\n        /**\n         * Angle in degrees (0 to 360) --> Towards\n         * N is 0 and E is 90\n         * @returns {Number}\n         */\n\n    }, {\n        key: \"directionTo\",\n        value: function directionTo() {\n            var verticalAngle = Math.atan2(this.u, this.v);\n            var inDegrees = verticalAngle * (180.0 / Math.PI);\n            if (inDegrees < 0) {\n                inDegrees = inDegrees + 360.0;\n            }\n            return inDegrees;\n        }\n\n        /**\n         * Angle in degrees (0 to 360) From x-->\n         * N is 0 and E is 90\n         * @returns {Number}\n         */\n\n    }, {\n        key: \"directionFrom\",\n        value: function directionFrom() {\n            var a = this.directionTo();\n            var opposite = (a + 180.0) % 360.0;\n            return opposite;\n        }\n\n        /*\n            Degrees --> text\n            new Dictionary<int, string>\n            {\n                //{0, 23, 45, 68, 90, 113, 135, 158, 180, 203, 225, 248, 270, 293, 315, 338, 360};\n                {0, 'N'},\n                {23, 'NNE'},\n                {45, 'NE'},\n                {68, 'ENE'},\n                {90, 'E'},\n                {113, 'ESE'},\n                {135, 'SE'},\n                {158, 'SSE'},\n                {180, 'S'},\n                {203, 'SSW'},\n                {225, 'SW'},\n                {248, 'WSW'},\n                {270, 'W'},\n                {293, 'WNW'},\n                {315, 'NW'},\n                {338, 'NNW'},\n                {360, 'N'}\n            };\n        */\n\n    }]);\n\n    return Vector;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vector);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Vector__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Field__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ScalarField__ = __webpack_require__(2);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n/**\n *  A set of vectors assigned to a regular 2D-grid (lon-lat)\n *  (e.g. a raster representing winds for a region)\n */\n\nvar VectorField = function (_Field) {\n    _inherits(VectorField, _Field);\n\n    _createClass(VectorField, null, [{\n        key: 'fromASCIIGrids',\n\n        /**\n         * Creates a VectorField from the content of two ASCIIGrid files\n         * @param   {String} ascU - with u-component\n         * @param   {String} ascV - with v-component\n         * @returns {VectorField}\n         */\n        value: function fromASCIIGrids(ascU, ascV) {\n            var scaleFactor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n            var u = __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */].fromASCIIGrid(ascU, scaleFactor);\n            var v = __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */].fromASCIIGrid(ascV, scaleFactor);\n            var p = VectorField._paramsFromScalarFields(u, v);\n\n            return new VectorField(p);\n        }\n\n        /**\n         * Creates a VectorField from the content of two different Geotiff files\n         * @param   {ArrayBuffer} gtU - geotiff data with u-component (band 0)\n         * @param   {ArrayBuffer} gtV - geotiff data with v-component (band 0)\n         * @returns {VectorField}\n         */\n\n    }, {\n        key: 'fromGeoTIFFs',\n        value: function fromGeoTIFFs(gtU, gtV) {\n            var u = __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */].fromGeoTIFF(gtU);\n            var v = __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */].fromGeoTIFF(gtV);\n            var p = VectorField._paramsFromScalarFields(u, v);\n\n            return new VectorField(p);\n        }\n\n        /**\n         * Creates a VectorField from the content of Multiband Geotiff\n         * @param   {ArrayBuffer} geotiffData - multiband\n         * @param   {Array} bandIndexesForUV\n         * @returns {VectorField}\n         */\n\n    }, {\n        key: 'fromMultibandGeoTIFF',\n        value: function fromMultibandGeoTIFF(geotiffData) {\n            var bandIndexesForUV = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 1];\n\n            var _ScalarField$multiple = __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */].multipleFromGeoTIFF(geotiffData, bandIndexesForUV),\n                _ScalarField$multiple2 = _slicedToArray(_ScalarField$multiple, 2),\n                u = _ScalarField$multiple2[0],\n                v = _ScalarField$multiple2[1];\n\n            var p = VectorField._paramsFromScalarFields(u, v);\n\n            return new VectorField(p);\n        }\n\n        /**\n         * Build parameters for VectorField, from 2 ScalarFields.\n         * No validation at all (nor interpolation) is applied, so u and v\n         * must be 'compatible' from the source\n         * @param   {ScalarField} u\n         * @param   {ScalarField} v\n         * @returns {Object} - parameters to build VectorField\n         */\n\n    }, {\n        key: '_paramsFromScalarFields',\n        value: function _paramsFromScalarFields(u, v) {\n            // TODO check u & v compatibility (cellSize...)\n            var p = {\n                nCols: u.nCols,\n                nRows: u.nRows,\n                xllCorner: u.xllCorner,\n                yllCorner: u.yllCorner,\n                cellXSize: u.cellXSize,\n                cellYSize: u.cellYSize,\n                us: u.zs,\n                vs: v.zs\n            };\n            return p;\n        }\n    }]);\n\n    function VectorField(params) {\n        _classCallCheck(this, VectorField);\n\n        var _this = _possibleConstructorReturn(this, (VectorField.__proto__ || Object.getPrototypeOf(VectorField)).call(this, params));\n\n        _this.us = params['us'];\n        _this.vs = params['vs'];\n        _this.grid = _this._buildGrid();\n        _this.range = _this._calculateRange();\n        return _this;\n    }\n\n    /**\n     * Get a derived field, from a computation on\n     * the VectorField\n     * @param   {String} type ['magnitude' | 'directionTo' | 'directionFrom']\n     * @returns {ScalarField}\n     */\n\n\n    _createClass(VectorField, [{\n        key: 'getScalarField',\n        value: function getScalarField(type) {\n            var f = this._getFunctionFor(type);\n            var p = {\n                nCols: this.params.nCols,\n                nRows: this.params.nRows,\n                xllCorner: this.params.xllCorner,\n                yllCorner: this.params.yllCorner,\n                cellXSize: this.params.cellXSize,\n                cellYSize: this.params.cellYSize,\n                zs: this._applyOnField(f)\n            };\n            return new __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */](p);\n        }\n    }, {\n        key: '_getFunctionFor',\n        value: function _getFunctionFor(type) {\n            return function (u, v) {\n                var uv = new __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* default */](u, v);\n                return uv[type](); // magnitude, directionTo, directionFrom\n            };\n        }\n    }, {\n        key: '_applyOnField',\n        value: function _applyOnField(func) {\n            var zs = [];\n            var n = this.numCells();\n            for (var i = 0; i < n; i++) {\n                var u = this.us[i];\n                var v = this.vs[i];\n                if (this._isValid(u) && this._isValid(v)) {\n                    zs.push(func(u, v));\n                } else {\n                    zs.push(null);\n                }\n            }\n            return zs;\n        }\n\n        /**\n         * Builds a grid with a Vector at each point, from two arrays\n         * 'us' and 'vs' following x-ascending & y-descending order\n         * (same as in ASCIIGrid)\n         * @returns {Array.<Array.<Vector>>} - grid[row][column]--> Vector\n         */\n\n    }, {\n        key: '_buildGrid',\n        value: function _buildGrid() {\n            var grid = this._arraysTo2d(this.us, this.vs, this.nRows, this.nCols);\n            return grid;\n        }\n    }, {\n        key: '_arraysTo2d',\n        value: function _arraysTo2d(us, vs, nRows, nCols) {\n            var grid = [];\n            var p = 0;\n\n            for (var j = 0; j < nRows; j++) {\n                var row = [];\n                for (var i = 0; i < nCols; i++, p++) {\n                    var u = us[p],\n                        v = vs[p];\n                    var valid = this._isValid(u) && this._isValid(v);\n                    row[i] = valid ? new __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* default */](u, v) : null; // <<<\n                }\n                grid[j] = row;\n            }\n            return grid;\n        }\n    }, {\n        key: '_newDataArrays',\n        value: function _newDataArrays(params) {\n            params['us'] = [];\n            params['vs'] = [];\n        }\n    }, {\n        key: '_pushValueToArrays',\n        value: function _pushValueToArrays(params, value) {\n            //console.log(value);\n            params['us'].push(value.u);\n            params['vs'].push(value.v);\n        }\n    }, {\n        key: '_makeNewFrom',\n        value: function _makeNewFrom(params) {\n            return new VectorField(params);\n        }\n\n        /**\n         * Calculate min & max values (magnitude)\n         * @private\n         * @returns {Array}\n         */\n\n    }, {\n        key: '_calculateRange',\n        value: function _calculateRange() {\n            // TODO make a clearer method for getting these vectors...\n            var vectors = this.getCells().map(function (pt) {\n                return pt.value;\n            }).filter(function (v) {\n                return v !== null;\n            });\n\n            if (this._inFilter) {\n                vectors = vectors.filter(this._inFilter);\n            }\n\n            // TODO check memory crash with high num of vectors!\n            var magnitudes = vectors.map(function (v) {\n                return v.magnitude();\n            });\n            var min = d3.min(magnitudes);\n            var max = d3.max(magnitudes);\n\n            return [min, max];\n        }\n\n        /**\n         * Bilinear interpolation for Vector\n         * https://en.wikipedia.org/wiki/Bilinear_interpolation\n         * @param   {Number} x\n         * @param   {Number} y\n         * @param   {Number[]} g00\n         * @param   {Number[]} g10\n         * @param   {Number[]} g01\n         * @param   {Number[]} g11\n         * @returns {Vector}\n         */\n\n    }, {\n        key: '_doInterpolation',\n        value: function _doInterpolation(x, y, g00, g10, g01, g11) {\n            var rx = 1 - x;\n            var ry = 1 - y;\n            var a = rx * ry,\n                b = x * ry,\n                c = rx * y,\n                d = x * y;\n            var u = g00.u * a + g10.u * b + g01.u * c + g11.u * d;\n            var v = g00.v * a + g10.v * b + g01.v * c + g11.v * d;\n            return new __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* default */](u, v);\n        }\n\n        /**\n         * Is valid (not 'null' nor 'undefined')\n         * @private\n         * @param   {Object} x object\n         * @returns {Boolean}\n         */\n\n    }, {\n        key: '_isValid',\n        value: function _isValid(x) {\n            return x !== null && x !== undefined;\n        }\n    }]);\n\n    return VectorField;\n}(__WEBPACK_IMPORTED_MODULE_1__Field__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (VectorField);\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n/**\n *   Control for a simple legend with a colorbar\n *   References:\n *      - http://jsfiddle.net/ramnathv/g8stqcf6/\n *      - http://jsfiddle.net/vis4/cYLZH/\n */\nL.Control.ColorBar = L.Control.extend({\n    options: {\n        position: 'bottomleft',\n        width: 300, // for colorbar itself (control is wider)\n        height: 15,\n        margin: 15,\n        background: '#fff',\n        textColor: 'black',\n        steps: 100,\n        decimals: 2,\n        units: 'uds', // ej: m/s\n        title: 'Legend', // ej: Ocean Currents\n        labels: [], // empty for no labels\n        labelFontSize: 10,\n        labelTextPosition: 'middle' // start | middle | end\n    },\n\n    initialize: function initialize(color, range, options) {\n        this.color = color; // 'chromajs' scale function\n        this.range = range; // [min, max]\n        L.Util.setOptions(this, options);\n    },\n\n    onAdd: function onAdd(map) {\n        this._map = map;\n        var div = L.DomUtil.create('div', 'leaflet-control-colorBar leaflet-bar leaflet-control');\n        div.style.padding = '10px';\n\n        L.DomEvent.addListener(div, 'click', L.DomEvent.stopPropagation).addListener(div, 'click', L.DomEvent.preventDefault);\n        div.style.backgroundColor = this.options.background;\n        div.style.cursor = 'text';\n        div.innerHTML = this.title() + this.palette();\n        return div;\n    },\n\n    title: function title() {\n        var d = document.createElement('div');\n        d3.select(d).append('span').style('color', this.options.textColor).style('display', 'block').style('margin-bottom', '5px').attr('class', 'leaflet-control-colorBar-title').text(this.options.title);\n        return d.innerHTML;\n    },\n\n    palette: function palette() {\n        var d = document.createElement('div');\n        var svg = this._createSvgIn(d);\n\n        this._appendColorBarTo(svg);\n\n        if (this.options.labels) {\n            this._appendLabelsTo(svg);\n        }\n\n        return d.innerHTML;\n    },\n\n    _createSvgIn: function _createSvgIn(d) {\n        var spaceForLabels = this.options.labels ? this.options.margin : 0;\n        var svg = d3.select(d).append('svg').attr('width', this.options.width + this.options.margin * 2).attr('height', this.options.height + spaceForLabels);\n        return svg;\n    },\n\n    _appendColorBarTo: function _appendColorBarTo(svg) {\n        var _this = this;\n\n        var colorPerValue = this._getColorPerValue();\n        var w = this.options.width / colorPerValue.length;\n\n        var groupBars = svg.append('g').attr('id', 'colorBar-buckets');\n        var buckets = groupBars.selectAll('rect').data(colorPerValue).enter().append('rect');\n        buckets.attr('x', function (d, i) {\n            return i * w + _this.options.margin;\n        }).attr('y', function () {\n            return 0;\n        }).attr('height', function () {\n            return _this.options.height;\n        } /*w * 4*/).attr('width', function () {\n            return w;\n        }).attr('stroke-width', 2).attr('stroke-linecap', 'butt').attr('stroke', function (d) {\n            return d.color.hex();\n        }).attr('fill', function (d) {\n            return d.color.hex();\n        });\n        buckets.append('title').text(function (d) {\n            return d.value.toFixed(_this.options.decimals) + ' ' + _this.options.units;\n        });\n    },\n\n    _appendLabelsTo: function _appendLabelsTo(svg) {\n        var _this2 = this;\n\n        var positionPerLabelValue = this._getPositionPerLabelValue();\n        //const w = this.options.width / colorPerValue.length;\n        var groupLabels = svg.append('g').attr('id', 'colorBar-labels');\n        var labels = groupLabels.selectAll('text').data(positionPerLabelValue).enter().append('text');\n        labels.attr('x', function (d) {\n            return d.position + _this2.options.margin;\n        }).attr('y', this.options.height + this.options.margin).attr('font-size', this.options.labelFontSize + 'px').attr('text-anchor', this.options.labelTextPosition).attr('fill', this.options.textColor).attr('class', 'leaflet-control-colorBar-label').text(function (d) {\n            return '' + d.value.toFixed(_this2.options.decimals);\n        });\n    },\n\n    _getColorPerValue: function _getColorPerValue() {\n        var _this3 = this;\n\n        var _range = _slicedToArray(this.range, 2),\n            min = _range[0],\n            max = _range[1];\n\n        var delta = (max - min) / this.options.steps;\n        var data = d3.range(min, max + delta, delta);\n        var colorPerValue = data.map(function (d) {\n            return {\n                value: d,\n                color: _this3.color(d)\n            };\n        });\n        return colorPerValue;\n    },\n\n    _getPositionPerLabelValue: function _getPositionPerLabelValue() {\n        var xPositionFor = d3.scaleLinear().range([0, this.options.width]).domain(this.range);\n        var data = this.options.labels;\n        var positionPerLabel = data.map(function (d) {\n            return {\n                value: d,\n                position: xPositionFor(d)\n            };\n        });\n        return positionPerLabel;\n    }\n});\n\nL.control.colorBar = function (color, range, options) {\n    return new L.Control.ColorBar(color, range, options);\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n/**\n * Abstract class for a Field layer on canvas, aka 'a Raster layer'\n * (ScalarField or a VectorField)\n */\nL.CanvasLayer.Field = L.CanvasLayer.extend({\n    options: {\n        mouseMoveCursor: {\n            value: 'pointer',\n            noValue: 'default'\n        },\n        opacity: 1,\n        onClick: null,\n        onMouseMove: null,\n        inFilter: null\n    },\n\n    initialize: function initialize(field, options) {\n        L.Util.setOptions(this, options);\n        this._visible = true;\n        if (field) {\n            this.setData(field);\n        }\n    },\n\n    getEvents: function getEvents() {\n        var events = L.CanvasLayer.prototype.getEvents.call(this);\n        events.zoomstart = this._hideCanvas.bind(this);\n        events.zoomend = this._showCanvas.bind(this);\n        return events;\n    },\n\n    onLayerDidMount: function onLayerDidMount() {\n        this._enableIdentify();\n        this._ensureCanvasAlignment();\n    },\n\n    show: function show() {\n        this._visible = true;\n        this._showCanvas();\n        this._enableIdentify();\n    },\n    hide: function hide() {\n        this._visible = false;\n        this._hideCanvas();\n        this._disableIdentify();\n    },\n    isVisible: function isVisible() {\n        return this._visible;\n    },\n    _showCanvas: function _showCanvas() {\n        if (this._canvas && this._visible) {\n            this._canvas.style.visibility = 'visible';\n        }\n    },\n    _hideCanvas: function _hideCanvas() {\n        if (this._canvas) {\n            this._canvas.style.visibility = 'hidden';\n        }\n    },\n    _enableIdentify: function _enableIdentify() {\n        this._map.on('click', this._onClick, this);\n        this._map.on('mousemove', this._onMouseMove, this);\n\n        this.options.onClick && this.on('click', this.options.onClick, this);\n        this.options.onMouseMove && this.on('mousemove', this.options.onMouseMove, this);\n    },\n    _disableIdentify: function _disableIdentify() {\n        this._map.off('click', this._onClick, this);\n        this._map.off('mousemove', this._onMouseMove, this);\n\n        this.options.onClick && this.off('click', this.options.onClick, this);\n        this.options.onMouseMove && this.off('mousemove', this.options.onMouseMove, this);\n    },\n    _ensureCanvasAlignment: function _ensureCanvasAlignment() {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n    },\n\n\n    onLayerWillUnmount: function onLayerWillUnmount() {\n        this._disableIdentify();\n    },\n\n    needRedraw: function needRedraw() {\n        if (this._map && this._field) {\n            L.CanvasLayer.prototype.needRedraw.call(this);\n        }\n    },\n\n\n    /* eslint-disable no-unused-vars */\n    onDrawLayer: function onDrawLayer(viewInfo) {\n        throw new TypeError('Must be overriden');\n    },\n    /* eslint-enable no-unused-vars */\n\n    setData: function setData(field) {\n        this.options.inFilter && field.setFilter(this.options.inFilter);\n        this._field = field;\n        this.needRedraw();\n        this.fire('load');\n    },\n\n    setFilter: function setFilter(f) {\n        this.options.inFilter = f;\n        this._field && this._field.setFilter(f);\n        this.needRedraw();\n    },\n\n    setOpacity: function setOpacity(opacity) {\n        this.options.opacity = opacity;\n\n        if (this._canvas) {\n            this._updateOpacity();\n        }\n        return this;\n    },\n\n    getBounds: function getBounds() {\n        var bb = this._field.extent();\n\n        var southWest = L.latLng(bb[1], bb[0]),\n            northEast = L.latLng(bb[3], bb[2]);\n        var bounds = L.latLngBounds(southWest, northEast);\n        return bounds;\n    },\n\n    _onClick: function _onClick(e) {\n        var v = this._queryValue(e);\n        this.fire('click', v);\n    },\n\n    _onMouseMove: function _onMouseMove(e) {\n        var v = this._queryValue(e);\n        this._changeCursorOn(v);\n        this.fire('mousemove', v);\n    },\n\n    _changeCursorOn: function _changeCursorOn(v) {\n        if (!this.options.mouseMoveCursor) return;\n\n        var _options$mouseMoveCur = this.options.mouseMoveCursor,\n            value = _options$mouseMoveCur.value,\n            noValue = _options$mouseMoveCur.noValue;\n\n        var style = this._map.getContainer().style;\n        style.cursor = v.value !== null ? value : noValue;\n    },\n\n    _updateOpacity: function _updateOpacity() {\n        L.DomUtil.setOpacity(this._canvas, this.options.opacity);\n    },\n\n    _queryValue: function _queryValue(e) {\n        var v = this._field ? this._field.valueAt(e.latlng.lng, e.latlng.lat) : null;\n        var result = {\n            latlng: e.latlng,\n            value: v\n        };\n        return result;\n    },\n\n    _getDrawingContext: function _getDrawingContext() {\n        var g = this._canvas.getContext('2d');\n        g.clearRect(0, 0, this._canvas.width, this._canvas.height);\n        return g;\n    }\n});\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Cell__ = __webpack_require__(0);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n\n\n/**\n * ScalarField on canvas (a 'Raster')\n */\nL.CanvasLayer.ScalarField = L.CanvasLayer.Field.extend({\n    options: {\n        type: 'colormap', // [colormap|vector]\n        color: null, // function colorFor(value) [e.g. chromajs.scale],\n        interpolate: false, // Change to use interpolation\n        vectorSize: 20, // only used if 'vector'\n        arrowDirection: 'from' // [from|towards]\n    },\n\n    initialize: function initialize(scalarField, options) {\n        L.CanvasLayer.Field.prototype.initialize.call(this, scalarField, options);\n        L.Util.setOptions(this, options);\n    },\n\n    _defaultColorScale: function _defaultColorScale() {\n        return chroma.scale(['white', 'black']).domain(this._field.range);\n    },\n\n    setColor: function setColor(f) {\n        this.options.color = f;\n        this.needRedraw();\n    },\n\n\n    /* eslint-disable no-unused-vars */\n    onDrawLayer: function onDrawLayer(viewInfo) {\n        if (!this.isVisible()) return;\n        this._updateOpacity();\n\n        var r = this._getRendererMethod();\n        //console.time('onDrawLayer');\n        r();\n        //console.timeEnd('onDrawLayer');\n    },\n    /* eslint-enable no-unused-vars */\n\n    _getRendererMethod: function _getRendererMethod() {\n        switch (this.options.type) {\n            case 'colormap':\n                return this._drawImage.bind(this);\n            case 'vector':\n                return this._drawArrows.bind(this);\n            default:\n                throw Error('Unkwown renderer type: ' + this.options.type);\n        }\n    },\n\n    _ensureColor: function _ensureColor() {\n        if (this.options.color === null) {\n            this.setColor(this._defaultColorScale());\n        }\n    },\n\n    _showCanvas: function _showCanvas() {\n        L.CanvasLayer.Field.prototype._showCanvas.call(this);\n        this.needRedraw(); // TODO check spurious redraw (e.g. hide/show without moving map)\n    },\n\n\n    /**\n     * Draws the field in an ImageData and applying it with putImageData.\n     * Used as a reference: http://geoexamples.com/d3-raster-tools-docs/code_samples/raster-pixels-page.html\n     */\n    _drawImage: function _drawImage() {\n        this._ensureColor();\n\n        var ctx = this._getDrawingContext();\n        var width = this._canvas.width;\n        var height = this._canvas.height;\n\n        var img = ctx.createImageData(width, height);\n        var data = img.data;\n\n        this._prepareImageIn(data, width, height);\n        ctx.putImageData(img, 0, 0);\n    },\n\n    /**\n     * Prepares the image in data, as array with RGBAs\n     * [R1, G1, B1, A1, R2, G2, B2, A2...]\n     * @private\n     * @param {[[Type]]} data   [[Description]]\n     * @param {Numver} width\n     * @param {Number} height\n     */\n    _prepareImageIn: function _prepareImageIn(data, width, height) {\n        var f = this.options.interpolate ? 'interpolatedValueAt' : 'valueAt';\n\n        var pos = 0;\n        for (var j = 0; j < height; j++) {\n            for (var i = 0; i < width; i++) {\n                var pointCoords = this._map.containerPointToLatLng([i, j]);\n                var lon = pointCoords.lng;\n                var lat = pointCoords.lat;\n\n                var v = this._field[f](lon, lat); // 'valueAt' | 'interpolatedValueAt' || TODO check some 'artifacts'\n                if (v !== null) {\n                    var color = this._getColorFor(v);\n\n                    var _color$rgba = color.rgba(),\n                        _color$rgba2 = _slicedToArray(_color$rgba, 4),\n                        R = _color$rgba2[0],\n                        G = _color$rgba2[1],\n                        B = _color$rgba2[2],\n                        A = _color$rgba2[3];\n\n                    data[pos] = R;\n                    data[pos + 1] = G;\n                    data[pos + 2] = B;\n                    data[pos + 3] = parseInt(A * 255); // not percent in alpha but hex 0-255\n                }\n                pos = pos + 4;\n            }\n        }\n    },\n\n\n    /**\n     * Draws the field as a set of arrows. Direction from 0 to 360 is assumed.\n     */\n    _drawArrows: function _drawArrows() {\n        var bounds = this._pixelBounds();\n        var pixelSize = (bounds.max.x - bounds.min.x) / this._field.nCols;\n\n        var stride = Math.max(1, Math.floor(1.2 * this.options.vectorSize / pixelSize));\n\n        var ctx = this._getDrawingContext();\n        ctx.strokeStyle = this.options.color;\n\n        var currentBounds = this._map.getBounds();\n\n        for (var y = 0; y < this._field.height; y = y + stride) {\n            for (var x = 0; x < this._field.width; x = x + stride) {\n                var _field$_lonLatAtIndex = this._field._lonLatAtIndexes(x, y),\n                    _field$_lonLatAtIndex2 = _slicedToArray(_field$_lonLatAtIndex, 2),\n                    lon = _field$_lonLatAtIndex2[0],\n                    lat = _field$_lonLatAtIndex2[1];\n\n                var v = this._field.valueAt(lon, lat);\n                var center = L.latLng(lat, lon);\n                if (v !== null && currentBounds.contains(center)) {\n                    var cell = new __WEBPACK_IMPORTED_MODULE_0__Cell__[\"a\" /* default */](center, v, this.cellXSize, this.cellYSize);\n                    this._drawArrow(cell, ctx);\n                }\n            }\n        }\n    },\n\n    _pixelBounds: function _pixelBounds() {\n        var bounds = this.getBounds();\n        var northWest = this._map.latLngToContainerPoint(bounds.getNorthWest());\n        var southEast = this._map.latLngToContainerPoint(bounds.getSouthEast());\n        var pixelBounds = L.bounds(northWest, southEast);\n        return pixelBounds;\n    },\n\n    _drawArrow: function _drawArrow(cell, ctx) {\n        var projected = this._map.latLngToContainerPoint(cell.center);\n\n        // colormap vs. simple color\n        var color = this.options.color;\n        if (typeof color === 'function') {\n            ctx.strokeStyle = color(cell.value);\n        }\n\n        var size = this.options.vectorSize;\n        ctx.save();\n\n        ctx.translate(projected.x, projected.y);\n\n        var rotationRads = (90 + cell.value) * Math.PI / 180; // from, by default\n        if (this.options.arrowDirection === 'towards') {\n            rotationRads = rotationRads + Math.PI;\n        }\n        ctx.rotate(rotationRads);\n\n        ctx.beginPath();\n        ctx.moveTo(-size / 2, 0);\n        ctx.lineTo(+size / 2, 0);\n        ctx.moveTo(size * 0.25, -size * 0.25);\n        ctx.lineTo(+size / 2, 0);\n        ctx.lineTo(size * 0.25, size * 0.25);\n        ctx.stroke();\n        ctx.restore();\n    },\n\n    /**\n     * Gets a chroma color for a pixel value, according to 'options.color'\n     */\n    _getColorFor: function _getColorFor(v) {\n        var c = this.options.color; // e.g. for a constant 'red'\n        if (typeof c === 'function') {\n            c = this.options.color(v);\n        }\n        var color = chroma(c); // to be more flexible, a chroma color object is always created || TODO improve efficiency\n        return color;\n    }\n});\n\nL.canvasLayer.scalarField = function (scalarField, options) {\n    return new L.CanvasLayer.ScalarField(scalarField, options);\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n *  Simple layer with lon-lat points\n *\n *  TODO rename to SimplePoint?\n */\nL.CanvasLayer.SimpleLonLat = L.CanvasLayer.extend({\n    options: {\n        color: 'gray'\n    },\n\n    initialize: function initialize(points, options) {\n        this.points = points;\n        L.Util.setOptions(this, options);\n    },\n\n    onLayerDidMount: function onLayerDidMount() {\n        // -- prepare custom drawing\n    },\n\n    onLayerWillUnmount: function onLayerWillUnmount() {\n        // -- custom cleanup\n    },\n\n    /* eslint-disable no-unused-vars */\n    setData: function setData(data) {\n        // -- custom data set\n        this.needRedraw(); // -- call to drawLayer\n    },\n    /* eslint-enable no-unused-vars */\n\n    onDrawLayer: function onDrawLayer(viewInfo) {\n        // canvas preparation\n        var g = viewInfo.canvas.getContext('2d');\n        g.clearRect(0, 0, viewInfo.canvas.width, viewInfo.canvas.height);\n        g.fillStyle = this.options.color;\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = this.points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var point = _step.value;\n\n                var p = viewInfo.layer._map.latLngToContainerPoint(point);\n                g.beginPath();\n                //g.arc(p.x, p.y, 1, 0, Math.PI * 2); // circle | TODO style 'function' as parameter?\n                g.fillRect(p.x, p.y, 2, 2); //simple point\n                g.fill();\n                g.closePath();\n                g.stroke();\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    },\n\n    getBounds: function getBounds() {\n        // TODO: bounding with points...\n        var xs = this.points.map(function (pt) {\n            return pt.lng;\n        });\n        var ys = this.points.map(function (pt) {\n            return pt.lat;\n        });\n\n        var xmin = Math.min.apply(Math, _toConsumableArray(xs));\n        var ymin = Math.min.apply(Math, _toConsumableArray(ys));\n        var xmax = Math.max.apply(Math, _toConsumableArray(xs));\n        var ymax = Math.max.apply(Math, _toConsumableArray(ys));\n\n        var southWest = L.latLng(ymin, xmin),\n            northEast = L.latLng(ymax, xmax);\n        var bounds = L.latLngBounds(southWest, northEast); // TODO FIX ERROR ? half-pixel?\n        return bounds;\n    }\n});\n\nL.canvasLayer.simpleLonLat = function (lonslats, options) {\n    return new L.CanvasLayer.SimpleLonLat(lonslats, options);\n};\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n/**\n * Animated VectorField on canvas\n */\nL.CanvasLayer.VectorFieldAnim = L.CanvasLayer.Field.extend({\n    options: {\n        paths: 800,\n        color: 'white', // html-color | function colorFor(value) [e.g. chromajs.scale]\n        width: 1.0, // number | function widthFor(value)\n        fade: 0.96, // 0 to 1\n        duration: 20, // milliseconds per 'frame'\n        maxAge: 200, // number of maximum frames per path\n        velocityScale: 1 / 5000\n    },\n\n    initialize: function initialize(vectorField, options) {\n        L.CanvasLayer.Field.prototype.initialize.call(this, vectorField, options);\n        L.Util.setOptions(this, options);\n\n        this.timer = null;\n    },\n\n    onLayerDidMount: function onLayerDidMount() {\n        L.CanvasLayer.Field.prototype.onLayerDidMount.call(this);\n        this._map.on('move resize', this._stopAnimation, this);\n    },\n\n    onLayerWillUnmount: function onLayerWillUnmount() {\n        L.CanvasLayer.Field.prototype.onLayerWillUnmount.call(this);\n        this._map.off('move resize', this._stopAnimation, this);\n        this._stopAnimation();\n    },\n\n    _hideCanvas: function _showCanvas() {\n        L.CanvasLayer.Field.prototype._hideCanvas.call(this);\n        this._stopAnimation();\n    },\n\n    onDrawLayer: function onDrawLayer(viewInfo) {\n        if (!this._field || !this.isVisible()) return;\n\n        this._updateOpacity();\n\n        var ctx = this._getDrawingContext();\n        var paths = this._prepareParticlePaths();\n\n        this.timer = d3.timer(function () {\n            _moveParticles();\n            _drawParticles();\n        }, this.options.duration);\n\n        var self = this;\n\n        /**\n         * Builds the paths, adding 'particles' on each animation step, considering\n         * their properties (age / position source > target)\n         */\n        function _moveParticles() {\n            // let screenFactor = 1 / self._map.getZoom(); // consider using a 'screenFactor' to ponderate velocityScale\n            paths.forEach(function (par) {\n                if (par.age > self.options.maxAge) {\n                    // restart, on a random x,y\n                    par.age = 0;\n                    self._field.randomPosition(par);\n                }\n\n                var vector = self._field.valueAt(par.x, par.y);\n                if (vector === null) {\n                    par.age = self.options.maxAge;\n                } else {\n                    // the next point will be...\n                    var xt = par.x + vector.u * self.options.velocityScale; //* screenFactor;\n                    var yt = par.y + vector.v * self.options.velocityScale; //* screenFactor;\n\n                    if (self._field.hasValueAt(xt, yt)) {\n                        par.xt = xt;\n                        par.yt = yt;\n                        par.m = vector.magnitude();\n                    } else {\n                        // not visible anymore...\n                        par.age = self.options.maxAge;\n                    }\n                }\n                par.age += 1;\n            });\n        }\n\n        /**\n         * Draws the paths on each step\n         */\n        function _drawParticles() {\n            // Previous paths...\n            var prev = ctx.globalCompositeOperation;\n            ctx.globalCompositeOperation = 'destination-in';\n            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n            //ctx.globalCompositeOperation = 'source-over';\n            ctx.globalCompositeOperation = prev;\n\n            // fading paths...\n            ctx.fillStyle = 'rgba(0, 0, 0, ' + self.options.fade + ')';\n            ctx.lineWidth = self.options.width;\n            ctx.strokeStyle = self.options.color;\n\n            // New paths\n            paths.forEach(function (par) {\n                self._drawParticle(viewInfo, ctx, par);\n            });\n        }\n    },\n\n    _drawParticle: function _drawParticle(viewInfo, ctx, par) {\n        var source = new L.latLng(par.y, par.x);\n        var target = new L.latLng(par.yt, par.xt);\n\n        if (viewInfo.bounds.contains(source) && par.age <= this.options.maxAge) {\n            var pA = viewInfo.layer._map.latLngToContainerPoint(source);\n            var pB = viewInfo.layer._map.latLngToContainerPoint(target);\n\n            ctx.beginPath();\n            ctx.moveTo(pA.x, pA.y);\n            ctx.lineTo(pB.x, pB.y);\n\n            // next-step movement\n            par.x = par.xt;\n            par.y = par.yt;\n\n            // colormap vs. simple color\n            var color = this.options.color;\n            if (typeof color === 'function') {\n                ctx.strokeStyle = color(par.m);\n            }\n\n            var width = this.options.width;\n            if (typeof width === 'function') {\n                ctx.lineWidth = width(par.m);\n            }\n\n            ctx.stroke();\n        }\n    },\n\n\n    _prepareParticlePaths: function _prepareParticlePaths() {\n        var paths = [];\n\n        for (var i = 0; i < this.options.paths; i++) {\n            var p = this._field.randomPosition();\n            p.age = this._randomAge();\n            paths.push(p);\n        }\n        return paths;\n    },\n\n    _randomAge: function _randomAge() {\n        return Math.floor(Math.random() * this.options.maxAge);\n    },\n\n    _stopAnimation: function _stopAnimation() {\n        if (this.timer) {\n            this.timer.stop();\n        }\n    }\n});\n\nL.canvasLayer.vectorFieldAnim = function (vectorField, options) {\n    return new L.CanvasLayer.VectorFieldAnim(vectorField, options);\n};\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n/*\n  1.0.1 (downloaded from https://github.com/Sumbera/gLayers.Leaflet/releases/tag/v1.0.1)\n\n  Generic  Canvas Layer for leaflet 0.7 and 1.0-rc,\n  copyright Stanislav Sumbera,  2016 , sumbera.com , license MIT\n  originally created and motivated by L.CanvasOverlay  available here: https://gist.github.com/Sumbera/11114288\n*/\n\nL.CanvasLayer = L.Layer.extend({\n    // -- initialized is called on prototype\n    initialize: function initialize(options) {\n        this._map = null;\n        this._canvas = null;\n        this._frame = null;\n        this._delegate = null;\n        L.setOptions(this, options);\n    },\n\n    delegate: function delegate(del) {\n        this._delegate = del;\n        return this;\n    },\n\n    needRedraw: function needRedraw() {\n        if (!this._frame) {\n            this._frame = L.Util.requestAnimFrame(this.drawLayer, this);\n        }\n        return this;\n    },\n\n    //-------------------------------------------------------------\n    _onLayerDidResize: function _onLayerDidResize(resizeEvent) {\n        this._canvas.width = resizeEvent.newSize.x;\n        this._canvas.height = resizeEvent.newSize.y;\n    },\n    //-------------------------------------------------------------\n    _onLayerDidMove: function _onLayerDidMove() {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n        this.drawLayer();\n    },\n    //-------------------------------------------------------------\n    getEvents: function getEvents() {\n        var events = {\n            resize: this._onLayerDidResize,\n            moveend: this._onLayerDidMove\n        };\n        if (this._map.options.zoomAnimation && L.Browser.any3d) {\n            events.zoomanim = this._animateZoom;\n        }\n\n        return events;\n    },\n    //-------------------------------------------------------------\n    onAdd: function onAdd(map) {\n        this._map = map;\n        this._canvas = L.DomUtil.create('canvas', 'leaflet-layer');\n        this.tiles = {};\n\n        var size = this._map.getSize();\n        this._canvas.width = size.x;\n        this._canvas.height = size.y;\n\n        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\n        L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\n\n        map._panes.overlayPane.appendChild(this._canvas);\n\n        map.on(this.getEvents(), this);\n\n        var del = this._delegate || this;\n        del.onLayerDidMount && del.onLayerDidMount(); // -- callback\n\n        this.needRedraw();\n    },\n\n    //-------------------------------------------------------------\n    onRemove: function onRemove(map) {\n        var del = this._delegate || this;\n        del.onLayerWillUnmount && del.onLayerWillUnmount(); // -- callback\n\n\n        map.getPanes().overlayPane.removeChild(this._canvas);\n\n        map.off(this.getEvents(), this);\n\n        this._canvas = null;\n    },\n\n    //------------------------------------------------------------\n    addTo: function addTo(map) {\n        map.addLayer(this);\n        return this;\n    },\n    // --------------------------------------------------------------------------------\n    LatLonToMercator: function LatLonToMercator(latlon) {\n        return {\n            x: latlon.lng * 6378137 * Math.PI / 180,\n            y: Math.log(Math.tan((90 + latlon.lat) * Math.PI / 360)) * 6378137\n        };\n    },\n\n    //------------------------------------------------------------------------------\n    drawLayer: function drawLayer() {\n        // -- todo make the viewInfo properties  flat objects.\n        var size = this._map.getSize();\n        var bounds = this._map.getBounds();\n        var zoom = this._map.getZoom();\n\n        var center = this.LatLonToMercator(this._map.getCenter());\n        var corner = this.LatLonToMercator(this._map.containerPointToLatLng(this._map.getSize()));\n\n        var del = this._delegate || this;\n        del.onDrawLayer && del.onDrawLayer({\n            layer: this,\n            canvas: this._canvas,\n            bounds: bounds,\n            size: size,\n            zoom: zoom,\n            center: center,\n            corner: corner\n        });\n        this._frame = null;\n    },\n\n    //------------------------------------------------------------------------------\n    _animateZoom: function _animateZoom(e) {\n        var scale = this._map.getZoomScale(e.zoom);\n        var offset = this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), e.zoom, e.center);\n\n        L.DomUtil.setTransform(this._canvas, offset, scale);\n    }\n});\n\nL.canvasLayer = function () {\n    return new L.CanvasLayer();\n};\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar invariant = __webpack_require__(12);\nvar getCoord = invariant.getCoord;\nvar getCoords = invariant.getCoords;\n\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can\n * be convex or concave. The function accounts for holes.\n *\n * @name inside\n * @param {Feature<Point>} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {boolean} [ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.inside(pt, poly);\n * //= true\n */\nmodule.exports = function (point, polygon, ignoreBoundary) {\n    // validation\n    if (!point) throw new Error('point is required');\n    if (!polygon) throw new Error('polygon is required');\n\n    var pt = getCoord(point);\n    var polys = getCoords(polygon);\n    var type = (polygon.geometry) ? polygon.geometry.type : polygon.type;\n    var bbox = polygon.bbox;\n\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) return false;\n\n    // normalize to multipolygon\n    if (type === 'Polygon') polys = [polys];\n\n    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) insidePoly = true;\n        }\n    }\n    return insidePoly;\n};\n\n/**\n * inRing\n *\n * @private\n * @param {[number, number]} pt [x,y]\n * @param {Array<[number, number]>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0], yi = ring[i][1];\n        var xj = ring[j][0], yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) return !ignoreBoundary;\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\n\n/**\n * inBBox\n *\n * @private\n * @param {[number, number]} pt point [x,y]\n * @param {[number, number, number, number]} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n           bbox[1] <= pt[1] &&\n           bbox[2] >= pt[0] &&\n           bbox[3] >= pt[1];\n}\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {string} GeoJSON Geometry Type\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeomType(point)\n * //=\"Point\"\n */\nfunction getGeomType(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    var geom = getGeom(geojson);\n    if (geom) return geom.type;\n}\n\nmodule.exports = {\n    geojsonType: geojsonType,\n    collectionOf: collectionOf,\n    featureOf: featureOf,\n    getCoord: getCoord,\n    getCoords: getCoords,\n    containsNumber: containsNumber,\n    getGeom: getGeom,\n    getGeomType: getGeomType\n};\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Vector_js__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Cell_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Field_js__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ScalarField_js__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__VectorField_js__ = __webpack_require__(4);\n// base\n\nwindow.L.Vector = __WEBPACK_IMPORTED_MODULE_0__Vector_js__[\"a\" /* default */];\n\n\nwindow.L.Cell = __WEBPACK_IMPORTED_MODULE_1__Cell_js__[\"a\" /* default */];\n\n\nwindow.L.Field = __WEBPACK_IMPORTED_MODULE_2__Field_js__[\"a\" /* default */];\n\n\nwindow.L.ScalarField = __WEBPACK_IMPORTED_MODULE_3__ScalarField_js__[\"a\" /* default */];\n\n\nwindow.L.VectorField = __WEBPACK_IMPORTED_MODULE_4__VectorField_js__[\"a\" /* default */];\n\n// layer\n__webpack_require__(10);\n__webpack_require__(8);\n__webpack_require__(6);\n__webpack_require__(7);\n__webpack_require__(9);\n\n// control\n__webpack_require__(5);\n\n/* eslint-disable no-console */\nconsole.log('leaflet.canvaslayer.field v1.4.1 (in progress...)');\n/* eslint-enable no-console */\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// leaflet.canvaslayer.field.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 13);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0bcbaaf1c252f301c32f","/**\n *  Simple regular cell in a raster\n */\nexport default class Cell {\n    /**\n     * A simple cell with a numerical value\n     * @param {L.LatLng} center\n     * @param {Number|Vector} value\n     * @param {Number} xSize\n     * @param {Number} ySize\n     */\n    constructor(center, value, xSize, ySize = xSize) {\n        this.center = center;\n        this.value = value;\n        this.xSize = xSize;\n        this.ySize = ySize;\n    }\n\n    equals(anotherCell) {\n        return (\n            this.center.equals(anotherCell.center) &&\n            this._equalValues(this.value, anotherCell.value) &&\n            this.xSize === anotherCell.xSize &&\n            this.ySize === anotherCell.ySize\n        );\n    }\n\n    _equalValues(value, anotherValue) {\n        let type = value.constructor.name;\n        let answerFor = {\n            Number: value === anotherValue,\n            Vector: value.u === anotherValue.u && value.v === anotherValue.v\n        };\n        return answerFor[type];\n    }\n\n    /**\n     * Bounds for the cell\n     * @returns {LatLngBounds}\n     */\n    getBounds() {\n        let halfX = this.xSize / 2.0;\n        let halfY = this.ySize / 2.0;\n        let cLat = this.center.lat;\n        let cLng = this.center.lng;\n        let ul = L.latLng([cLat + halfY, cLng - halfX]);\n        let lr = L.latLng([cLat - halfY, cLng + halfX]);\n\n        return L.latLngBounds(\n            L.latLng(lr.lat, ul.lng),\n            L.latLng(ul.lat, lr.lng)\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./Cell.js","import Cell from './Cell';\nimport inside from '@turf/inside';\n\n/**\n *  Abstract class for a set of values (Vector | Scalar)\n *  assigned to a regular 2D-grid (lon-lat), aka 'a Raster source'\n */\nexport default class Field {\n    constructor(params) {\n        this.params = params;\n\n        this.nCols = params['nCols'];\n        this.nRows = params['nRows'];\n\n        // alias\n        this.width = params['nCols'];\n        this.height = params['nRows'];\n\n        // ll = lower-left\n        this.xllCorner = params['xllCorner'];\n        this.yllCorner = params['yllCorner'];\n\n        // ur = upper-right\n        this.xurCorner =\n            params['xllCorner'] + params['nCols'] * params['cellXSize'];\n        this.yurCorner =\n            params['yllCorner'] + params['nRows'] * params['cellYSize'];\n\n        this.cellXSize = params['cellXSize'];\n        this.cellYSize = params['cellYSize'];\n\n        this.grid = null; // to be defined by subclasses\n        this.isContinuous = this.xurCorner - this.xllCorner >= 360;\n        this.longitudeNeedsToBeWrapped = this.xurCorner > 180; // [0, 360] --> [-180, 180]\n\n        this._inFilter = null;\n        this._spatialMask = null;\n    }\n\n    /**\n     * Builds a grid with a value at each point (either Vector or Number)\n     * Original params must include the required input values, following\n     * x-ascending & y-descending order (same as in ASCIIGrid)\n     * @abstract\n     * @private\n     * @returns {Array.<Array.<Vector|Number>>} - grid[row][column]--> Vector|Number\n     */\n    _buildGrid() {\n        throw new TypeError('Must be overriden');\n    }\n\n    _updateRange() {\n        this.range = this._calculateRange();\n    }\n\n    /**\n     * Number of cells in the grid (rows * cols)\n     * @returns {Number}\n     */\n    numCells() {\n        return this.nRows * this.nCols;\n    }\n\n    /**\n     * A list with every cell\n     * @returns {Array<Cell>} - cells (x-ascending & y-descending order)\n     */\n    getCells(stride = 1) {\n        let cells = [];\n        for (let j = 0; j < this.nRows; j = j + stride) {\n            for (let i = 0; i < this.nCols; i = i + stride) {\n                let [lon, lat] = this._lonLatAtIndexes(i, j);\n                let center = L.latLng(lat, lon);\n                let value = this._valueAtIndexes(i, j);\n                let c = new Cell(center, value, this.cellXSize, this.cellYSize);\n                cells.push(c); // <<\n            }\n        }\n        return cells;\n    }\n\n    /**\n     * Apply a filter function to field values\n     * @param   {Function} f - boolean function\n     */\n    setFilter(f) {\n        this._inFilter = f;\n        this._updateRange();\n    }\n\n    /**\n     * Apply a spatial mask to field values\n     * @param {L.GeoJSON} m \n     */\n    setSpatialMask(m) {\n        this._spatialMask = m;\n    }\n\n    /**\n     * Grid extent\n     * @returns {Number[]} [xmin, ymin, xmax, ymax]\n     */\n    extent() {\n        let [xmin, xmax] = this._getWrappedLongitudes();\n        return [xmin, this.yllCorner, xmax, this.yurCorner];\n    }\n\n    /**\n     * [xmin, xmax] in [-180, 180] range\n     */\n    _getWrappedLongitudes() {\n        let xmin = this.xllCorner;\n        let xmax = this.xurCorner;\n\n        if (this.longitudeNeedsToBeWrapped) {\n            if (this.isContinuous) {\n                xmin = -180;\n                xmax = 180;\n            } else {\n                // not sure about this (just one particular case, but others...?)\n                xmax = this.xurCorner - 360;\n                xmin = this.xllCorner - 360;\n                /* eslint-disable no-console */\n                // console.warn(`are these xmin: ${xmin} & xmax: ${xmax} OK?`);\n                // TODO: Better throw an exception on no-controlled situations.\n                /* eslint-enable no-console */\n            }\n        }\n        return [xmin, xmax];\n    }\n\n    /**\n     * Returns whether or not the grid contains the point, considering\n     * the spatialMask if it has been previously set\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    contains(lon, lat) {\n        if (this._spatialMask) {\n            return this._pointInMask(lon, lat);\n        }\n        return this._pointInExtent(lon, lat);\n    }\n\n    /**\n     * Checks if coordinates are inside the Extent (considering wrapped longitudes if needed)\n     * @param {Number} lon \n     * @param {Number} lat \n     */\n    _pointInExtent(lon, lat) {\n        let [xmin, xmax] = this._getWrappedLongitudes();\n        let longitudeIn = lon >= xmin && lon <= xmax;\n        let latitudeIn = lat >= this.yllCorner && lat <= this.yurCorner;\n        return longitudeIn && latitudeIn;\n    }\n\n    /**\n     * Check if coordinates are inside the spatialMask (Point in Polygon analysis)\n     * @param {Number} lon \n     * @param {Number} lat \n     */\n    _pointInMask(lon, lat) {\n        const pt = {\n            type: 'Feature',\n            geometry: {\n                type: 'Point',\n                coordinates: [lon, lat] // geojson, lon-lat order !\n            },\n            properties: {}\n        };\n        const poly = this._spatialMask;\n        return inside(pt, poly);\n    }\n\n    /**\n     * Returns if the grid doesn't contain the point\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    notContains(lon, lat) {\n        return !this.contains(lon, lat);\n    }\n\n    /**\n     * Interpolated value at lon-lat coordinates (bilinear method)\n     * @param   {Number} longitude\n     * @param   {Number} latitude\n     * @returns {Vector|Number} [u, v, magnitude]\n     *                          \n     * Source: https://github.com/cambecc/earth > product.js\n     */\n    interpolatedValueAt(lon, lat) {\n        if (this.notContains(lon, lat)) return null;\n\n        let [i, j] = this._getDecimalIndexes(lon, lat);\n        return this.interpolatedValueAtIndexes(i, j);\n    }\n\n    /**\n     * Interpolated value at i-j indexes (bilinear method)\n     * @param   {Number} i\n     * @param   {Number} j\n     * @returns {Vector|Number} [u, v, magnitude]\n     *\n     * Source: https://github.com/cambecc/earth > product.js\n     */\n    interpolatedValueAtIndexes(i, j) {\n        //         1      2           After converting  and  to fractional grid indexes i and j, we find the\n        //        fi  i   ci          four points 'G' that enclose point (i, j). These points are at the four\n        //         | =1.4 |           corners specified by the floor and ceiling of i and j. For example, given\n        //      ---G--|---G--- fj 8   i = 1.4 and j = 8.3, the four surrounding grid points are (1, 8), (2, 8),\n        //    j ___|_ .   |           (1, 9) and (2, 9).\n        //  =8.3   |      |\n        //      ---G------G--- cj 9   Note that for wrapped grids, the first column is duplicated as the last\n        //         |      |           column, so the index ci can be used without taking a modulo.\n\n        let indexes = this._getFourSurroundingIndexes(i, j);\n        let [fi, ci, fj, cj] = indexes;\n        let values = this._getFourSurroundingValues(fi, ci, fj, cj);\n        if (values) {\n            let [g00, g10, g01, g11] = values;\n            return this._doInterpolation(i - fi, j - fj, g00, g10, g01, g11);\n        }\n        return null;\n    }\n\n    /**\n     * Get decimal indexes\n     * @private\n     * @param {Number} lon\n     * @param {Number} lat\n     * @returns {Array}    [[Description]]\n     */\n    _getDecimalIndexes(lon, lat) {\n        if (this.longitudeNeedsToBeWrapped && lon < this.xllCorner) {\n            lon = lon + 360;\n        }\n        let i = (lon - this.xllCorner) / this.cellXSize;\n        let j = (this.yurCorner - lat) / this.cellYSize;\n        return [i, j];\n    }\n\n    /**\n     * Get surrounding indexes (integer), clampling on borders\n     * @private\n     * @param   {Number} i - decimal index\n     * @param   {Number} j - decimal index\n     * @returns {Array} [fi, ci, fj, cj]\n     */\n    _getFourSurroundingIndexes(i, j) {\n        let fi = Math.floor(i);\n        let ci = fi + 1;\n        // duplicate colum to simplify interpolation logic (wrapped value)\n        if (this.isContinuous && ci >= this.nCols) {\n            ci = 0;\n        }\n        ci = this._clampColumnIndex(ci);\n\n        let fj = this._clampRowIndex(Math.floor(j));\n        let cj = this._clampRowIndex(fj + 1);\n\n        return [fi, ci, fj, cj];\n    }\n\n    /**\n     * Get four surrounding values or null if not available,\n     * from 4 integer indexes\n     * @private\n     * @param   {Number} fi\n     * @param   {Number} ci\n     * @param   {Number} fj\n     * @param   {Number} cj\n     * @returns {Array} \n     */\n    _getFourSurroundingValues(fi, ci, fj, cj) {\n        var row;\n        if ((row = this.grid[fj])) {\n            // upper row ^^\n            var g00 = row[fi]; // << left\n            var g10 = row[ci]; // right >>\n            if (\n                this._isValid(g00) &&\n                this._isValid(g10) &&\n                (row = this.grid[cj])\n            ) {\n                // lower row vv\n                var g01 = row[fi]; // << left\n                var g11 = row[ci]; // right >>\n                if (this._isValid(g01) && this._isValid(g11)) {\n                    return [g00, g10, g01, g11]; // 4 values found!\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Nearest value at lon-lat coordinates\n     * @param   {Number} longitude\n     * @param   {Number} latitude\n     * @returns {Vector|Number}\n     */\n    valueAt(lon, lat) {\n        if (this.notContains(lon, lat)) return null;\n\n        let [i, j] = this._getDecimalIndexes(lon, lat);\n        let ii = Math.floor(i);\n        let jj = Math.floor(j);\n\n        const ci = this._clampColumnIndex(ii);\n        const cj = this._clampRowIndex(jj);\n\n        let value = this._valueAtIndexes(ci, cj);\n        if (this._inFilter) {\n            if (!this._inFilter(value)) return null;\n        }\n\n        return value;\n    }\n\n    /**\n     * Returns whether or not the field has a value at the point\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    hasValueAt(lon, lat) {\n        let value = this.valueAt(lon, lat);\n        let hasValue = value !== null;\n\n        let included = true;\n        if (this._inFilter) {\n            included = this._inFilter(value);\n        }\n        return hasValue && included;\n    }\n\n    /**\n     * Returns if the grid has no value at the point\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    notHasValueAt(lon, lat) {\n        return !this.hasValueAt(lon, lat);\n    }\n\n    /**\n     * Gives a random position to 'o' inside the grid\n     * @param {Object} [o] - an object (eg. a particle)\n     * @returns {{x: Number, y: Number}} - object with x, y (lon, lat)\n     */\n    randomPosition(o = {}) {\n        let i = (Math.random() * this.nCols) | 0;\n        let j = (Math.random() * this.nRows) | 0;\n\n        o.x = this._longitudeAtX(i);\n        o.y = this._latitudeAtY(j);\n\n        return o;\n    }\n\n    /**\n     * Value for grid indexes\n     * @param   {Number} i - column index (integer)\n     * @param   {Number} j - row index (integer)\n     * @returns {Vector|Number}\n     */\n    _valueAtIndexes(i, j) {\n        return this.grid[j][i]; // <-- j,i !!\n    }\n\n    /**\n     * Lon-Lat for grid indexes\n     * @param   {Number} i - column index (integer)\n     * @param   {Number} j - row index (integer)\n     * @returns {Number[]} [lon, lat]\n     */\n    _lonLatAtIndexes(i, j) {\n        let lon = this._longitudeAtX(i);\n        let lat = this._latitudeAtY(j);\n\n        return [lon, lat];\n    }\n\n    /**\n     * Longitude for grid-index\n     * @param   {Number} i - column index (integer)\n     * @returns {Number} longitude at the center of the cell\n     */\n    _longitudeAtX(i) {\n        let halfXPixel = this.cellXSize / 2.0;\n        let lon = this.xllCorner + halfXPixel + i * this.cellXSize;\n        if (this.longitudeNeedsToBeWrapped) {\n            lon = lon > 180 ? lon - 360 : lon;\n        }\n        return lon;\n    }\n\n    /**\n     * Latitude for grid-index\n     * @param   {Number} j - row index (integer)\n     * @returns {Number} latitude at the center of the cell\n     */\n    _latitudeAtY(j) {\n        let halfYPixel = this.cellYSize / 2.0;\n        return this.yurCorner - halfYPixel - j * this.cellYSize;\n    }\n\n    /**\n     * Apply the interpolation\n     * @abstract\n     * @private\n     */\n    /* eslint-disable no-unused-vars */\n    _doInterpolation(x, y, g00, g10, g01, g11) {\n        throw new TypeError('Must be overriden');\n    }\n    /* eslint-disable no-unused-vars */\n\n    /**\n     * Check the column index is inside the field,\n     * adjusting to min or max when needed\n     * @private\n     * @param   {Number} ii - index\n     * @returns {Number} i - inside the allowed indexes\n     */\n    _clampColumnIndex(ii) {\n        let i = ii;\n        if (ii < 0) {\n            i = 0;\n        }\n        let maxCol = this.nCols - 1;\n        if (ii > maxCol) {\n            i = maxCol;\n        }\n        return i;\n    }\n\n    /**\n     * Check the row index is inside the field,\n     * adjusting to min or max when needed\n     * @private\n     * @param   {Number} jj index\n     * @returns {Number} j - inside the allowed indexes\n     */\n    _clampRowIndex(jj) {\n        let j = jj;\n        if (jj < 0) {\n            j = 0;\n        }\n        let maxRow = this.nRows - 1;\n        if (jj > maxRow) {\n            j = maxRow;\n        }\n        return j;\n    }\n\n    /**\n     * Is valid (not 'null' nor 'undefined')\n     * @private\n     * @param   {Object} x object\n     * @returns {Boolean}\n     */\n    _isValid(x) {\n        return x !== null && x !== undefined;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./Field.js","import Field from './Field';\n\n/**\n * Scalar Field\n */\nexport default class ScalarField extends Field {\n    /**\n     * Creates a ScalarField from the content of an ASCIIGrid file\n     * @param   {String}   asc\n     * @returns {ScalarField}\n     */\n    static fromASCIIGrid(asc, scaleFactor = 1) {\n        //console.time('ScalarField from ASC');\n\n        let lines = asc.split('\\n');\n\n        // Header\n        ScalarField._checkIsValidASCIIGridHeader(lines);\n\n        let n = /-?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/; // any number\n\n        const cellSize = parseFloat(lines[4].match(n)); // right now, no different x-y size is allowed\n        let p = {\n            nCols: parseInt(lines[0].match(n)),\n            nRows: parseInt(lines[1].match(n)),\n            xllCorner: parseFloat(lines[2].match(n)),\n            yllCorner: parseFloat(lines[3].match(n)),\n            cellXSize: cellSize,\n            cellYSize: cellSize\n        };\n        let noDataValue = lines[5]\n            .toUpperCase()\n            .replace('NODATA_VALUE', '')\n            .trim();\n\n        // Data (left-right and top-down)\n        let zs = []; // TODO Consider using TypedArray (& manage NO_DATA)\n        for (let i = 6; i < lines.length; i++) {\n            let line = lines[i].trim();\n            if (line === '') break;\n\n            let items = line.split(' ');\n            items.forEach(it => {\n                const v =\n                    it !== noDataValue ? parseFloat(it * scaleFactor) : null;\n                zs.push(v);\n            });\n        }\n        p.zs = zs;\n\n        //console.timeEnd('ScalarField from ASC');\n        return new ScalarField(p);\n    }\n\n    static _checkIsValidASCIIGridHeader(lines) {\n        const upperCasesLines = lines.map(lin => lin.toUpperCase());\n\n        const parameters = [\n            'NCOLS',\n            'NROWS',\n            'XLLCORNER',\n            'YLLCORNER',\n            'CELLSIZE',\n            'NODATA_VALUE'\n        ];\n\n        let i = 0;\n        for (let expected of parameters) {\n            let line = upperCasesLines[i];\n            let found = line.indexOf(expected) != -1;\n            if (!found) {\n                throw `Not valid ASCIIGrid: expected '${expected}' at line '${\n                    line\n                }' [lin. n ${i}]`;\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Creates a ScalarField from the content of a GeoTIFF file\n     * @param   {ArrayBuffer}   data\n     * @param   {Number}   bandIndex\n     * @returns {ScalarField}\n     */\n    static fromGeoTIFF(data, bandIndex = 0) {\n        return ScalarField.multipleFromGeoTIFF(data, [bandIndex])[0];\n    }\n\n    /**\n     * Creates a ScalarField array (one per band) from the content of a GeoTIFF file\n     * @param   {ArrayBuffer}   data\n     * @param   {Array}   bandIndexes - if not provided all bands are returned\n     * @returns {Array.<ScalarField>}\n     */\n    static multipleFromGeoTIFF(data, bandIndexes) {\n        //console.time('ScalarField from GeoTIFF');\n\n        let tiff = GeoTIFF.parse(data); // geotiff.js\n        let image = tiff.getImage();\n        let rasters = image.readRasters();\n        let tiepoint = image.getTiePoints()[0];\n        let fileDirectory = image.getFileDirectory();\n        let [xScale, yScale] = fileDirectory.ModelPixelScale;\n\n        if (typeof bandIndexes === 'undefined' || bandIndexes.length === 0) {\n            bandIndexes = [...Array(rasters.length).keys()];\n        }\n\n        let scalarFields = [];\n        scalarFields = bandIndexes.map(function(bandIndex) {\n            let zs = rasters[bandIndex]; // left-right and top-down order\n\n            if (fileDirectory.GDAL_NODATA) {\n                let noData = parseFloat(fileDirectory.GDAL_NODATA);\n                // console.log(noData);\n                let simpleZS = Array.from(zs); // to simple array, so null is allowed | TODO efficiency??\n                zs = simpleZS.map(function(z) {\n                    return z === noData ? null : z;\n                });\n            }\n\n            let p = {\n                nCols: image.getWidth(),\n                nRows: image.getHeight(),\n                xllCorner: tiepoint.x,\n                yllCorner: tiepoint.y - image.getHeight() * yScale,\n                cellXSize: xScale,\n                cellYSize: yScale,\n                zs: zs\n            };\n            return new ScalarField(p);\n        });\n\n        //console.timeEnd('ScalarField from GeoTIFF');\n        return scalarFields;\n    }\n\n    constructor(params) {\n        super(params);\n        this.zs = params['zs'];\n\n        this.grid = this._buildGrid();\n        this._updateRange();\n        //console.log(`ScalarField created (${this.nCols} x ${this.nRows})`);\n    }\n\n    /**\n     * Builds a grid with a Number at each point, from an array\n     * 'zs' following x-ascending & y-descending order\n     * (same as in ASCIIGrid)\n     * @private\n     * @returns {Array.<Array.<Number>>} - grid[row][column]--> Number\n     */\n    _buildGrid() {\n        let grid = this._arrayTo2d(this.zs, this.nRows, this.nCols);\n        return grid;\n    }\n\n    _arrayTo2d(array, nRows, nCols) {\n        let grid = [];\n        let p = 0;\n        for (var j = 0; j < nRows; j++) {\n            var row = [];\n            for (var i = 0; i < nCols; i++, p++) {\n                let z = array[p];\n                row[i] = this._isValid(z) ? z : null; // <<<\n            }\n            grid[j] = row;\n        }\n        return grid;\n    }\n\n    _newDataArrays(params) {\n        params['zs'] = [];\n    }\n\n    _pushValueToArrays(params, value) {\n        params['zs'].push(value);\n    }\n\n    _makeNewFrom(params) {\n        return new ScalarField(params);\n    }\n\n    /**\n     * Calculate min & max values\n     * @private\n     * @returns {Array} - [min, max]\n     */\n    _calculateRange() {\n        var data = this.zs;\n        if (this._inFilter) {\n            data = data.filter(this._inFilter);\n        }\n        return [d3.min(data), d3.max(data)];\n    }\n\n    /**\n     * Bilinear interpolation for Number\n     * https://en.wikipedia.org/wiki/Bilinear_interpolation\n     * @param   {Number} x\n     * @param   {Number} y\n     * @param   {Number} g00\n     * @param   {Number} g10\n     * @param   {Number} g01\n     * @param   {Number} g11\n     * @returns {Number}\n     */\n    _doInterpolation(x, y, g00, g10, g01, g11) {\n        var rx = 1 - x;\n        var ry = 1 - y;\n        return g00 * rx * ry + g10 * x * ry + g01 * rx * y + g11 * x * y;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./ScalarField.js","/**\n *  2D Vector\n */\nexport default class Vector {\n\n    constructor(u, v) {\n        this.u = u;\n        this.v = v;\n    }\n\n    /**\n     * Magnitude\n     * @returns {Number}\n     */\n    magnitude() {\n        return Math.sqrt(this.u * this.u + this.v * this.v);\n    }\n\n    /**\n     * Angle in degrees (0 to 360) --> Towards\n     * N is 0 and E is 90\n     * @returns {Number}\n     */\n    directionTo() {\n        let verticalAngle = Math.atan2(this.u, this.v);\n        let inDegrees = verticalAngle * (180.0 / Math.PI);\n        if (inDegrees < 0) {\n            inDegrees = inDegrees + 360.0;\n        }\n        return inDegrees;\n    }\n\n    /**\n     * Angle in degrees (0 to 360) From x-->\n     * N is 0 and E is 90\n     * @returns {Number}\n     */\n    directionFrom() {\n        let a = this.directionTo();\n        let opposite = (a + 180.0) % 360.0;\n        return opposite;\n    }\n\n    /*\n        Degrees --> text\n        new Dictionary<int, string>\n        {\n            //{0, 23, 45, 68, 90, 113, 135, 158, 180, 203, 225, 248, 270, 293, 315, 338, 360};\n            {0, 'N'},\n            {23, 'NNE'},\n            {45, 'NE'},\n            {68, 'ENE'},\n            {90, 'E'},\n            {113, 'ESE'},\n            {135, 'SE'},\n            {158, 'SSE'},\n            {180, 'S'},\n            {203, 'SSW'},\n            {225, 'SW'},\n            {248, 'WSW'},\n            {270, 'W'},\n            {293, 'WNW'},\n            {315, 'NW'},\n            {338, 'NNW'},\n            {360, 'N'}\n        };\n    */\n}\n\n\n\n// WEBPACK FOOTER //\n// ./Vector.js","import Vector from './Vector';\nimport Field from './Field';\nimport ScalarField from './ScalarField';\n\n/**\n *  A set of vectors assigned to a regular 2D-grid (lon-lat)\n *  (e.g. a raster representing winds for a region)\n */\nexport default class VectorField extends Field {\n    /**\n     * Creates a VectorField from the content of two ASCIIGrid files\n     * @param   {String} ascU - with u-component\n     * @param   {String} ascV - with v-component\n     * @returns {VectorField}\n     */\n    static fromASCIIGrids(ascU, ascV, scaleFactor = 1) {\n        let u = ScalarField.fromASCIIGrid(ascU, scaleFactor);\n        let v = ScalarField.fromASCIIGrid(ascV, scaleFactor);\n        let p = VectorField._paramsFromScalarFields(u, v);\n\n        return new VectorField(p);\n    }\n\n    /**\n     * Creates a VectorField from the content of two different Geotiff files\n     * @param   {ArrayBuffer} gtU - geotiff data with u-component (band 0)\n     * @param   {ArrayBuffer} gtV - geotiff data with v-component (band 0)\n     * @returns {VectorField}\n     */\n    static fromGeoTIFFs(gtU, gtV) {\n        let u = ScalarField.fromGeoTIFF(gtU);\n        let v = ScalarField.fromGeoTIFF(gtV);\n        let p = VectorField._paramsFromScalarFields(u, v);\n\n        return new VectorField(p);\n    }\n\n    /**\n     * Creates a VectorField from the content of Multiband Geotiff\n     * @param   {ArrayBuffer} geotiffData - multiband\n     * @param   {Array} bandIndexesForUV\n     * @returns {VectorField}\n     */\n    static fromMultibandGeoTIFF(geotiffData, bandIndexesForUV = [0, 1]) {\n        let [u, v] = ScalarField.multipleFromGeoTIFF(\n            geotiffData,\n            bandIndexesForUV\n        );\n        let p = VectorField._paramsFromScalarFields(u, v);\n\n        return new VectorField(p);\n    }\n\n    /**\n     * Build parameters for VectorField, from 2 ScalarFields.\n     * No validation at all (nor interpolation) is applied, so u and v\n     * must be 'compatible' from the source\n     * @param   {ScalarField} u\n     * @param   {ScalarField} v\n     * @returns {Object} - parameters to build VectorField\n     */\n    static _paramsFromScalarFields(u, v) {\n        // TODO check u & v compatibility (cellSize...)\n        let p = {\n            nCols: u.nCols,\n            nRows: u.nRows,\n            xllCorner: u.xllCorner,\n            yllCorner: u.yllCorner,\n            cellXSize: u.cellXSize,\n            cellYSize: u.cellYSize,\n            us: u.zs,\n            vs: v.zs\n        };\n        return p;\n    }\n\n    constructor(params) {\n        super(params);\n\n        this.us = params['us'];\n        this.vs = params['vs'];\n        this.grid = this._buildGrid();\n        this.range = this._calculateRange();\n    }\n\n    /**\n     * Get a derived field, from a computation on\n     * the VectorField\n     * @param   {String} type ['magnitude' | 'directionTo' | 'directionFrom']\n     * @returns {ScalarField}\n     */\n    getScalarField(type) {\n        let f = this._getFunctionFor(type);\n        let p = {\n            nCols: this.params.nCols,\n            nRows: this.params.nRows,\n            xllCorner: this.params.xllCorner,\n            yllCorner: this.params.yllCorner,\n            cellXSize: this.params.cellXSize,\n            cellYSize: this.params.cellYSize,\n            zs: this._applyOnField(f)\n        };\n        return new ScalarField(p);\n    }\n\n    _getFunctionFor(type) {\n        return function(u, v) {\n            let uv = new Vector(u, v);\n            return uv[type](); // magnitude, directionTo, directionFrom\n        };\n    }\n\n    _applyOnField(func) {\n        let zs = [];\n        let n = this.numCells();\n        for (var i = 0; i < n; i++) {\n            let u = this.us[i];\n            let v = this.vs[i];\n            if (this._isValid(u) && this._isValid(v)) {\n                zs.push(func(u, v));\n            } else {\n                zs.push(null);\n            }\n        }\n        return zs;\n    }\n\n    /**\n     * Builds a grid with a Vector at each point, from two arrays\n     * 'us' and 'vs' following x-ascending & y-descending order\n     * (same as in ASCIIGrid)\n     * @returns {Array.<Array.<Vector>>} - grid[row][column]--> Vector\n     */\n    _buildGrid() {\n        let grid = this._arraysTo2d(this.us, this.vs, this.nRows, this.nCols);\n        return grid;\n    }\n\n    _arraysTo2d(us, vs, nRows, nCols) {\n        let grid = [];\n        let p = 0;\n\n        for (var j = 0; j < nRows; j++) {\n            var row = [];\n            for (var i = 0; i < nCols; i++, p++) {\n                let u = us[p],\n                    v = vs[p];\n                let valid = this._isValid(u) && this._isValid(v);\n                row[i] = valid ? new Vector(u, v) : null; // <<<\n            }\n            grid[j] = row;\n        }\n        return grid;\n    }\n\n    _newDataArrays(params) {\n        params['us'] = [];\n        params['vs'] = [];\n    }\n    _pushValueToArrays(params, value) {\n        //console.log(value);\n        params['us'].push(value.u);\n        params['vs'].push(value.v);\n    }\n    _makeNewFrom(params) {\n        return new VectorField(params);\n    }\n\n    /**\n     * Calculate min & max values (magnitude)\n     * @private\n     * @returns {Array}\n     */\n    _calculateRange() {\n        // TODO make a clearer method for getting these vectors...\n        let vectors = this.getCells()\n            .map(pt => pt.value)\n            .filter(function(v) {\n                return v !== null;\n            });\n\n        if (this._inFilter) {\n            vectors = vectors.filter(this._inFilter);\n        }\n\n        // TODO check memory crash with high num of vectors!\n        let magnitudes = vectors.map(v => v.magnitude());\n        let min = d3.min(magnitudes);\n        let max = d3.max(magnitudes);\n\n        return [min, max];\n    }\n\n    /**\n     * Bilinear interpolation for Vector\n     * https://en.wikipedia.org/wiki/Bilinear_interpolation\n     * @param   {Number} x\n     * @param   {Number} y\n     * @param   {Number[]} g00\n     * @param   {Number[]} g10\n     * @param   {Number[]} g01\n     * @param   {Number[]} g11\n     * @returns {Vector}\n     */\n    _doInterpolation(x, y, g00, g10, g01, g11) {\n        var rx = 1 - x;\n        var ry = 1 - y;\n        var a = rx * ry,\n            b = x * ry,\n            c = rx * y,\n            d = x * y;\n        var u = g00.u * a + g10.u * b + g01.u * c + g11.u * d;\n        var v = g00.v * a + g10.v * b + g01.v * c + g11.v * d;\n        return new Vector(u, v);\n    }\n\n    /**\n     * Is valid (not 'null' nor 'undefined')\n     * @private\n     * @param   {Object} x object\n     * @returns {Boolean}\n     */\n    _isValid(x) {\n        return x !== null && x !== undefined;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./VectorField.js","/**\n *   Control for a simple legend with a colorbar\n *   References:\n *      - http://jsfiddle.net/ramnathv/g8stqcf6/\n *      - http://jsfiddle.net/vis4/cYLZH/\n */\nL.Control.ColorBar = L.Control.extend({\n    options: {\n        position: 'bottomleft',\n        width: 300, // for colorbar itself (control is wider)\n        height: 15,\n        margin: 15,\n        background: '#fff',\n        textColor: 'black',\n        steps: 100,\n        decimals: 2,\n        units: 'uds', // ej: m/s\n        title: 'Legend', // ej: Ocean Currents\n        labels: [], // empty for no labels\n        labelFontSize: 10,\n        labelTextPosition: 'middle' // start | middle | end\n    },\n\n    initialize: function(color, range, options) {\n        this.color = color; // 'chromajs' scale function\n        this.range = range; // [min, max]\n        L.Util.setOptions(this, options);\n    },\n\n    onAdd: function(map) {\n        this._map = map;\n        let div = L.DomUtil.create(\n            'div',\n            'leaflet-control-colorBar leaflet-bar leaflet-control'\n        );\n        div.style.padding = '10px';\n\n        L.DomEvent\n            .addListener(div, 'click', L.DomEvent.stopPropagation)\n            .addListener(div, 'click', L.DomEvent.preventDefault);\n        div.style.backgroundColor = this.options.background;\n        div.style.cursor = 'text';\n        div.innerHTML = this.title() + this.palette();\n        return div;\n    },\n\n    title: function() {\n        let d = document.createElement('div');\n        d3\n            .select(d)\n            .append('span')\n            .style('color', this.options.textColor)\n            .style('display', 'block')\n            .style('margin-bottom', '5px')\n            .attr('class', 'leaflet-control-colorBar-title')\n            .text(this.options.title);\n        return d.innerHTML;\n    },\n\n    palette: function() {\n        let d = document.createElement('div');\n        let svg = this._createSvgIn(d);\n\n        this._appendColorBarTo(svg);\n\n        if (this.options.labels) {\n            this._appendLabelsTo(svg);\n        }\n\n        return d.innerHTML;\n    },\n\n    _createSvgIn: function(d) {\n        let spaceForLabels = this.options.labels ? this.options.margin : 0;\n        let svg = d3\n            .select(d)\n            .append('svg')\n            .attr('width', this.options.width + this.options.margin * 2)\n            .attr('height', this.options.height + spaceForLabels);\n        return svg;\n    },\n\n    _appendColorBarTo: function(svg) {\n        const colorPerValue = this._getColorPerValue();\n        const w = this.options.width / colorPerValue.length;\n\n        let groupBars = svg.append('g').attr('id', 'colorBar-buckets');\n        let buckets = groupBars\n            .selectAll('rect')\n            .data(colorPerValue)\n            .enter()\n            .append('rect');\n        buckets\n            .attr('x', (d, i) => i * w + this.options.margin)\n            .attr('y', () => 0)\n            .attr('height', () => this.options.height /*w * 4*/)\n            .attr('width', () => w)\n            .attr('stroke-width', 2)\n            .attr('stroke-linecap', 'butt')\n            .attr('stroke', d => d.color.hex())\n            .attr('fill', d => d.color.hex());\n        buckets\n            .append('title')\n            .text(\n                d =>\n                    `${d.value.toFixed(this.options.decimals)} ${this.options\n                        .units}`\n            );\n    },\n\n    _appendLabelsTo: function(svg) {\n        const positionPerLabelValue = this._getPositionPerLabelValue();\n        //const w = this.options.width / colorPerValue.length;\n        let groupLabels = svg.append('g').attr('id', 'colorBar-labels');\n        let labels = groupLabels\n            .selectAll('text')\n            .data(positionPerLabelValue)\n            .enter()\n            .append('text');\n        labels\n            .attr('x', d => d.position + this.options.margin)\n            .attr('y', this.options.height + this.options.margin)\n            .attr('font-size', `${this.options.labelFontSize}px`)\n            .attr('text-anchor', this.options.labelTextPosition)\n            .attr('fill', this.options.textColor)\n            .attr('class', 'leaflet-control-colorBar-label')\n            .text(d => `${d.value.toFixed(this.options.decimals)}`);\n    },\n\n    _getColorPerValue: function() {\n        const [min, max] = this.range;\n        let delta = (max - min) / this.options.steps;\n        let data = d3.range(min, max + delta, delta);\n        let colorPerValue = data.map(d => {\n            return {\n                value: d,\n                color: this.color(d)\n            };\n        });\n        return colorPerValue;\n    },\n\n    _getPositionPerLabelValue: function() {\n        var xPositionFor = d3\n            .scaleLinear()\n            .range([0, this.options.width])\n            .domain(this.range);\n        let data = this.options.labels;\n        let positionPerLabel = data.map(d => {\n            return {\n                value: d,\n                position: xPositionFor(d)\n            };\n        });\n        return positionPerLabel;\n    }\n});\n\nL.control.colorBar = function(color, range, options) {\n    return new L.Control.ColorBar(color, range, options);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./control/L.Control.ColorBar.js","/**\n * Abstract class for a Field layer on canvas, aka 'a Raster layer'\n * (ScalarField or a VectorField)\n */\nL.CanvasLayer.Field = L.CanvasLayer.extend({\n    options: {\n        mouseMoveCursor: {\n            value: 'pointer',\n            noValue: 'default'\n        },\n        opacity: 1,\n        onClick: null,\n        onMouseMove: null,\n        inFilter: null\n    },\n\n    initialize: function(field, options) {\n        L.Util.setOptions(this, options);\n        this._visible = true;\n        if (field) {\n            this.setData(field);\n        }\n    },\n\n    getEvents: function() {\n        var events = L.CanvasLayer.prototype.getEvents.call(this);\n        events.zoomstart = this._hideCanvas.bind(this);\n        events.zoomend = this._showCanvas.bind(this);\n        return events;\n    },\n\n    onLayerDidMount: function() {\n        this._enableIdentify();\n        this._ensureCanvasAlignment();\n    },\n\n    show() {\n        this._visible = true;\n        this._showCanvas();\n        this._enableIdentify();\n    },\n\n    hide() {\n        this._visible = false;\n        this._hideCanvas();\n        this._disableIdentify();\n    },\n\n    isVisible() {\n        return this._visible;\n    },\n\n    _showCanvas() {\n        if (this._canvas && this._visible) {\n            this._canvas.style.visibility = 'visible';\n        }\n    },\n\n    _hideCanvas() {\n        if (this._canvas) {\n            this._canvas.style.visibility = 'hidden';\n        }\n    },\n\n    _enableIdentify() {\n        this._map.on('click', this._onClick, this);\n        this._map.on('mousemove', this._onMouseMove, this);\n\n        this.options.onClick && this.on('click', this.options.onClick, this);\n        this.options.onMouseMove &&\n            this.on('mousemove', this.options.onMouseMove, this);\n    },\n\n    _disableIdentify() {\n        this._map.off('click', this._onClick, this);\n        this._map.off('mousemove', this._onMouseMove, this);\n\n        this.options.onClick && this.off('click', this.options.onClick, this);\n        this.options.onMouseMove &&\n            this.off('mousemove', this.options.onMouseMove, this);\n    },\n\n    _ensureCanvasAlignment() {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n    },\n\n    onLayerWillUnmount: function() {\n        this._disableIdentify();\n    },\n\n    needRedraw() {\n        if (this._map && this._field) {\n            L.CanvasLayer.prototype.needRedraw.call(this);\n        }\n    },\n\n    /* eslint-disable no-unused-vars */\n    onDrawLayer: function(viewInfo) {\n        throw new TypeError('Must be overriden');\n    },\n    /* eslint-enable no-unused-vars */\n\n    setData: function(field) {\n        this.options.inFilter && field.setFilter(this.options.inFilter);\n        this._field = field;\n        this.needRedraw();\n        this.fire('load');\n    },\n\n    setFilter: function(f) {\n        this.options.inFilter = f;\n        this._field && this._field.setFilter(f);\n        this.needRedraw();\n    },\n\n    setOpacity: function(opacity) {\n        this.options.opacity = opacity;\n\n        if (this._canvas) {\n            this._updateOpacity();\n        }\n        return this;\n    },\n\n    getBounds: function() {\n        let bb = this._field.extent();\n\n        let southWest = L.latLng(bb[1], bb[0]),\n            northEast = L.latLng(bb[3], bb[2]);\n        let bounds = L.latLngBounds(southWest, northEast);\n        return bounds;\n    },\n\n    _onClick: function(e) {\n        let v = this._queryValue(e);\n        this.fire('click', v);\n    },\n\n    _onMouseMove: function(e) {\n        let v = this._queryValue(e);\n        this._changeCursorOn(v);\n        this.fire('mousemove', v);\n    },\n\n    _changeCursorOn: function(v) {\n        if (!this.options.mouseMoveCursor) return;\n\n        let { value, noValue } = this.options.mouseMoveCursor;\n        let style = this._map.getContainer().style;\n        style.cursor = v.value !== null ? value : noValue;\n    },\n\n    _updateOpacity: function() {\n        L.DomUtil.setOpacity(this._canvas, this.options.opacity);\n    },\n\n    _queryValue: function(e) {\n        let v = this._field\n            ? this._field.valueAt(e.latlng.lng, e.latlng.lat)\n            : null;\n        let result = {\n            latlng: e.latlng,\n            value: v\n        };\n        return result;\n    },\n\n    _getDrawingContext: function() {\n        let g = this._canvas.getContext('2d');\n        g.clearRect(0, 0, this._canvas.width, this._canvas.height);\n        return g;\n    }\n});\n\n\n\n// WEBPACK FOOTER //\n// ./layer/L.CanvasLayer.Field.js","import Cell from '../Cell';\n\n/**\n * ScalarField on canvas (a 'Raster')\n */\nL.CanvasLayer.ScalarField = L.CanvasLayer.Field.extend({\n    options: {\n        type: 'colormap', // [colormap|vector]\n        color: null, // function colorFor(value) [e.g. chromajs.scale],\n        interpolate: false, // Change to use interpolation\n        vectorSize: 20, // only used if 'vector'\n        arrowDirection: 'from' // [from|towards]\n    },\n\n    initialize: function(scalarField, options) {\n        L.CanvasLayer.Field.prototype.initialize.call(\n            this,\n            scalarField,\n            options\n        );\n        L.Util.setOptions(this, options);\n    },\n\n    _defaultColorScale: function() {\n        return chroma.scale(['white', 'black']).domain(this._field.range);\n    },\n\n    setColor(f) {\n        this.options.color = f;\n        this.needRedraw();\n    },\n\n    /* eslint-disable no-unused-vars */\n    onDrawLayer: function(viewInfo) {\n        if (!this.isVisible()) return;\n        this._updateOpacity();\n\n        let r = this._getRendererMethod();\n        //console.time('onDrawLayer');\n        r();\n        //console.timeEnd('onDrawLayer');\n    },\n    /* eslint-enable no-unused-vars */\n\n    _getRendererMethod: function() {\n        switch (this.options.type) {\n            case 'colormap':\n                return this._drawImage.bind(this);\n            case 'vector':\n                return this._drawArrows.bind(this);\n            default:\n                throw Error(`Unkwown renderer type: ${this.options.type}`);\n        }\n    },\n\n    _ensureColor: function() {\n        if (this.options.color === null) {\n            this.setColor(this._defaultColorScale());\n        }\n    },\n\n    _showCanvas() {\n        L.CanvasLayer.Field.prototype._showCanvas.call(this);\n        this.needRedraw(); // TODO check spurious redraw (e.g. hide/show without moving map)\n    },\n\n    /**\n     * Draws the field in an ImageData and applying it with putImageData.\n     * Used as a reference: http://geoexamples.com/d3-raster-tools-docs/code_samples/raster-pixels-page.html\n     */\n    _drawImage: function() {\n        this._ensureColor();\n\n        let ctx = this._getDrawingContext();\n        let width = this._canvas.width;\n        let height = this._canvas.height;\n\n        let img = ctx.createImageData(width, height);\n        let data = img.data;\n\n        this._prepareImageIn(data, width, height);\n        ctx.putImageData(img, 0, 0);\n    },\n\n    /**\n     * Prepares the image in data, as array with RGBAs\n     * [R1, G1, B1, A1, R2, G2, B2, A2...]\n     * @private\n     * @param {[[Type]]} data   [[Description]]\n     * @param {Numver} width\n     * @param {Number} height\n     */\n    _prepareImageIn(data, width, height) {\n        let f = this.options.interpolate ? 'interpolatedValueAt' : 'valueAt';\n\n        let pos = 0;\n        for (let j = 0; j < height; j++) {\n            for (let i = 0; i < width; i++) {\n                let pointCoords = this._map.containerPointToLatLng([i, j]);\n                let lon = pointCoords.lng;\n                let lat = pointCoords.lat;\n\n                let v = this._field[f](lon, lat); // 'valueAt' | 'interpolatedValueAt' || TODO check some 'artifacts'\n                if (v !== null) {\n                    let color = this._getColorFor(v);\n                    let [R, G, B, A] = color.rgba();\n                    data[pos] = R;\n                    data[pos + 1] = G;\n                    data[pos + 2] = B;\n                    data[pos + 3] = parseInt(A * 255); // not percent in alpha but hex 0-255\n                }\n                pos = pos + 4;\n            }\n        }\n    },\n\n    /**\n     * Draws the field as a set of arrows. Direction from 0 to 360 is assumed.\n     */\n    _drawArrows: function() {\n        const bounds = this._pixelBounds();\n        const pixelSize = (bounds.max.x - bounds.min.x) / this._field.nCols;\n\n        var stride = Math.max(\n            1,\n            Math.floor(1.2 * this.options.vectorSize / pixelSize)\n        );\n\n        const ctx = this._getDrawingContext();\n        ctx.strokeStyle = this.options.color;\n\n        var currentBounds = this._map.getBounds();\n\n        for (var y = 0; y < this._field.height; y = y + stride) {\n            for (var x = 0; x < this._field.width; x = x + stride) {\n                let [lon, lat] = this._field._lonLatAtIndexes(x, y);\n                let v = this._field.valueAt(lon, lat);\n                let center = L.latLng(lat, lon);\n                if (v !== null && currentBounds.contains(center)) {\n                    let cell = new Cell(\n                        center,\n                        v,\n                        this.cellXSize,\n                        this.cellYSize\n                    );\n                    this._drawArrow(cell, ctx);\n                }\n            }\n        }\n    },\n\n    _pixelBounds: function() {\n        const bounds = this.getBounds();\n        const northWest = this._map.latLngToContainerPoint(\n            bounds.getNorthWest()\n        );\n        const southEast = this._map.latLngToContainerPoint(\n            bounds.getSouthEast()\n        );\n        var pixelBounds = L.bounds(northWest, southEast);\n        return pixelBounds;\n    },\n\n    _drawArrow: function(cell, ctx) {\n        var projected = this._map.latLngToContainerPoint(cell.center);\n\n        // colormap vs. simple color\n        let color = this.options.color;\n        if (typeof color === 'function') {\n            ctx.strokeStyle = color(cell.value);\n        }\n\n        const size = this.options.vectorSize;\n        ctx.save();\n\n        ctx.translate(projected.x, projected.y);\n\n        let rotationRads = (90 + cell.value) * Math.PI / 180; // from, by default\n        if (this.options.arrowDirection === 'towards') {\n            rotationRads = rotationRads + Math.PI;\n        }\n        ctx.rotate(rotationRads);\n\n        ctx.beginPath();\n        ctx.moveTo(-size / 2, 0);\n        ctx.lineTo(+size / 2, 0);\n        ctx.moveTo(size * 0.25, -size * 0.25);\n        ctx.lineTo(+size / 2, 0);\n        ctx.lineTo(size * 0.25, size * 0.25);\n        ctx.stroke();\n        ctx.restore();\n    },\n\n    /**\n     * Gets a chroma color for a pixel value, according to 'options.color'\n     */\n    _getColorFor(v) {\n        let c = this.options.color; // e.g. for a constant 'red'\n        if (typeof c === 'function') {\n            c = this.options.color(v);\n        }\n        let color = chroma(c); // to be more flexible, a chroma color object is always created || TODO improve efficiency\n        return color;\n    }\n});\n\nL.canvasLayer.scalarField = function(scalarField, options) {\n    return new L.CanvasLayer.ScalarField(scalarField, options);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./layer/L.CanvasLayer.ScalarField.js","/**\n *  Simple layer with lon-lat points\n *\n *  TODO rename to SimplePoint?\n */\nL.CanvasLayer.SimpleLonLat = L.CanvasLayer.extend({\n    options: {\n        color: 'gray'\n    },\n\n    initialize: function(points, options) {\n        this.points = points;\n        L.Util.setOptions(this, options);\n    },\n\n    onLayerDidMount: function() {\n        // -- prepare custom drawing\n    },\n\n    onLayerWillUnmount: function() {\n        // -- custom cleanup\n    },\n\n    /* eslint-disable no-unused-vars */\n    setData: function(data) {\n        // -- custom data set\n        this.needRedraw(); // -- call to drawLayer\n    },\n    /* eslint-enable no-unused-vars */\n\n    onDrawLayer: function(viewInfo) {\n        // canvas preparation\n        let g = viewInfo.canvas.getContext('2d');\n        g.clearRect(0, 0, viewInfo.canvas.width, viewInfo.canvas.height);\n        g.fillStyle = this.options.color;\n\n        for (let point of this.points) {\n            let p = viewInfo.layer._map.latLngToContainerPoint(point);\n            g.beginPath();\n            //g.arc(p.x, p.y, 1, 0, Math.PI * 2); // circle | TODO style 'function' as parameter?\n            g.fillRect(p.x, p.y, 2, 2); //simple point\n            g.fill();\n            g.closePath();\n            g.stroke();\n        }\n    },\n\n    getBounds: function() {\n        // TODO: bounding with points...\n        let xs = this.points.map(pt => pt.lng);\n        let ys = this.points.map(pt => pt.lat);\n\n        let xmin = Math.min(...xs);\n        let ymin = Math.min(...ys);\n        let xmax = Math.max(...xs);\n        let ymax = Math.max(...ys);\n\n        let southWest = L.latLng(ymin, xmin),\n            northEast = L.latLng(ymax, xmax);\n        let bounds = L.latLngBounds(southWest, northEast); // TODO FIX ERROR ? half-pixel?\n        return bounds;\n    }\n});\n\nL.canvasLayer.simpleLonLat = function(lonslats, options) {\n    return new L.CanvasLayer.SimpleLonLat(lonslats, options);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./layer/L.CanvasLayer.SimpleLonLat.js","/**\n * Animated VectorField on canvas\n */\nL.CanvasLayer.VectorFieldAnim = L.CanvasLayer.Field.extend({\n    options: {\n        paths: 800,\n        color: 'white', // html-color | function colorFor(value) [e.g. chromajs.scale]\n        width: 1.0, // number | function widthFor(value)\n        fade: 0.96, // 0 to 1\n        duration: 20, // milliseconds per 'frame'\n        maxAge: 200, // number of maximum frames per path\n        velocityScale: 1 / 5000\n    },\n\n    initialize: function(vectorField, options) {\n        L.CanvasLayer.Field.prototype.initialize.call(\n            this,\n            vectorField,\n            options\n        );\n        L.Util.setOptions(this, options);\n\n        this.timer = null;\n    },\n\n    onLayerDidMount: function() {\n        L.CanvasLayer.Field.prototype.onLayerDidMount.call(this);\n        this._map.on('move resize', this._stopAnimation, this);\n    },\n\n    onLayerWillUnmount: function() {\n        L.CanvasLayer.Field.prototype.onLayerWillUnmount.call(this);\n        this._map.off('move resize', this._stopAnimation, this);\n        this._stopAnimation();\n    },\n\n    _hideCanvas: function _showCanvas() {\n        L.CanvasLayer.Field.prototype._hideCanvas.call(this);\n        this._stopAnimation();\n    },\n\n    onDrawLayer: function(viewInfo) {\n        if (!this._field || !this.isVisible()) return;\n\n        this._updateOpacity();\n\n        let ctx = this._getDrawingContext();\n        let paths = this._prepareParticlePaths();\n\n        this.timer = d3.timer(function() {\n            _moveParticles();\n            _drawParticles();\n        }, this.options.duration);\n\n        let self = this;\n\n        /**\n         * Builds the paths, adding 'particles' on each animation step, considering\n         * their properties (age / position source > target)\n         */\n        function _moveParticles() {\n            // let screenFactor = 1 / self._map.getZoom(); // consider using a 'screenFactor' to ponderate velocityScale\n            paths.forEach(function(par) {\n                if (par.age > self.options.maxAge) {\n                    // restart, on a random x,y\n                    par.age = 0;\n                    self._field.randomPosition(par);\n                }\n\n                let vector = self._field.valueAt(par.x, par.y);\n                if (vector === null) {\n                    par.age = self.options.maxAge;\n                } else {\n                    // the next point will be...\n                    let xt = par.x + vector.u * self.options.velocityScale; //* screenFactor;\n                    let yt = par.y + vector.v * self.options.velocityScale; //* screenFactor;\n\n                    if (self._field.hasValueAt(xt, yt)) {\n                        par.xt = xt;\n                        par.yt = yt;\n                        par.m = vector.magnitude();\n                    } else {\n                        // not visible anymore...\n                        par.age = self.options.maxAge;\n                    }\n                }\n                par.age += 1;\n            });\n        }\n\n        /**\n         * Draws the paths on each step\n         */\n        function _drawParticles() {\n            // Previous paths...\n            let prev = ctx.globalCompositeOperation;\n            ctx.globalCompositeOperation = 'destination-in';\n            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n            //ctx.globalCompositeOperation = 'source-over';\n            ctx.globalCompositeOperation = prev;\n\n            // fading paths...\n            ctx.fillStyle = `rgba(0, 0, 0, ${self.options.fade})`;\n            ctx.lineWidth = self.options.width;\n            ctx.strokeStyle = self.options.color;\n\n            // New paths\n            paths.forEach(function(par) {\n                self._drawParticle(viewInfo, ctx, par);\n            });\n        }\n    },\n\n    _drawParticle(viewInfo, ctx, par) {\n        let source = new L.latLng(par.y, par.x);\n        let target = new L.latLng(par.yt, par.xt);\n\n        if (\n            viewInfo.bounds.contains(source) &&\n            par.age <= this.options.maxAge\n        ) {\n            let pA = viewInfo.layer._map.latLngToContainerPoint(source);\n            let pB = viewInfo.layer._map.latLngToContainerPoint(target);\n\n            ctx.beginPath();\n            ctx.moveTo(pA.x, pA.y);\n            ctx.lineTo(pB.x, pB.y);\n\n            // next-step movement\n            par.x = par.xt;\n            par.y = par.yt;\n\n            // colormap vs. simple color\n            let color = this.options.color;\n            if (typeof color === 'function') {\n                ctx.strokeStyle = color(par.m);\n            }\n\n            let width = this.options.width;\n            if (typeof width === 'function') {\n                ctx.lineWidth = width(par.m);\n            }\n\n            ctx.stroke();\n        }\n    },\n\n    _prepareParticlePaths: function() {\n        let paths = [];\n\n        for (var i = 0; i < this.options.paths; i++) {\n            let p = this._field.randomPosition();\n            p.age = this._randomAge();\n            paths.push(p);\n        }\n        return paths;\n    },\n\n    _randomAge: function() {\n        return Math.floor(Math.random() * this.options.maxAge);\n    },\n\n    _stopAnimation: function() {\n        if (this.timer) {\n            this.timer.stop();\n        }\n    }\n});\n\nL.canvasLayer.vectorFieldAnim = function(vectorField, options) {\n    return new L.CanvasLayer.VectorFieldAnim(vectorField, options);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./layer/L.CanvasLayer.VectorFieldAnim.js","/*\n  1.0.1 (downloaded from https://github.com/Sumbera/gLayers.Leaflet/releases/tag/v1.0.1)\n\n  Generic  Canvas Layer for leaflet 0.7 and 1.0-rc,\n  copyright Stanislav Sumbera,  2016 , sumbera.com , license MIT\n  originally created and motivated by L.CanvasOverlay  available here: https://gist.github.com/Sumbera/11114288\n*/\n\nL.CanvasLayer = L.Layer.extend({\n    // -- initialized is called on prototype\n    initialize: function (options) {\n        this._map = null;\n        this._canvas = null;\n        this._frame = null;\n        this._delegate = null;\n        L.setOptions(this, options);\n    },\n\n    delegate: function (del) {\n        this._delegate = del;\n        return this;\n    },\n\n    needRedraw: function () {\n        if (!this._frame) {\n            this._frame = L.Util.requestAnimFrame(this.drawLayer, this);\n        }\n        return this;\n    },\n\n    //-------------------------------------------------------------\n    _onLayerDidResize: function (resizeEvent) {\n        this._canvas.width = resizeEvent.newSize.x;\n        this._canvas.height = resizeEvent.newSize.y;\n    },\n    //-------------------------------------------------------------\n    _onLayerDidMove: function () {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n        this.drawLayer();\n    },\n    //-------------------------------------------------------------\n    getEvents: function () {\n        var events = {\n            resize: this._onLayerDidResize,\n            moveend: this._onLayerDidMove\n        };\n        if (this._map.options.zoomAnimation && L.Browser.any3d) {\n            events.zoomanim = this._animateZoom;\n        }\n\n        return events;\n    },\n    //-------------------------------------------------------------\n    onAdd: function (map) {\n        this._map = map;\n        this._canvas = L.DomUtil.create('canvas', 'leaflet-layer');\n        this.tiles = {};\n\n        var size = this._map.getSize();\n        this._canvas.width = size.x;\n        this._canvas.height = size.y;\n\n        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\n        L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\n\n\n        map._panes.overlayPane.appendChild(this._canvas);\n\n        map.on(this.getEvents(), this);\n\n        var del = this._delegate || this;\n        del.onLayerDidMount && del.onLayerDidMount(); // -- callback\n\n        this.needRedraw();\n    },\n\n    //-------------------------------------------------------------\n    onRemove: function (map) {\n        var del = this._delegate || this;\n        del.onLayerWillUnmount && del.onLayerWillUnmount(); // -- callback\n\n\n        map.getPanes().overlayPane.removeChild(this._canvas);\n\n        map.off(this.getEvents(), this);\n\n        this._canvas = null;\n\n    },\n\n    //------------------------------------------------------------\n    addTo: function (map) {\n        map.addLayer(this);\n        return this;\n    },\n    // --------------------------------------------------------------------------------\n    LatLonToMercator: function (latlon) {\n        return {\n            x: latlon.lng * 6378137 * Math.PI / 180,\n            y: Math.log(Math.tan((90 + latlon.lat) * Math.PI / 360)) * 6378137\n        };\n    },\n\n    //------------------------------------------------------------------------------\n    drawLayer: function () {\n        // -- todo make the viewInfo properties  flat objects.\n        var size = this._map.getSize();\n        var bounds = this._map.getBounds();\n        var zoom = this._map.getZoom();\n\n        var center = this.LatLonToMercator(this._map.getCenter());\n        var corner = this.LatLonToMercator(this._map.containerPointToLatLng(this._map.getSize()));\n\n        var del = this._delegate || this;\n        del.onDrawLayer && del.onDrawLayer({\n            layer: this,\n            canvas: this._canvas,\n            bounds: bounds,\n            size: size,\n            zoom: zoom,\n            center: center,\n            corner: corner\n        });\n        this._frame = null;\n    },\n\n    //------------------------------------------------------------------------------\n    _animateZoom: function (e) {\n        var scale = this._map.getZoomScale(e.zoom);\n        var offset = this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), e.zoom, e.center);\n\n        L.DomUtil.setTransform(this._canvas, offset, scale);\n    }\n});\n\nL.canvasLayer = function () {\n    return new L.CanvasLayer();\n};\n\n\n\n// WEBPACK FOOTER //\n// ./layer/L.CanvasLayer.js","var invariant = require('@turf/invariant');\nvar getCoord = invariant.getCoord;\nvar getCoords = invariant.getCoords;\n\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can\n * be convex or concave. The function accounts for holes.\n *\n * @name inside\n * @param {Feature<Point>} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {boolean} [ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.inside(pt, poly);\n * //= true\n */\nmodule.exports = function (point, polygon, ignoreBoundary) {\n    // validation\n    if (!point) throw new Error('point is required');\n    if (!polygon) throw new Error('polygon is required');\n\n    var pt = getCoord(point);\n    var polys = getCoords(polygon);\n    var type = (polygon.geometry) ? polygon.geometry.type : polygon.type;\n    var bbox = polygon.bbox;\n\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) return false;\n\n    // normalize to multipolygon\n    if (type === 'Polygon') polys = [polys];\n\n    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) insidePoly = true;\n        }\n    }\n    return insidePoly;\n};\n\n/**\n * inRing\n *\n * @private\n * @param {[number, number]} pt [x,y]\n * @param {Array<[number, number]>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0], yi = ring[i][1];\n        var xj = ring[j][0], yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) return !ignoreBoundary;\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\n\n/**\n * inBBox\n *\n * @private\n * @param {[number, number]} pt point [x,y]\n * @param {[number, number, number, number]} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n           bbox[1] <= pt[1] &&\n           bbox[2] >= pt[0] &&\n           bbox[3] >= pt[1];\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@turf/inside/index.js\n// module id = 11\n// module chunks = 0","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {string} GeoJSON Geometry Type\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeomType(point)\n * //=\"Point\"\n */\nfunction getGeomType(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    var geom = getGeom(geojson);\n    if (geom) return geom.type;\n}\n\nmodule.exports = {\n    geojsonType: geojsonType,\n    collectionOf: collectionOf,\n    featureOf: featureOf,\n    getCoord: getCoord,\n    getCoords: getCoords,\n    containsNumber: containsNumber,\n    getGeom: getGeom,\n    getGeomType: getGeomType\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@turf/invariant/index.js\n// module id = 12\n// module chunks = 0","// base\nimport Vector from './Vector.js';\nwindow.L.Vector = Vector;\n\nimport Cell from './Cell.js';\nwindow.L.Cell = Cell;\n\nimport Field from './Field.js';\nwindow.L.Field = Field;\n\nimport ScalarField from './ScalarField.js';\nwindow.L.ScalarField = ScalarField;\n\nimport VectorField from './VectorField.js';\nwindow.L.VectorField = VectorField;\n\n// layer\nrequire('./layer/L.CanvasLayer.js');\nrequire('./layer/L.CanvasLayer.SimpleLonLat.js');\nrequire('./layer/L.CanvasLayer.Field.js');\nrequire('./layer/L.CanvasLayer.ScalarField.js');\nrequire('./layer/L.CanvasLayer.VectorFieldAnim.js');\n\n// control\nrequire('./control/L.Control.ColorBar.js');\n\n/* eslint-disable no-console */\nconsole.log('leaflet.canvaslayer.field v1.4.1 (in progress...)');\n/* eslint-enable no-console */\n\n\n\n// WEBPACK FOOTER //\n// ./_main.js"],"sourceRoot":""}