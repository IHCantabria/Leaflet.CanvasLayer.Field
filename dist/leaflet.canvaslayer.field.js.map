{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./Cell.js","webpack:///../node_modules/@turf/inside/index.js","webpack:///../node_modules/@turf/invariant/index.js","webpack:///./layer/L.CanvasLayer.js","webpack:///./layer/L.CanvasLayer.SimpleLonLat.js","webpack:///./layer/L.CanvasLayer.Field.js","webpack:///./layer/L.CanvasLayer.ScalarField.js","webpack:///./layer/L.CanvasLayer.VectorFieldAnim.js","webpack:///./control/L.Control.ColorBar.js","webpack:///./Vector.js","webpack:///./Field.js","webpack:///./ScalarField.js","webpack:///./VectorField.js","webpack:///./_main.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Cell","center","xSize","ySize","this","anotherCell","equals","_equalValues","anotherValue","type","constructor","Number","Vector","u","v","halfX","halfY","cLat","lat","cLng","lng","ul","L","latLng","lr","latLngBounds","invariant","getCoord","getCoords","inRing","pt","ring","ignoreBoundary","isInside","length","slice","j","xi","yi","xj","yj","point","polygon","Error","polys","geometry","bbox","inBBox","insidePoly","inHole","k","obj","coordinates","containsNumber","Array","isArray","getGeom","geojson","undefined","geometries","geojsonType","collectionOf","featureCollection","features","feature","featureOf","getGeomType","geom","CanvasLayer","Layer","extend","initialize","options","_map","_canvas","_frame","_delegate","setOptions","delegate","del","needRedraw","Util","requestAnimFrame","drawLayer","_onLayerDidResize","resizeEvent","width","newSize","x","height","y","_onLayerDidMove","topLeft","containerPointToLayerPoint","DomUtil","setPosition","getEvents","events","resize","moveend","zoomAnimation","Browser","any3d","zoomanim","_animateZoom","onAdd","map","tiles","size","getSize","animated","addClass","_panes","overlayPane","appendChild","on","onLayerDidMount","onRemove","onLayerWillUnmount","getPanes","removeChild","off","addTo","addLayer","LatLonToMercator","latlon","Math","PI","log","tan","bounds","getBounds","zoom","getZoom","getCenter","corner","containerPointToLatLng","onDrawLayer","layer","canvas","e","scale","getZoomScale","offset","_latLngToNewLayerPoint","getNorthWest","setTransform","canvasLayer","SimpleLonLat","color","points","setData","data","viewInfo","g","getContext","clearRect","fillStyle","latLngToContainerPoint","beginPath","fillRect","fill","closePath","stroke","xs","ys","xmin","min","ymin","xmax","max","ymax","southWest","northEast","simpleLonLat","lonslats","Field","mouseMoveCursor","noValue","opacity","onClick","onMouseMove","inFilter","field","_visible","zoomstart","_hideCanvas","zoomend","_showCanvas","_enableIdentify","_ensureCanvasAlignment","show","hide","_disableIdentify","isVisible","style","visibility","_onClick","_onMouseMove","_field","TypeError","setFilter","fire","f","setOpacity","_updateOpacity","bb","extent","_queryValue","_changeCursorOn","getContainer","cursor","valueAt","latlng","_getDrawingContext","ScalarField","interpolate","vectorSize","arrowDirection","scalarField","_defaultColorScale","chroma","domain","range","setColor","_getRendererMethod","_drawImage","_drawArrows","_ensureColor","ctx","img","createImageData","_prepareImageIn","putImageData","pos","pointCoords","lon","_getColorFor","rgba","R","G","B","A","parseInt","_pixelBounds","pixelSize","nCols","stride","floor","strokeStyle","currentBounds","_lonLatAtIndexes","contains","cell","cellXSize","cellYSize","_drawArrow","northWest","southEast","getSouthEast","projected","save","translate","rotationRads","rotate","moveTo","lineTo","restore","VectorFieldAnim","paths","fade","duration","maxAge","velocityScale","vectorField","timer","_stopAnimation","_prepareParticlePaths","d3","prev","forEach","par","age","self","randomPosition","vector","xt","yt","hasValueAt","magnitude","globalCompositeOperation","lineWidth","_drawParticle","source","target","pA","pB","_randomAge","push","random","stop","vectorFieldAnim","Control","ColorBar","position","margin","background","textColor","steps","decimals","units","title","labels","textLabels","labelFontSize","labelTextPosition","div","padding","DomEvent","addListener","stopPropagation","preventDefault","backgroundColor","innerHTML","palette","document","createElement","select","append","attr","text","svg","_createSvgIn","_appendColorBarTo","_appendLabelsTo","spaceForLabels","colorPerValue","_getColorPerValue","w","buckets","selectAll","enter","hex","toFixed","positionPerLabelValue","_getPositionPerLabelValue","label","delta","xPositionFor","scaleLinear","index","control","colorBar","sqrt","inDegrees","atan2","directionTo","params","nRows","xllCorner","yllCorner","xurCorner","yurCorner","grid","isContinuous","longitudeNeedsToBeWrapped","_inFilter","_spatialMask","_calculateRange","cells","_valueAtIndexes","_updateRange","_getWrappedLongitudes","_pointInMask","_pointInExtent","longitudeIn","latitudeIn","properties","poly","inside","notContains","_getDecimalIndexes","interpolatedValueAtIndexes","indexes","_getFourSurroundingIndexes","fi","ci","fj","cj","values","_getFourSurroundingValues","g00","g10","g01","g11","_doInterpolation","_clampColumnIndex","_clampRowIndex","row","_isValid","ii","jj","hasValue","included","_longitudeAtX","_latitudeAtY","halfXPixel","halfYPixel","maxCol","maxRow","zs","_buildGrid","asc","scaleFactor","lines","split","header","_parseASCIIGridHeader","line","trim","items","it","floatItem","parseFloat","noDataValue","headerLines","headerItems","filter","toUpperCase","usesCorner","cellSize","err","bandIndex","multipleFromGeoTIFF","bandIndexes","image","GeoTIFF","parse","getImage","rasters","readRasters","tiepoint","getTiePoints","fileDirectory","getFileDirectory","ModelPixelScale","xScale","yScale","keys","GDAL_NODATA","noData","from","z","getWidth","getHeight","_arrayTo2d","array","rx","ry","VectorField","us","vs","ascU","ascV","fromASCIIGrid","_paramsFromScalarFields","gtU","gtV","fromGeoTIFF","geotiffData","bandIndexesForUV","_getFunctionFor","_applyOnField","func","numCells","_arraysTo2d","valid","vectors","getCells","magnitudes","a","b","window","require"],"mappings":"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","file":"leaflet.canvaslayer.field.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","/**\n *  Simple regular cell in a raster\n */\nexport default class Cell {\n    /**\n     * A simple cell with a numerical value\n     * @param {L.LatLng} center\n     * @param {Number|Vector} value\n     * @param {Number} xSize\n     * @param {Number} ySize\n     */\n    constructor(center, value, xSize, ySize = xSize) {\n        this.center = center;\n        this.value = value;\n        this.xSize = xSize;\n        this.ySize = ySize;\n    }\n\n    equals(anotherCell) {\n        return (\n            this.center.equals(anotherCell.center) &&\n            this._equalValues(this.value, anotherCell.value) &&\n            this.xSize === anotherCell.xSize &&\n            this.ySize === anotherCell.ySize\n        );\n    }\n\n    _equalValues(value, anotherValue) {\n        let type = value.constructor.name;\n        let answerFor = {\n            Number: value === anotherValue,\n            Vector: value.u === anotherValue.u && value.v === anotherValue.v\n        };\n        return answerFor[type];\n    }\n\n    /**\n     * Bounds for the cell\n     * @returns {LatLngBounds}\n     */\n    getBounds() {\n        let halfX = this.xSize / 2.0;\n        let halfY = this.ySize / 2.0;\n        let cLat = this.center.lat;\n        let cLng = this.center.lng;\n        let ul = L.latLng([cLat + halfY, cLng - halfX]);\n        let lr = L.latLng([cLat - halfY, cLng + halfX]);\n\n        return L.latLngBounds(\n            L.latLng(lr.lat, ul.lng),\n            L.latLng(ul.lat, lr.lng)\n        );\n    }\n}\n","var invariant = require('@turf/invariant');\nvar getCoord = invariant.getCoord;\nvar getCoords = invariant.getCoords;\n\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can\n * be convex or concave. The function accounts for holes.\n *\n * @name inside\n * @param {Feature<Point>} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {boolean} [ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.inside(pt, poly);\n * //= true\n */\nmodule.exports = function (point, polygon, ignoreBoundary) {\n    // validation\n    if (!point) throw new Error('point is required');\n    if (!polygon) throw new Error('polygon is required');\n\n    var pt = getCoord(point);\n    var polys = getCoords(polygon);\n    var type = (polygon.geometry) ? polygon.geometry.type : polygon.type;\n    var bbox = polygon.bbox;\n\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) return false;\n\n    // normalize to multipolygon\n    if (type === 'Polygon') polys = [polys];\n\n    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) insidePoly = true;\n        }\n    }\n    return insidePoly;\n};\n\n/**\n * inRing\n *\n * @private\n * @param {[number, number]} pt [x,y]\n * @param {Array<[number, number]>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0], yi = ring[i][1];\n        var xj = ring[j][0], yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) return !ignoreBoundary;\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\n\n/**\n * inBBox\n *\n * @private\n * @param {[number, number]} pt point [x,y]\n * @param {[number, number, number, number]} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n           bbox[1] <= pt[1] &&\n           bbox[2] >= pt[0] &&\n           bbox[3] >= pt[1];\n}\n","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {string} GeoJSON Geometry Type\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeomType(point)\n * //=\"Point\"\n */\nfunction getGeomType(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    var geom = getGeom(geojson);\n    if (geom) return geom.type;\n}\n\nmodule.exports = {\n    geojsonType: geojsonType,\n    collectionOf: collectionOf,\n    featureOf: featureOf,\n    getCoord: getCoord,\n    getCoords: getCoords,\n    containsNumber: containsNumber,\n    getGeom: getGeom,\n    getGeomType: getGeomType\n};\n","/*\n  1.0.1 (downloaded from https://github.com/Sumbera/gLayers.Leaflet/releases/tag/v1.0.1)\n\n  Generic  Canvas Layer for leaflet 0.7 and 1.0-rc,\n  copyright Stanislav Sumbera,  2016 , sumbera.com , license MIT\n  originally created and motivated by L.CanvasOverlay  available here: https://gist.github.com/Sumbera/11114288\n*/\n\nL.CanvasLayer = L.Layer.extend({\n    // -- initialized is called on prototype\n    initialize: function (options) {\n        this._map = null;\n        this._canvas = null;\n        this._frame = null;\n        this._delegate = null;\n        L.setOptions(this, options);\n    },\n\n    delegate: function (del) {\n        this._delegate = del;\n        return this;\n    },\n\n    needRedraw: function () {\n        if (!this._frame) {\n            this._frame = L.Util.requestAnimFrame(this.drawLayer, this);\n        }\n        return this;\n    },\n\n    //-------------------------------------------------------------\n    _onLayerDidResize: function (resizeEvent) {\n        this._canvas.width = resizeEvent.newSize.x;\n        this._canvas.height = resizeEvent.newSize.y;\n    },\n    //-------------------------------------------------------------\n    _onLayerDidMove: function () {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n        this.drawLayer();\n    },\n    //-------------------------------------------------------------\n    getEvents: function () {\n        var events = {\n            resize: this._onLayerDidResize,\n            moveend: this._onLayerDidMove\n        };\n        if (this._map.options.zoomAnimation && L.Browser.any3d) {\n            events.zoomanim = this._animateZoom;\n        }\n\n        return events;\n    },\n    //-------------------------------------------------------------\n    onAdd: function (map) {\n        this._map = map;\n        this._canvas = L.DomUtil.create('canvas', 'leaflet-layer');\n        this.tiles = {};\n\n        var size = this._map.getSize();\n        this._canvas.width = size.x;\n        this._canvas.height = size.y;\n\n        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\n        L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\n\n\n        map._panes.overlayPane.appendChild(this._canvas);\n\n        map.on(this.getEvents(), this);\n\n        var del = this._delegate || this;\n        del.onLayerDidMount && del.onLayerDidMount(); // -- callback\n\n        this.needRedraw();\n    },\n\n    //-------------------------------------------------------------\n    onRemove: function (map) {\n        var del = this._delegate || this;\n        del.onLayerWillUnmount && del.onLayerWillUnmount(); // -- callback\n\n\n        map.getPanes().overlayPane.removeChild(this._canvas);\n\n        map.off(this.getEvents(), this);\n\n        this._canvas = null;\n\n    },\n\n    //------------------------------------------------------------\n    addTo: function (map) {\n        map.addLayer(this);\n        return this;\n    },\n    // --------------------------------------------------------------------------------\n    LatLonToMercator: function (latlon) {\n        return {\n            x: latlon.lng * 6378137 * Math.PI / 180,\n            y: Math.log(Math.tan((90 + latlon.lat) * Math.PI / 360)) * 6378137\n        };\n    },\n\n    //------------------------------------------------------------------------------\n    drawLayer: function () {\n        // -- todo make the viewInfo properties  flat objects.\n        var size = this._map.getSize();\n        var bounds = this._map.getBounds();\n        var zoom = this._map.getZoom();\n\n        var center = this.LatLonToMercator(this._map.getCenter());\n        var corner = this.LatLonToMercator(this._map.containerPointToLatLng(this._map.getSize()));\n\n        var del = this._delegate || this;\n        del.onDrawLayer && del.onDrawLayer({\n            layer: this,\n            canvas: this._canvas,\n            bounds: bounds,\n            size: size,\n            zoom: zoom,\n            center: center,\n            corner: corner\n        });\n        this._frame = null;\n    },\n\n    //------------------------------------------------------------------------------\n    _animateZoom: function (e) {\n        var scale = this._map.getZoomScale(e.zoom);\n        var offset = this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), e.zoom, e.center);\n\n        L.DomUtil.setTransform(this._canvas, offset, scale);\n    }\n});\n\nL.canvasLayer = function () {\n    return new L.CanvasLayer();\n};\n","/**\n *  Simple layer with lon-lat points\n *\n *  TODO rename to SimplePoint?\n */\nL.CanvasLayer.SimpleLonLat = L.CanvasLayer.extend({\n    options: {\n        color: 'gray',\n        size: 2\n    },\n\n    initialize: function(points, options) {\n        this.points = points;\n        L.Util.setOptions(this, options);\n    },\n\n    onLayerDidMount: function() {\n        // -- prepare custom drawing\n    },\n\n    onLayerWillUnmount: function() {\n        // -- custom cleanup\n    },\n\n    /* eslint-disable no-unused-vars */\n    setData: function(data) {\n        // -- custom data set\n        this.needRedraw(); // -- call to drawLayer\n    },\n    /* eslint-enable no-unused-vars */\n\n    onDrawLayer: function(viewInfo) {\n        // canvas preparation\n        let g = viewInfo.canvas.getContext('2d');\n        g.clearRect(0, 0, viewInfo.canvas.width, viewInfo.canvas.height);\n        g.fillStyle = this.options.color;\n\n        for (let point of this.points) {\n            let p = viewInfo.layer._map.latLngToContainerPoint(point);\n            g.beginPath();\n            //g.arc(p.x, p.y, 1, 0, Math.PI * 2); // circle | TODO style 'function' as parameter?\n            g.fillRect(p.x, p.y, this.options.size, this.options.size); //simple point\n            g.fill();\n            g.closePath();\n            g.stroke();\n        }\n    },\n\n    getBounds: function() {\n        // TODO: bounding with points...\n        let xs = this.points.map(pt => pt.lng);\n        let ys = this.points.map(pt => pt.lat);\n\n        let xmin = Math.min(...xs);\n        let ymin = Math.min(...ys);\n        let xmax = Math.max(...xs);\n        let ymax = Math.max(...ys);\n\n        let southWest = L.latLng(ymin, xmin),\n            northEast = L.latLng(ymax, xmax);\n        let bounds = L.latLngBounds(southWest, northEast); // TODO FIX ERROR ? half-pixel?\n        return bounds;\n    }\n});\n\nL.canvasLayer.simpleLonLat = function(lonslats, options) {\n    return new L.CanvasLayer.SimpleLonLat(lonslats, options);\n};\n","/**\n * Abstract class for a Field layer on canvas, aka 'a Raster layer'\n * (ScalarField or a VectorField)\n */\nL.CanvasLayer.Field = L.CanvasLayer.extend({\n    options: {\n        mouseMoveCursor: {\n            value: 'pointer',\n            noValue: 'default'\n        },\n        opacity: 1,\n        onClick: null,\n        onMouseMove: null,\n        inFilter: null\n    },\n\n    initialize: function(field, options) {\n        L.Util.setOptions(this, options);\n        this._visible = true;\n        if (field) {\n            this.setData(field);\n        }\n    },\n\n    getEvents: function() {\n        var events = L.CanvasLayer.prototype.getEvents.call(this);\n        events.zoomstart = this._hideCanvas.bind(this);\n        events.zoomend = this._showCanvas.bind(this);\n        return events;\n    },\n\n    onLayerDidMount: function() {\n        this._enableIdentify();\n        this._ensureCanvasAlignment();\n    },\n\n    show() {\n        this._visible = true;\n        this._showCanvas();\n        this._enableIdentify();\n    },\n\n    hide() {\n        this._visible = false;\n        this._hideCanvas();\n        this._disableIdentify();\n    },\n\n    isVisible() {\n        return this._visible;\n    },\n\n    _showCanvas() {\n        if (this._canvas && this._visible) {\n            this._canvas.style.visibility = 'visible';\n        }\n    },\n\n    _hideCanvas() {\n        if (this._canvas) {\n            this._canvas.style.visibility = 'hidden';\n        }\n    },\n\n    _enableIdentify() {\n        this._map.on('click', this._onClick, this);\n        this._map.on('mousemove', this._onMouseMove, this);\n\n        this.options.onClick && this.on('click', this.options.onClick, this);\n        this.options.onMouseMove &&\n            this.on('mousemove', this.options.onMouseMove, this);\n    },\n\n    _disableIdentify() {\n        this._map.off('click', this._onClick, this);\n        this._map.off('mousemove', this._onMouseMove, this);\n\n        this.options.onClick && this.off('click', this.options.onClick, this);\n        this.options.onMouseMove &&\n            this.off('mousemove', this.options.onMouseMove, this);\n    },\n\n    _ensureCanvasAlignment() {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n    },\n\n    onLayerWillUnmount: function() {\n        this._disableIdentify();\n    },\n\n    needRedraw() {\n        if (this._map && this._field) {\n            L.CanvasLayer.prototype.needRedraw.call(this);\n        }\n    },\n\n    /* eslint-disable no-unused-vars */\n    onDrawLayer: function(viewInfo) {\n        throw new TypeError('Must be overriden');\n    },\n    /* eslint-enable no-unused-vars */\n\n    setData: function(field) {\n        this.options.inFilter && field.setFilter(this.options.inFilter);\n        this._field = field;\n        this.needRedraw();\n        this.fire('load');\n    },\n\n    setFilter: function(f) {\n        this.options.inFilter = f;\n        this._field && this._field.setFilter(f);\n        this.needRedraw();\n    },\n\n    setOpacity: function(opacity) {\n        this.options.opacity = opacity;\n\n        if (this._canvas) {\n            this._updateOpacity();\n        }\n        return this;\n    },\n\n    getBounds: function() {\n        let bb = this._field.extent();\n\n        let southWest = L.latLng(bb[1], bb[0]),\n            northEast = L.latLng(bb[3], bb[2]);\n        let bounds = L.latLngBounds(southWest, northEast);\n        return bounds;\n    },\n\n    _onClick: function(e) {\n        let v = this._queryValue(e);\n        this.fire('click', v);\n    },\n\n    _onMouseMove: function(e) {\n        let v = this._queryValue(e);\n        this._changeCursorOn(v);\n        this.fire('mousemove', v);\n    },\n\n    _changeCursorOn: function(v) {\n        if (!this.options.mouseMoveCursor) return;\n\n        let { value, noValue } = this.options.mouseMoveCursor;\n        let style = this._map.getContainer().style;\n        style.cursor = v.value !== null ? value : noValue;\n    },\n\n    _updateOpacity: function() {\n        L.DomUtil.setOpacity(this._canvas, this.options.opacity);\n    },\n\n    _queryValue: function(e) {\n        let v = this._field\n            ? this._field.valueAt(e.latlng.lng, e.latlng.lat)\n            : null;\n        let result = {\n            latlng: e.latlng,\n            value: v\n        };\n        return result;\n    },\n\n    _getDrawingContext: function() {\n        let g = this._canvas.getContext('2d');\n        g.clearRect(0, 0, this._canvas.width, this._canvas.height);\n        return g;\n    }\n});\n","import Cell from '../Cell';\n\n/**\n * ScalarField on canvas (a 'Raster')\n */\nL.CanvasLayer.ScalarField = L.CanvasLayer.Field.extend({\n    options: {\n        type: 'colormap', // [colormap|vector]\n        color: null, // function colorFor(value) [e.g. chromajs.scale],\n        interpolate: false, // Change to use interpolation\n        vectorSize: 20, // only used if 'vector'\n        arrowDirection: 'from' // [from|towards]\n    },\n\n    initialize: function(scalarField, options) {\n        L.CanvasLayer.Field.prototype.initialize.call(\n            this,\n            scalarField,\n            options\n        );\n        L.Util.setOptions(this, options);\n    },\n\n    _defaultColorScale: function() {\n        return chroma.scale(['white', 'black']).domain(this._field.range);\n    },\n\n    setColor(f) {\n        this.options.color = f;\n        this.needRedraw();\n    },\n\n    /* eslint-disable no-unused-vars */\n    onDrawLayer: function(viewInfo) {\n        if (!this.isVisible()) return;\n        this._updateOpacity();\n\n        let r = this._getRendererMethod();\n        //console.time('onDrawLayer');\n        r();\n        //console.timeEnd('onDrawLayer');\n    },\n    /* eslint-enable no-unused-vars */\n\n    _getRendererMethod: function() {\n        switch (this.options.type) {\n            case 'colormap':\n                return this._drawImage.bind(this);\n            case 'vector':\n                return this._drawArrows.bind(this);\n            default:\n                throw Error(`Unkwown renderer type: ${this.options.type}`);\n        }\n    },\n\n    _ensureColor: function() {\n        if (this.options.color === null) {\n            this.setColor(this._defaultColorScale());\n        }\n    },\n\n    _showCanvas() {\n        L.CanvasLayer.Field.prototype._showCanvas.call(this);\n        this.needRedraw(); // TODO check spurious redraw (e.g. hide/show without moving map)\n    },\n\n    /**\n     * Draws the field in an ImageData and applying it with putImageData.\n     * Used as a reference: http://geoexamples.com/d3-raster-tools-docs/code_samples/raster-pixels-page.html\n     */\n    _drawImage: function() {\n        this._ensureColor();\n\n        let ctx = this._getDrawingContext();\n        let width = this._canvas.width;\n        let height = this._canvas.height;\n\n        let img = ctx.createImageData(width, height);\n        let data = img.data;\n\n        this._prepareImageIn(data, width, height);\n        ctx.putImageData(img, 0, 0);\n    },\n\n    /**\n     * Prepares the image in data, as array with RGBAs\n     * [R1, G1, B1, A1, R2, G2, B2, A2...]\n     * @private\n     * @param {[[Type]]} data   [[Description]]\n     * @param {Numver} width\n     * @param {Number} height\n     */\n    _prepareImageIn(data, width, height) {\n        let f = this.options.interpolate ? 'interpolatedValueAt' : 'valueAt';\n\n        let pos = 0;\n        for (let j = 0; j < height; j++) {\n            for (let i = 0; i < width; i++) {\n                let pointCoords = this._map.containerPointToLatLng([i, j]);\n                let lon = pointCoords.lng;\n                let lat = pointCoords.lat;\n\n                let v = this._field[f](lon, lat); // 'valueAt' | 'interpolatedValueAt' || TODO check some 'artifacts'\n                if (v !== null) {\n                    let color = this._getColorFor(v);\n                    let [R, G, B, A] = color.rgba();\n                    data[pos] = R;\n                    data[pos + 1] = G;\n                    data[pos + 2] = B;\n                    data[pos + 3] = parseInt(A * 255); // not percent in alpha but hex 0-255\n                }\n                pos = pos + 4;\n            }\n        }\n    },\n\n    /**\n     * Draws the field as a set of arrows. Direction from 0 to 360 is assumed.\n     */\n    _drawArrows: function() {\n        const bounds = this._pixelBounds();\n        const pixelSize = (bounds.max.x - bounds.min.x) / this._field.nCols;\n\n        var stride = Math.max(\n            1,\n            Math.floor(1.2 * this.options.vectorSize / pixelSize)\n        );\n\n        const ctx = this._getDrawingContext();\n        ctx.strokeStyle = this.options.color;\n\n        var currentBounds = this._map.getBounds();\n\n        for (var y = 0; y < this._field.height; y = y + stride) {\n            for (var x = 0; x < this._field.width; x = x + stride) {\n                let [lon, lat] = this._field._lonLatAtIndexes(x, y);\n                let v = this._field.valueAt(lon, lat);\n                let center = L.latLng(lat, lon);\n                if (v !== null && currentBounds.contains(center)) {\n                    let cell = new Cell(\n                        center,\n                        v,\n                        this.cellXSize,\n                        this.cellYSize\n                    );\n                    this._drawArrow(cell, ctx);\n                }\n            }\n        }\n    },\n\n    _pixelBounds: function() {\n        const bounds = this.getBounds();\n        const northWest = this._map.latLngToContainerPoint(\n            bounds.getNorthWest()\n        );\n        const southEast = this._map.latLngToContainerPoint(\n            bounds.getSouthEast()\n        );\n        var pixelBounds = L.bounds(northWest, southEast);\n        return pixelBounds;\n    },\n\n    _drawArrow: function(cell, ctx) {\n        var projected = this._map.latLngToContainerPoint(cell.center);\n\n        // colormap vs. simple color\n        let color = this.options.color;\n        if (typeof color === 'function') {\n            ctx.strokeStyle = color(cell.value);\n        }\n\n        const size = this.options.vectorSize;\n        ctx.save();\n\n        ctx.translate(projected.x, projected.y);\n\n        let rotationRads = (90 + cell.value) * Math.PI / 180; // from, by default\n        if (this.options.arrowDirection === 'towards') {\n            rotationRads = rotationRads + Math.PI;\n        }\n        ctx.rotate(rotationRads);\n\n        ctx.beginPath();\n        ctx.moveTo(-size / 2, 0);\n        ctx.lineTo(+size / 2, 0);\n        ctx.moveTo(size * 0.25, -size * 0.25);\n        ctx.lineTo(+size / 2, 0);\n        ctx.lineTo(size * 0.25, size * 0.25);\n        ctx.stroke();\n        ctx.restore();\n    },\n\n    /**\n     * Gets a chroma color for a pixel value, according to 'options.color'\n     */\n    _getColorFor(v) {\n        let c = this.options.color; // e.g. for a constant 'red'\n        if (typeof c === 'function') {\n            c = this.options.color(v);\n        }\n        let color = chroma(c); // to be more flexible, a chroma color object is always created || TODO improve efficiency\n        return color;\n    }\n});\n\nL.canvasLayer.scalarField = function(scalarField, options) {\n    return new L.CanvasLayer.ScalarField(scalarField, options);\n};\n","/**\n * Animated VectorField on canvas\n */\nL.CanvasLayer.VectorFieldAnim = L.CanvasLayer.Field.extend({\n    options: {\n        paths: 800,\n        color: 'white', // html-color | function colorFor(value) [e.g. chromajs.scale]\n        width: 1.0, // number | function widthFor(value)\n        fade: 0.96, // 0 to 1\n        duration: 20, // milliseconds per 'frame'\n        maxAge: 200, // number of maximum frames per path\n        velocityScale: 1 / 5000\n    },\n\n    initialize: function(vectorField, options) {\n        L.CanvasLayer.Field.prototype.initialize.call(\n            this,\n            vectorField,\n            options\n        );\n        L.Util.setOptions(this, options);\n\n        this.timer = null;\n    },\n\n    onLayerDidMount: function() {\n        L.CanvasLayer.Field.prototype.onLayerDidMount.call(this);\n        this._map.on('move resize', this._stopAnimation, this);\n    },\n\n    onLayerWillUnmount: function() {\n        L.CanvasLayer.Field.prototype.onLayerWillUnmount.call(this);\n        this._map.off('move resize', this._stopAnimation, this);\n        this._stopAnimation();\n    },\n\n    _hideCanvas: function _showCanvas() {\n        L.CanvasLayer.Field.prototype._hideCanvas.call(this);\n        this._stopAnimation();\n    },\n\n    onDrawLayer: function(viewInfo) {\n        if (!this._field || !this.isVisible()) return;\n\n        this._updateOpacity();\n\n        let ctx = this._getDrawingContext();\n        let paths = this._prepareParticlePaths();\n\n        this.timer = d3.timer(function() {\n            _moveParticles();\n            _drawParticles();\n        }, this.options.duration);\n\n        let self = this;\n\n        /**\n         * Builds the paths, adding 'particles' on each animation step, considering\n         * their properties (age / position source > target)\n         */\n        function _moveParticles() {\n            // let screenFactor = 1 / self._map.getZoom(); // consider using a 'screenFactor' to ponderate velocityScale\n            paths.forEach(function(par) {\n                if (par.age > self.options.maxAge) {\n                    // restart, on a random x,y\n                    par.age = 0;\n                    self._field.randomPosition(par);\n                }\n\n                let vector = self._field.valueAt(par.x, par.y);\n                if (vector === null) {\n                    par.age = self.options.maxAge;\n                } else {\n                    // the next point will be...\n                    let xt = par.x + vector.u * self.options.velocityScale; //* screenFactor;\n                    let yt = par.y + vector.v * self.options.velocityScale; //* screenFactor;\n\n                    if (self._field.hasValueAt(xt, yt)) {\n                        par.xt = xt;\n                        par.yt = yt;\n                        par.m = vector.magnitude();\n                    } else {\n                        // not visible anymore...\n                        par.age = self.options.maxAge;\n                    }\n                }\n                par.age += 1;\n            });\n        }\n\n        /**\n         * Draws the paths on each step\n         */\n        function _drawParticles() {\n            // Previous paths...\n            let prev = ctx.globalCompositeOperation;\n            ctx.globalCompositeOperation = 'destination-in';\n            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n            //ctx.globalCompositeOperation = 'source-over';\n            ctx.globalCompositeOperation = prev;\n\n            // fading paths...\n            ctx.fillStyle = `rgba(0, 0, 0, ${self.options.fade})`;\n            ctx.lineWidth = self.options.width;\n            ctx.strokeStyle = self.options.color;\n\n            // New paths\n            paths.forEach(function(par) {\n                self._drawParticle(viewInfo, ctx, par);\n            });\n        }\n    },\n\n    _drawParticle(viewInfo, ctx, par) {\n        let source = new L.latLng(par.y, par.x);\n        let target = new L.latLng(par.yt, par.xt);\n\n        if (\n            viewInfo.bounds.contains(source) &&\n            par.age <= this.options.maxAge\n        ) {\n            let pA = viewInfo.layer._map.latLngToContainerPoint(source);\n            let pB = viewInfo.layer._map.latLngToContainerPoint(target);\n\n            ctx.beginPath();\n            ctx.moveTo(pA.x, pA.y);\n            ctx.lineTo(pB.x, pB.y);\n\n            // next-step movement\n            par.x = par.xt;\n            par.y = par.yt;\n\n            // colormap vs. simple color\n            let color = this.options.color;\n            if (typeof color === 'function') {\n                ctx.strokeStyle = color(par.m);\n            }\n\n            let width = this.options.width;\n            if (typeof width === 'function') {\n                ctx.lineWidth = width(par.m);\n            }\n\n            ctx.stroke();\n        }\n    },\n\n    _prepareParticlePaths: function() {\n        let paths = [];\n\n        for (var i = 0; i < this.options.paths; i++) {\n            let p = this._field.randomPosition();\n            p.age = this._randomAge();\n            paths.push(p);\n        }\n        return paths;\n    },\n\n    _randomAge: function() {\n        return Math.floor(Math.random() * this.options.maxAge);\n    },\n\n    _stopAnimation: function() {\n        if (this.timer) {\n            this.timer.stop();\n        }\n    }\n});\n\nL.canvasLayer.vectorFieldAnim = function(vectorField, options) {\n    return new L.CanvasLayer.VectorFieldAnim(vectorField, options);\n};\n","/**\n *   Control for a simple legend with a colorbar\n *   References:\n *      - http://jsfiddle.net/ramnathv/g8stqcf6/\n *      - http://jsfiddle.net/vis4/cYLZH/\n */\nL.Control.ColorBar = L.Control.extend({\n    options: {\n        position: 'bottomleft',\n        width: 300, // for colorbar itself (control is wider)\n        height: 15,\n        margin: 15,\n        background: '#fff',\n        textColor: 'black',\n        steps: 100,\n        decimals: 2,\n        units: 'uds', // ej: m/s\n        title: 'Legend', // ej: Ocean Currents\n        labels: [], // empty for no labels\n        textLabels: [], // empty for default labels. Custom labels ej: ['low', 'mid','high'] \n        labelFontSize: 10,\n        labelTextPosition: 'middle' // start | middle | end\n    },\n\n    initialize: function (color, range, options) {\n        this.color = color; // 'chromajs' scale function\n        this.range = range; // [min, max]\n        L.Util.setOptions(this, options);\n    },\n\n    onAdd: function (map) {\n        this._map = map;\n        let div = L.DomUtil.create(\n            'div',\n            'leaflet-control-colorBar leaflet-bar leaflet-control'\n        );\n        div.style.padding = '10px';\n\n        L.DomEvent\n            .addListener(div, 'click', L.DomEvent.stopPropagation)\n            .addListener(div, 'click', L.DomEvent.preventDefault);\n        div.style.backgroundColor = this.options.background;\n        div.style.cursor = 'text';\n        div.innerHTML = this.title() + this.palette();\n        return div;\n    },\n\n    title: function () {\n        let d = document.createElement('div');\n        d3\n            .select(d)\n            .append('span')\n            .style('color', this.options.textColor)\n            .style('display', 'block')\n            .style('margin-bottom', '5px')\n            .attr('class', 'leaflet-control-colorBar-title')\n            .text(this.options.title);\n        return d.innerHTML;\n    },\n\n    palette: function () {\n        let d = document.createElement('div');\n        let svg = this._createSvgIn(d);\n\n        this._appendColorBarTo(svg);\n\n        if (this.options.labels) {\n            this._appendLabelsTo(svg);\n        }\n\n        return d.innerHTML;\n    },\n\n    _createSvgIn: function (d) {\n        let spaceForLabels = this.options.labels ? this.options.margin : 0;\n        let svg = d3\n            .select(d)\n            .append('svg')\n            .attr('width', this.options.width + this.options.margin * 2)\n            .attr('height', this.options.height + spaceForLabels);\n        return svg;\n    },\n\n    _appendColorBarTo: function (svg) {\n        const colorPerValue = this._getColorPerValue();\n        const w = this.options.width / colorPerValue.length;\n\n        let groupBars = svg.append('g').attr('id', 'colorBar-buckets');\n        let buckets = groupBars\n            .selectAll('rect')\n            .data(colorPerValue)\n            .enter()\n            .append('rect');\n        buckets\n            .attr('x', (d, i) => i * w + this.options.margin)\n            .attr('y', () => 0)\n            .attr('height', () => this.options.height /*w * 4*/ )\n            .attr('width', () => w)\n            .attr('stroke-width', 2)\n            .attr('stroke-linecap', 'butt')\n            .attr('stroke', d => d.color.hex())\n            .attr('fill', d => d.color.hex());\n        buckets\n            .append('title')\n            .text(\n                d =>\n                    `${d.value.toFixed(this.options.decimals)} ${this.options\n                        .units}`\n            );\n    },\n\n    _appendLabelsTo: function (svg) {\n        const positionPerLabelValue = this._getPositionPerLabelValue();\n        //const w = this.options.width / colorPerValue.length;\n        let groupLabels = svg.append('g').attr('id', 'colorBar-labels');\n        let labels = groupLabels\n            .selectAll('text')\n            .data(positionPerLabelValue)\n            .enter()\n            .append('text');\n        labels\n            .attr('x', d => d.position + this.options.margin)\n            .attr('y', this.options.height + this.options.margin)\n            .attr('font-size', `${this.options.labelFontSize}px`)\n            .attr('text-anchor', this.options.labelTextPosition)\n            .attr('fill', this.options.textColor)\n            .attr('class', 'leaflet-control-colorBar-label')\n            .text(d => this.options.textLabels ? d.label : `${d.value.toFixed(this.options.decimals)}`);\n    },\n\n    _getColorPerValue: function () {\n        const [min, max] = this.range;\n        let delta = (max - min) / this.options.steps;\n        let data = d3.range(min, max + delta, delta);\n        let colorPerValue = data.map(d => {\n            return {\n                value: d,\n                color: this.color(d)\n            };\n        });\n        return colorPerValue;\n    },\n\n    _getPositionPerLabelValue: function () {\n        var xPositionFor = d3\n            .scaleLinear()\n            .range([0, this.options.width])\n            .domain(this.range);\n        let data = this.options.labels;\n        let positionPerLabel = data.map((d, index) => {\n            return {\n                label: this.options.textLabels ? this.options.textLabels[index] : '',\n                value: d,\n                position: xPositionFor(d)\n            };\n        });\n        return positionPerLabel;\n    }\n});\n\nL.control.colorBar = function (color, range, options) {\n    return new L.Control.ColorBar(color, range, options);\n};","/**\n *  2D Vector\n */\nexport default class Vector {\n\n    constructor(u, v) {\n        this.u = u;\n        this.v = v;\n    }\n\n    /**\n     * Magnitude\n     * @returns {Number}\n     */\n    magnitude() {\n        return Math.sqrt(this.u * this.u + this.v * this.v);\n    }\n\n    /**\n     * Angle in degrees (0 to 360) --> Towards\n     * N is 0 and E is 90\n     * @returns {Number}\n     */\n    directionTo() {\n        let verticalAngle = Math.atan2(this.u, this.v);\n        let inDegrees = verticalAngle * (180.0 / Math.PI);\n        if (inDegrees < 0) {\n            inDegrees = inDegrees + 360.0;\n        }\n        return inDegrees;\n    }\n\n    /**\n     * Angle in degrees (0 to 360) From x-->\n     * N is 0 and E is 90\n     * @returns {Number}\n     */\n    directionFrom() {\n        let a = this.directionTo();\n        let opposite = (a + 180.0) % 360.0;\n        return opposite;\n    }\n\n    /*\n        Degrees --> text\n        new Dictionary<int, string>\n        {\n            //{0, 23, 45, 68, 90, 113, 135, 158, 180, 203, 225, 248, 270, 293, 315, 338, 360};\n            {0, 'N'},\n            {23, 'NNE'},\n            {45, 'NE'},\n            {68, 'ENE'},\n            {90, 'E'},\n            {113, 'ESE'},\n            {135, 'SE'},\n            {158, 'SSE'},\n            {180, 'S'},\n            {203, 'SSW'},\n            {225, 'SW'},\n            {248, 'WSW'},\n            {270, 'W'},\n            {293, 'WNW'},\n            {315, 'NW'},\n            {338, 'NNW'},\n            {360, 'N'}\n        };\n    */\n}\n","import Cell from './Cell';\nimport inside from '@turf/inside';\n\n/**\n *  Abstract class for a set of values (Vector | Scalar)\n *  assigned to a regular 2D-grid (lon-lat), aka 'a Raster source'\n */\nexport default class Field {\n    constructor(params) {\n        this.params = params;\n\n        this.nCols = params['nCols'];\n        this.nRows = params['nRows'];\n\n        // alias\n        this.width = params['nCols'];\n        this.height = params['nRows'];\n\n        // ll = lower-left\n        this.xllCorner = params['xllCorner'];\n        this.yllCorner = params['yllCorner'];\n\n        // ur = upper-right\n        this.xurCorner =\n            params['xllCorner'] + params['nCols'] * params['cellXSize'];\n        this.yurCorner =\n            params['yllCorner'] + params['nRows'] * params['cellYSize'];\n\n        this.cellXSize = params['cellXSize'];\n        this.cellYSize = params['cellYSize'];\n\n        this.grid = null; // to be defined by subclasses\n        this.isContinuous = this.xurCorner - this.xllCorner >= 360;\n        this.longitudeNeedsToBeWrapped = this.xurCorner > 180; // [0, 360] --> [-180, 180]\n\n        this._inFilter = null;\n        this._spatialMask = null;\n    }\n\n    /**\n     * Builds a grid with a value at each point (either Vector or Number)\n     * Original params must include the required input values, following\n     * x-ascending & y-descending order (same as in ASCIIGrid)\n     * @abstract\n     * @private\n     * @returns {Array.<Array.<Vector|Number>>} - grid[row][column]--> Vector|Number\n     */\n    _buildGrid() {\n        throw new TypeError('Must be overriden');\n    }\n\n    _updateRange() {\n        this.range = this._calculateRange();\n    }\n\n    /**\n     * Number of cells in the grid (rows * cols)\n     * @returns {Number}\n     */\n    numCells() {\n        return this.nRows * this.nCols;\n    }\n\n    /**\n     * A list with every cell\n     * @returns {Array<Cell>} - cells (x-ascending & y-descending order)\n     */\n    getCells(stride = 1) {\n        let cells = [];\n        for (let j = 0; j < this.nRows; j = j + stride) {\n            for (let i = 0; i < this.nCols; i = i + stride) {\n                let [lon, lat] = this._lonLatAtIndexes(i, j);\n                let center = L.latLng(lat, lon);\n                let value = this._valueAtIndexes(i, j);\n                let c = new Cell(center, value, this.cellXSize, this.cellYSize);\n                cells.push(c); // <<\n            }\n        }\n        return cells;\n    }\n\n    /**\n     * Apply a filter function to field values\n     * @param   {Function} f - boolean function\n     */\n    setFilter(f) {\n        this._inFilter = f;\n        this._updateRange();\n    }\n\n    /**\n     * Apply a spatial mask to field values\n     * @param {L.GeoJSON} m \n     */\n    setSpatialMask(m) {\n        this._spatialMask = m;\n    }\n\n    /**\n     * Grid extent\n     * @returns {Number[]} [xmin, ymin, xmax, ymax]\n     */\n    extent() {\n        let [xmin, xmax] = this._getWrappedLongitudes();\n        return [xmin, this.yllCorner, xmax, this.yurCorner];\n    }\n\n    /**\n     * [xmin, xmax] in [-180, 180] range\n     */\n    _getWrappedLongitudes() {\n        let xmin = this.xllCorner;\n        let xmax = this.xurCorner;\n\n        if (this.longitudeNeedsToBeWrapped) {\n            if (this.isContinuous) {\n                xmin = -180;\n                xmax = 180;\n            } else {\n                // not sure about this (just one particular case, but others...?)\n                xmax = this.xurCorner - 360;\n                xmin = this.xllCorner - 360;\n                /* eslint-disable no-console */\n                // console.warn(`are these xmin: ${xmin} & xmax: ${xmax} OK?`);\n                // TODO: Better throw an exception on no-controlled situations.\n                /* eslint-enable no-console */\n            }\n        }\n        return [xmin, xmax];\n    }\n\n    /**\n     * Returns whether or not the grid contains the point, considering\n     * the spatialMask if it has been previously set\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    contains(lon, lat) {\n        if (this._spatialMask) {\n            return this._pointInMask(lon, lat);\n        }\n        return this._pointInExtent(lon, lat);\n    }\n\n    /**\n     * Checks if coordinates are inside the Extent (considering wrapped longitudes if needed)\n     * @param {Number} lon \n     * @param {Number} lat \n     */\n    _pointInExtent(lon, lat) {\n        let [xmin, xmax] = this._getWrappedLongitudes();\n        let longitudeIn = lon >= xmin && lon <= xmax;\n        let latitudeIn = lat >= this.yllCorner && lat <= this.yurCorner;\n        return longitudeIn && latitudeIn;\n    }\n\n    /**\n     * Check if coordinates are inside the spatialMask (Point in Polygon analysis)\n     * @param {Number} lon \n     * @param {Number} lat \n     */\n    _pointInMask(lon, lat) {\n        const pt = {\n            type: 'Feature',\n            geometry: {\n                type: 'Point',\n                coordinates: [lon, lat] // geojson, lon-lat order !\n            },\n            properties: {}\n        };\n        const poly = this._spatialMask;\n        return inside(pt, poly);\n    }\n\n    /**\n     * Returns if the grid doesn't contain the point\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    notContains(lon, lat) {\n        return !this.contains(lon, lat);\n    }\n\n    /**\n     * Interpolated value at lon-lat coordinates (bilinear method)\n     * @param   {Number} longitude\n     * @param   {Number} latitude\n     * @returns {Vector|Number} [u, v, magnitude]\n     *                          \n     * Source: https://github.com/cambecc/earth > product.js\n     */\n    interpolatedValueAt(lon, lat) {\n        if (this.notContains(lon, lat)) return null;\n\n        let [i, j] = this._getDecimalIndexes(lon, lat);\n        return this.interpolatedValueAtIndexes(i, j);\n    }\n\n    /**\n     * Interpolated value at i-j indexes (bilinear method)\n     * @param   {Number} i\n     * @param   {Number} j\n     * @returns {Vector|Number} [u, v, magnitude]\n     *\n     * Source: https://github.com/cambecc/earth > product.js\n     */\n    interpolatedValueAtIndexes(i, j) {\n        //         1      2           After converting  and  to fractional grid indexes i and j, we find the\n        //        fi  i   ci          four points 'G' that enclose point (i, j). These points are at the four\n        //         | =1.4 |           corners specified by the floor and ceiling of i and j. For example, given\n        //      ---G--|---G--- fj 8   i = 1.4 and j = 8.3, the four surrounding grid points are (1, 8), (2, 8),\n        //    j ___|_ .   |           (1, 9) and (2, 9).\n        //  =8.3   |      |\n        //      ---G------G--- cj 9   Note that for wrapped grids, the first column is duplicated as the last\n        //         |      |           column, so the index ci can be used without taking a modulo.\n\n        let indexes = this._getFourSurroundingIndexes(i, j);\n        let [fi, ci, fj, cj] = indexes;\n        let values = this._getFourSurroundingValues(fi, ci, fj, cj);\n        if (values) {\n            let [g00, g10, g01, g11] = values;\n            return this._doInterpolation(i - fi, j - fj, g00, g10, g01, g11);\n        }\n        return null;\n    }\n\n    /**\n     * Get decimal indexes\n     * @private\n     * @param {Number} lon\n     * @param {Number} lat\n     * @returns {Array}    [[Description]]\n     */\n    _getDecimalIndexes(lon, lat) {\n        if (this.longitudeNeedsToBeWrapped && lon < this.xllCorner) {\n            lon = lon + 360;\n        }\n        let i = (lon - this.xllCorner) / this.cellXSize;\n        let j = (this.yurCorner - lat) / this.cellYSize;\n        return [i, j];\n    }\n\n    /**\n     * Get surrounding indexes (integer), clampling on borders\n     * @private\n     * @param   {Number} i - decimal index\n     * @param   {Number} j - decimal index\n     * @returns {Array} [fi, ci, fj, cj]\n     */\n    _getFourSurroundingIndexes(i, j) {\n        let fi = Math.floor(i);\n        let ci = fi + 1;\n        // duplicate colum to simplify interpolation logic (wrapped value)\n        if (this.isContinuous && ci >= this.nCols) {\n            ci = 0;\n        }\n        ci = this._clampColumnIndex(ci);\n\n        let fj = this._clampRowIndex(Math.floor(j));\n        let cj = this._clampRowIndex(fj + 1);\n\n        return [fi, ci, fj, cj];\n    }\n\n    /**\n     * Get four surrounding values or null if not available,\n     * from 4 integer indexes\n     * @private\n     * @param   {Number} fi\n     * @param   {Number} ci\n     * @param   {Number} fj\n     * @param   {Number} cj\n     * @returns {Array} \n     */\n    _getFourSurroundingValues(fi, ci, fj, cj) {\n        var row;\n        if ((row = this.grid[fj])) {\n            // upper row ^^\n            var g00 = row[fi]; // << left\n            var g10 = row[ci]; // right >>\n            if (\n                this._isValid(g00) &&\n                this._isValid(g10) &&\n                (row = this.grid[cj])\n            ) {\n                // lower row vv\n                var g01 = row[fi]; // << left\n                var g11 = row[ci]; // right >>\n                if (this._isValid(g01) && this._isValid(g11)) {\n                    return [g00, g10, g01, g11]; // 4 values found!\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Nearest value at lon-lat coordinates\n     * @param   {Number} longitude\n     * @param   {Number} latitude\n     * @returns {Vector|Number}\n     */\n    valueAt(lon, lat) {\n        if (this.notContains(lon, lat)) return null;\n\n        let [i, j] = this._getDecimalIndexes(lon, lat);\n        let ii = Math.floor(i);\n        let jj = Math.floor(j);\n\n        const ci = this._clampColumnIndex(ii);\n        const cj = this._clampRowIndex(jj);\n\n        let value = this._valueAtIndexes(ci, cj);\n        if (this._inFilter) {\n            if (!this._inFilter(value)) return null;\n        }\n\n        return value;\n    }\n\n    /**\n     * Returns whether or not the field has a value at the point\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    hasValueAt(lon, lat) {\n        let value = this.valueAt(lon, lat);\n        let hasValue = value !== null;\n\n        let included = true;\n        if (this._inFilter) {\n            included = this._inFilter(value);\n        }\n        return hasValue && included;\n    }\n\n    /**\n     * Returns if the grid has no value at the point\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    notHasValueAt(lon, lat) {\n        return !this.hasValueAt(lon, lat);\n    }\n\n    /**\n     * Gives a random position to 'o' inside the grid\n     * @param {Object} [o] - an object (eg. a particle)\n     * @returns {{x: Number, y: Number}} - object with x, y (lon, lat)\n     */\n    randomPosition(o = {}) {\n        let i = (Math.random() * this.nCols) | 0;\n        let j = (Math.random() * this.nRows) | 0;\n\n        o.x = this._longitudeAtX(i);\n        o.y = this._latitudeAtY(j);\n\n        return o;\n    }\n\n    /**\n     * Value for grid indexes\n     * @param   {Number} i - column index (integer)\n     * @param   {Number} j - row index (integer)\n     * @returns {Vector|Number}\n     */\n    _valueAtIndexes(i, j) {\n        return this.grid[j][i]; // <-- j,i !!\n    }\n\n    /**\n     * Lon-Lat for grid indexes\n     * @param   {Number} i - column index (integer)\n     * @param   {Number} j - row index (integer)\n     * @returns {Number[]} [lon, lat]\n     */\n    _lonLatAtIndexes(i, j) {\n        let lon = this._longitudeAtX(i);\n        let lat = this._latitudeAtY(j);\n\n        return [lon, lat];\n    }\n\n    /**\n     * Longitude for grid-index\n     * @param   {Number} i - column index (integer)\n     * @returns {Number} longitude at the center of the cell\n     */\n    _longitudeAtX(i) {\n        let halfXPixel = this.cellXSize / 2.0;\n        let lon = this.xllCorner + halfXPixel + i * this.cellXSize;\n        if (this.longitudeNeedsToBeWrapped) {\n            lon = lon > 180 ? lon - 360 : lon;\n        }\n        return lon;\n    }\n\n    /**\n     * Latitude for grid-index\n     * @param   {Number} j - row index (integer)\n     * @returns {Number} latitude at the center of the cell\n     */\n    _latitudeAtY(j) {\n        let halfYPixel = this.cellYSize / 2.0;\n        return this.yurCorner - halfYPixel - j * this.cellYSize;\n    }\n\n    /**\n     * Apply the interpolation\n     * @abstract\n     * @private\n     */\n    /* eslint-disable no-unused-vars */\n    _doInterpolation(x, y, g00, g10, g01, g11) {\n        throw new TypeError('Must be overriden');\n    }\n    /* eslint-disable no-unused-vars */\n\n    /**\n     * Check the column index is inside the field,\n     * adjusting to min or max when needed\n     * @private\n     * @param   {Number} ii - index\n     * @returns {Number} i - inside the allowed indexes\n     */\n    _clampColumnIndex(ii) {\n        let i = ii;\n        if (ii < 0) {\n            i = 0;\n        }\n        let maxCol = this.nCols - 1;\n        if (ii > maxCol) {\n            i = maxCol;\n        }\n        return i;\n    }\n\n    /**\n     * Check the row index is inside the field,\n     * adjusting to min or max when needed\n     * @private\n     * @param   {Number} jj index\n     * @returns {Number} j - inside the allowed indexes\n     */\n    _clampRowIndex(jj) {\n        let j = jj;\n        if (jj < 0) {\n            j = 0;\n        }\n        let maxRow = this.nRows - 1;\n        if (jj > maxRow) {\n            j = maxRow;\n        }\n        return j;\n    }\n\n    /**\n     * Is valid (not 'null' nor 'undefined')\n     * @private\n     * @param   {Object} x object\n     * @returns {Boolean}\n     */\n    _isValid(x) {\n        return x !== null && x !== undefined;\n    }\n}\n","import Field from './Field';\n\n/**\n * Scalar Field\n */\nexport default class ScalarField extends Field {\n    /**\n   * Creates a ScalarField from the content of an ASCIIGrid file\n   * @param   {String}   asc\n   * @returns {ScalarField}\n   */\n    static fromASCIIGrid(asc, scaleFactor = 1) {\n    //console.time('ScalarField from ASC');\n\n        let lines = asc.split('\\n');\n\n        // Header\n        var header = ScalarField._parseASCIIGridHeader(lines.slice(0, 6));\n\n        // Data (left-right and top-down)\n        let zs = [];\n        for (let i = 6; i < lines.length; i++) {\n            let line = lines[i].trim();\n            if (line === '') break;\n\n            let items = line.split(' ');\n            items.forEach((it) => {\n                let floatItem = parseFloat(it);\n                let v =\n          floatItem !== header.noDataValue ? floatItem * scaleFactor : null;\n                zs.push(v);\n            });\n        }\n        let p = header;\n        p.zs = zs;\n\n        //console.timeEnd('ScalarField from ASC');\n        return new ScalarField(p);\n    }\n\n    /**\n   * Parse an ASCII Grid header, made with 6 lines\n   * It allows the use of XLLCORNER/YLLCORNER or XLLCENTER/YLLCENTER conventions\n   * @param {Array.String} headerLines\n   */\n    static _parseASCIIGridHeader(headerLines) {\n        try {\n            const headerItems = headerLines.map((line) => {\n                var items = line.split(' ').filter((i) => i != '');\n                var param = items[0].trim().toUpperCase();\n                var value = parseFloat(items[1].trim());\n                return {\n                    [param]: value,\n                };\n            });\n\n            const usesCorner = 'XLLCORNER' in headerItems[2];\n            const cellSize = headerItems[4]['CELLSIZE'];\n\n            const header = {\n                nCols: parseInt(headerItems[0]['NCOLS']),\n                nRows: parseInt(headerItems[1]['NROWS']),\n                xllCorner: usesCorner\n                    ? headerItems[2]['XLLCORNER']\n                    : headerItems[2]['XLLCENTER'] - cellSize / 2,\n                yllCorner: usesCorner\n                    ? headerItems[3]['YLLCORNER']\n                    : headerItems[3]['YLLCENTER'] - cellSize / 2,\n                cellXSize: cellSize,\n                cellYSize: cellSize,\n                noDataValue: headerItems[5]['NODATA_VALUE'],\n            };\n            return header;\n        } catch (err) {\n            throw new Error(`Not a valid ASCIIGrid Header: ${err}`);\n        }\n    }\n\n    /**\n   * Creates a ScalarField from the content of a GeoTIFF file\n   * @param   {ArrayBuffer}   data\n   * @param   {Number}   bandIndex\n   * @returns {ScalarField}\n   */\n    static fromGeoTIFF(data, bandIndex = 0) {\n        return ScalarField.multipleFromGeoTIFF(data, [bandIndex])[0];\n    }\n\n    /**\n   * Creates a ScalarField array (one per band) from the content of a GeoTIFF file\n   * @param   {ArrayBuffer}   data\n   * @param   {Array}   bandIndexes - if not provided all bands are returned\n   * @returns {Array.<ScalarField>}\n   */\n    static multipleFromGeoTIFF(data, bandIndexes) {\n    //console.time('ScalarField from GeoTIFF');\n\n        let tiff = GeoTIFF.parse(data); // geotiff.js\n        let image = tiff.getImage();\n        let rasters = image.readRasters();\n        let tiepoint = image.getTiePoints()[0];\n        let fileDirectory = image.getFileDirectory();\n        let [xScale, yScale] = fileDirectory.ModelPixelScale;\n\n        if (typeof bandIndexes === 'undefined' || bandIndexes.length === 0) {\n            bandIndexes = [...Array(rasters.length).keys()];\n        }\n\n        let scalarFields = [];\n        scalarFields = bandIndexes.map(function (bandIndex) {\n            let zs = rasters[bandIndex]; // left-right and top-down order\n\n            if (fileDirectory.GDAL_NODATA) {\n                let noData = parseFloat(fileDirectory.GDAL_NODATA);\n                // console.log(noData);\n                let simpleZS = Array.from(zs); // to simple array, so null is allowed | TODO efficiency??\n                zs = simpleZS.map(function (z) {\n                    return z === noData ? null : z;\n                });\n            }\n\n            let p = {\n                nCols: image.getWidth(),\n                nRows: image.getHeight(),\n                xllCorner: tiepoint.x,\n                yllCorner: tiepoint.y - image.getHeight() * yScale,\n                cellXSize: xScale,\n                cellYSize: yScale,\n                zs: zs,\n            };\n            return new ScalarField(p);\n        });\n\n        //console.timeEnd('ScalarField from GeoTIFF');\n        return scalarFields;\n    }\n\n    constructor(params) {\n        super(params);\n        this.zs = params['zs'];\n\n        this.grid = this._buildGrid();\n        this._updateRange();\n    //console.log(`ScalarField created (${this.nCols} x ${this.nRows})`);\n    }\n\n    /**\n   * Builds a grid with a Number at each point, from an array\n   * 'zs' following x-ascending & y-descending order\n   * (same as in ASCIIGrid)\n   * @private\n   * @returns {Array.<Array.<Number>>} - grid[row][column]--> Number\n   */\n    _buildGrid() {\n        let grid = this._arrayTo2d(this.zs, this.nRows, this.nCols);\n        return grid;\n    }\n\n    _arrayTo2d(array, nRows, nCols) {\n        let grid = [];\n        let p = 0;\n        for (var j = 0; j < nRows; j++) {\n            var row = [];\n            for (var i = 0; i < nCols; i++, p++) {\n                let z = array[p];\n                row[i] = this._isValid(z) ? z : null; // <<<\n            }\n            grid[j] = row;\n        }\n        return grid;\n    }\n\n    _newDataArrays(params) {\n        params['zs'] = [];\n    }\n\n    _pushValueToArrays(params, value) {\n        params['zs'].push(value);\n    }\n\n    _makeNewFrom(params) {\n        return new ScalarField(params);\n    }\n\n    /**\n   * Calculate min & max values\n   * @private\n   * @returns {Array} - [min, max]\n   */\n    _calculateRange() {\n        var data = this.zs;\n        if (this._inFilter) {\n            data = data.filter(this._inFilter);\n        }\n        return [d3.min(data), d3.max(data)];\n    }\n\n    /**\n   * Bilinear interpolation for Number\n   * https://en.wikipedia.org/wiki/Bilinear_interpolation\n   * @param   {Number} x\n   * @param   {Number} y\n   * @param   {Number} g00\n   * @param   {Number} g10\n   * @param   {Number} g01\n   * @param   {Number} g11\n   * @returns {Number}\n   */\n    _doInterpolation(x, y, g00, g10, g01, g11) {\n        var rx = 1 - x;\n        var ry = 1 - y;\n        return g00 * rx * ry + g10 * x * ry + g01 * rx * y + g11 * x * y;\n    }\n}\n","import Vector from './Vector';\nimport Field from './Field';\nimport ScalarField from './ScalarField';\n\n/**\n *  A set of vectors assigned to a regular 2D-grid (lon-lat)\n *  (e.g. a raster representing winds for a region)\n */\nexport default class VectorField extends Field {\n    /**\n     * Creates a VectorField from the content of two ASCIIGrid files\n     * @param   {String} ascU - with u-component\n     * @param   {String} ascV - with v-component\n     * @returns {VectorField}\n     */\n    static fromASCIIGrids(ascU, ascV, scaleFactor = 1) {\n        let u = ScalarField.fromASCIIGrid(ascU, scaleFactor);\n        let v = ScalarField.fromASCIIGrid(ascV, scaleFactor);\n        let p = VectorField._paramsFromScalarFields(u, v);\n\n        return new VectorField(p);\n    }\n\n    /**\n     * Creates a VectorField from the content of two different Geotiff files\n     * @param   {ArrayBuffer} gtU - geotiff data with u-component (band 0)\n     * @param   {ArrayBuffer} gtV - geotiff data with v-component (band 0)\n     * @returns {VectorField}\n     */\n    static fromGeoTIFFs(gtU, gtV) {\n        let u = ScalarField.fromGeoTIFF(gtU);\n        let v = ScalarField.fromGeoTIFF(gtV);\n        let p = VectorField._paramsFromScalarFields(u, v);\n\n        return new VectorField(p);\n    }\n\n    /**\n     * Creates a VectorField from the content of Multiband Geotiff\n     * @param   {ArrayBuffer} geotiffData - multiband\n     * @param   {Array} bandIndexesForUV\n     * @returns {VectorField}\n     */\n    static fromMultibandGeoTIFF(geotiffData, bandIndexesForUV = [0, 1]) {\n        let [u, v] = ScalarField.multipleFromGeoTIFF(\n            geotiffData,\n            bandIndexesForUV\n        );\n        let p = VectorField._paramsFromScalarFields(u, v);\n\n        return new VectorField(p);\n    }\n\n    /**\n     * Build parameters for VectorField, from 2 ScalarFields.\n     * No validation at all (nor interpolation) is applied, so u and v\n     * must be 'compatible' from the source\n     * @param   {ScalarField} u\n     * @param   {ScalarField} v\n     * @returns {Object} - parameters to build VectorField\n     */\n    static _paramsFromScalarFields(u, v) {\n        // TODO check u & v compatibility (cellSize...)\n        let p = {\n            nCols: u.nCols,\n            nRows: u.nRows,\n            xllCorner: u.xllCorner,\n            yllCorner: u.yllCorner,\n            cellXSize: u.cellXSize,\n            cellYSize: u.cellYSize,\n            us: u.zs,\n            vs: v.zs\n        };\n        return p;\n    }\n\n    constructor(params) {\n        super(params);\n\n        this.us = params['us'];\n        this.vs = params['vs'];\n        this.grid = this._buildGrid();\n        this.range = this._calculateRange();\n    }\n\n    /**\n     * Get a derived field, from a computation on\n     * the VectorField\n     * @param   {String} type ['magnitude' | 'directionTo' | 'directionFrom']\n     * @returns {ScalarField}\n     */\n    getScalarField(type) {\n        let f = this._getFunctionFor(type);\n        let p = {\n            nCols: this.params.nCols,\n            nRows: this.params.nRows,\n            xllCorner: this.params.xllCorner,\n            yllCorner: this.params.yllCorner,\n            cellXSize: this.params.cellXSize,\n            cellYSize: this.params.cellYSize,\n            zs: this._applyOnField(f)\n        };\n        return new ScalarField(p);\n    }\n\n    _getFunctionFor(type) {\n        return function(u, v) {\n            let uv = new Vector(u, v);\n            return uv[type](); // magnitude, directionTo, directionFrom\n        };\n    }\n\n    _applyOnField(func) {\n        let zs = [];\n        let n = this.numCells();\n        for (var i = 0; i < n; i++) {\n            let u = this.us[i];\n            let v = this.vs[i];\n            if (this._isValid(u) && this._isValid(v)) {\n                zs.push(func(u, v));\n            } else {\n                zs.push(null);\n            }\n        }\n        return zs;\n    }\n\n    /**\n     * Builds a grid with a Vector at each point, from two arrays\n     * 'us' and 'vs' following x-ascending & y-descending order\n     * (same as in ASCIIGrid)\n     * @returns {Array.<Array.<Vector>>} - grid[row][column]--> Vector\n     */\n    _buildGrid() {\n        let grid = this._arraysTo2d(this.us, this.vs, this.nRows, this.nCols);\n        return grid;\n    }\n\n    _arraysTo2d(us, vs, nRows, nCols) {\n        let grid = [];\n        let p = 0;\n\n        for (var j = 0; j < nRows; j++) {\n            var row = [];\n            for (var i = 0; i < nCols; i++, p++) {\n                let u = us[p],\n                    v = vs[p];\n                let valid = this._isValid(u) && this._isValid(v);\n                row[i] = valid ? new Vector(u, v) : null; // <<<\n            }\n            grid[j] = row;\n        }\n        return grid;\n    }\n\n    _newDataArrays(params) {\n        params['us'] = [];\n        params['vs'] = [];\n    }\n    _pushValueToArrays(params, value) {\n        //console.log(value);\n        params['us'].push(value.u);\n        params['vs'].push(value.v);\n    }\n    _makeNewFrom(params) {\n        return new VectorField(params);\n    }\n\n    /**\n     * Calculate min & max values (magnitude)\n     * @private\n     * @returns {Array}\n     */\n    _calculateRange() {\n        // TODO make a clearer method for getting these vectors...\n        let vectors = this.getCells()\n            .map(pt => pt.value)\n            .filter(function(v) {\n                return v !== null;\n            });\n\n        if (this._inFilter) {\n            vectors = vectors.filter(this._inFilter);\n        }\n\n        // TODO check memory crash with high num of vectors!\n        let magnitudes = vectors.map(v => v.magnitude());\n        let min = d3.min(magnitudes);\n        let max = d3.max(magnitudes);\n\n        return [min, max];\n    }\n\n    /**\n     * Bilinear interpolation for Vector\n     * https://en.wikipedia.org/wiki/Bilinear_interpolation\n     * @param   {Number} x\n     * @param   {Number} y\n     * @param   {Number[]} g00\n     * @param   {Number[]} g10\n     * @param   {Number[]} g01\n     * @param   {Number[]} g11\n     * @returns {Vector}\n     */\n    _doInterpolation(x, y, g00, g10, g01, g11) {\n        var rx = 1 - x;\n        var ry = 1 - y;\n        var a = rx * ry,\n            b = x * ry,\n            c = rx * y,\n            d = x * y;\n        var u = g00.u * a + g10.u * b + g01.u * c + g11.u * d;\n        var v = g00.v * a + g10.v * b + g01.v * c + g11.v * d;\n        return new Vector(u, v);\n    }\n\n    /**\n     * Is valid (not 'null' nor 'undefined')\n     * @private\n     * @param   {Object} x object\n     * @returns {Boolean}\n     */\n    _isValid(x) {\n        return x !== null && x !== undefined;\n    }\n}\n","// base\nimport Vector from './Vector.js';\nwindow.L.Vector = Vector;\n\nimport Cell from './Cell.js';\nwindow.L.Cell = Cell;\n\nimport Field from './Field.js';\nwindow.L.Field = Field;\n\nimport ScalarField from './ScalarField.js';\nwindow.L.ScalarField = ScalarField;\n\nimport VectorField from './VectorField.js';\nwindow.L.VectorField = VectorField;\n\n// layer\nrequire('./layer/L.CanvasLayer.js');\nrequire('./layer/L.CanvasLayer.SimpleLonLat.js');\nrequire('./layer/L.CanvasLayer.Field.js');\nrequire('./layer/L.CanvasLayer.ScalarField.js');\nrequire('./layer/L.CanvasLayer.VectorFieldAnim.js');\n\n// control\nrequire('./control/L.Control.ColorBar.js');"],"sourceRoot":""}