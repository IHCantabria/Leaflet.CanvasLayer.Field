{"version":3,"sources":["webpack:///leaflet.canvaslayer.field.js","webpack:///webpack/bootstrap ce12273210aff3d0b8d4","webpack:///./Cell.js","webpack:///./Field.js","webpack:///./ScalarField.js","webpack:///./Vector.js","webpack:///./VectorField.js","webpack:///./control/L.Control.ColorBar.js","webpack:///./layer/L.CanvasLayer.Field.js","webpack:///./layer/L.CanvasLayer.ScalarField.js","webpack:///./layer/L.CanvasLayer.SimpleLonLat.js","webpack:///./layer/L.CanvasLayer.VectorFieldAnim.js","webpack:///./layer/L.CanvasLayer.js","webpack:///../~/@turf/inside/index.js","webpack:///../~/@turf/invariant/index.js","webpack:///./_main.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","Cell","center","xSize","ySize","arguments","undefined","this","anotherCell","equals","_equalValues","anotherValue","type","constructor","Number","Vector","u","v","halfX","halfY","cLat","lat","cLng","lng","ul","L","latLng","lr","latLngBounds","__WEBPACK_IMPORTED_MODULE_0__Cell__","__WEBPACK_IMPORTED_MODULE_1__turf_inside__","__WEBPACK_IMPORTED_MODULE_1__turf_inside___default","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","push","err","Array","isArray","Field","params","nCols","nRows","width","height","xllCorner","yllCorner","xurCorner","yurCorner","cellXSize","cellYSize","grid","isContinuous","longitudeNeedsToBeWrapped","_inFilter","_spatialMask","range","_calculateRange","stride","cells","j","_lonLatAtIndexes2","_lonLatAtIndexes","_lonLatAtIndexes3","lon","_valueAtIndexes","f","_updateRange","_getWrappedLongitudes2","_getWrappedLongitudes","_getWrappedLongitudes3","xmin","xmax","_pointInMask","_pointInExtent","_getWrappedLongitudes4","_getWrappedLongitudes5","longitudeIn","latitudeIn","pt","geometry","coordinates","properties","poly","contains","notContains","_getDecimalIndexes2","_getDecimalIndexes","_getDecimalIndexes3","interpolatedValueAtIndexes","indexes","_getFourSurroundingIndexes","_indexes","fi","ci","fj","cj","values","_getFourSurroundingValues","_values","g00","g10","g01","g11","_doInterpolation","Math","floor","_clampColumnIndex","_clampRowIndex","row","_isValid","_getDecimalIndexes4","_getDecimalIndexes5","ii","jj","valueAt","hasValue","included","hasValueAt","random","x","_longitudeAtX","y","_latitudeAtY","halfXPixel","halfYPixel","maxCol","maxRow","_toConsumableArray","arr2","from","_defineProperty","obj","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0__Field__","ScalarField","_Field","_this","getPrototypeOf","zs","_buildGrid","asc","scaleFactor","lines","split","header","_parseASCIIGridHeader","slice","line","trim","forEach","it","floatItem","parseFloat","noDataValue","headerLines","headerItems","map","items","filter","toUpperCase","usesCorner","cellSize","parseInt","Error","data","bandIndex","multipleFromGeoTIFF","bandIndexes","tiff","GeoTIFF","parse","image","getImage","rasters","readRasters","tiepoint","getTiePoints","fileDirectory","getFileDirectory","_fileDirectory$ModelP","ModelPixelScale","xScale","yScale","keys","GDAL_NODATA","noData","z","getWidth","getHeight","_arrayTo2d","array","d3","min","max","rx","ry","sqrt","verticalAngle","atan2","inDegrees","PI","directionTo","__WEBPACK_IMPORTED_MODULE_0__Vector__","__WEBPACK_IMPORTED_MODULE_1__Field__","__WEBPACK_IMPORTED_MODULE_2__ScalarField__","VectorField","us","vs","ascU","ascV","fromASCIIGrid","_paramsFromScalarFields","gtU","gtV","fromGeoTIFF","geotiffData","bandIndexesForUV","_ScalarField$multiple","_ScalarField$multiple2","_getFunctionFor","_applyOnField","func","numCells","_arraysTo2d","valid","vectors","getCells","magnitudes","magnitude","a","b","Control","ColorBar","extend","options","position","margin","background","textColor","steps","decimals","units","title","labels","textLabels","labelFontSize","labelTextPosition","initialize","color","Util","setOptions","onAdd","_map","div","DomUtil","style","padding","DomEvent","addListener","stopPropagation","preventDefault","backgroundColor","cursor","innerHTML","palette","document","createElement","select","append","attr","text","svg","_createSvgIn","_appendColorBarTo","_appendLabelsTo","spaceForLabels","colorPerValue","_getColorPerValue","w","groupBars","buckets","selectAll","enter","hex","toFixed","_this2","positionPerLabelValue","_getPositionPerLabelValue","label","_this3","_range","delta","_this4","xPositionFor","scaleLinear","domain","index","control","colorBar","CanvasLayer","mouseMoveCursor","noValue","opacity","onClick","onMouseMove","inFilter","field","_visible","setData","getEvents","events","zoomstart","_hideCanvas","bind","zoomend","_showCanvas","onLayerDidMount","_enableIdentify","_ensureCanvasAlignment","show","hide","_disableIdentify","isVisible","_canvas","visibility","on","_onClick","_onMouseMove","off","topLeft","containerPointToLayerPoint","setPosition","onLayerWillUnmount","needRedraw","_field","onDrawLayer","viewInfo","setFilter","fire","setOpacity","_updateOpacity","getBounds","bb","extent","southWest","northEast","e","_queryValue","_changeCursorOn","_options$mouseMoveCur","getContainer","latlng","_getDrawingContext","g","getContext","clearRect","interpolate","vectorSize","arrowDirection","scalarField","_defaultColorScale","chroma","scale","setColor","_getRendererMethod","_drawImage","_drawArrows","_ensureColor","ctx","img","createImageData","_prepareImageIn","putImageData","pos","pointCoords","containerPointToLatLng","_getColorFor","_color$rgba","rgba","_color$rgba2","R","G","B","A","bounds","_pixelBounds","pixelSize","strokeStyle","currentBounds","_field$_lonLatAtIndex","_field$_lonLatAtIndex2","cell","_drawArrow","northWest","latLngToContainerPoint","getNorthWest","southEast","getSouthEast","projected","size","save","translate","rotationRads","rotate","beginPath","moveTo","lineTo","stroke","restore","canvasLayer","SimpleLonLat","points","canvas","fillStyle","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","point","layer","fillRect","fill","closePath","return","xs","ys","apply","ymin","ymax","simpleLonLat","lonslats","VectorFieldAnim","paths","fade","duration","maxAge","velocityScale","vectorField","timer","_stopAnimation","_moveParticles","par","age","randomPosition","vector","xt","yt","_drawParticles","prev","globalCompositeOperation","lineWidth","_drawParticle","_prepareParticlePaths","source","pA","pB","_randomAge","stop","vectorFieldAnim","Layer","_frame","_delegate","delegate","del","requestAnimFrame","drawLayer","_onLayerDidResize","resizeEvent","newSize","_onLayerDidMove","resize","moveend","zoomAnimation","Browser","any3d","zoomanim","_animateZoom","tiles","getSize","animated","addClass","_panes","overlayPane","appendChild","onRemove","getPanes","removeChild","addTo","addLayer","LatLonToMercator","latlon","log","tan","zoom","getZoom","getCenter","corner","getZoomScale","offset","_latLngToNewLayerPoint","setTransform","inRing","ring","ignoreBoundary","isInside","xi","yi","xj","yj","inBBox","bbox","invariant","getCoord","getCoords","polygon","polys","insidePoly","inHole","k","containsNumber","geojsonType","featureOf","feature","collectionOf","featureCollection","features","getGeom","geojson","geometries","getGeomType","geom","__WEBPACK_IMPORTED_MODULE_0__Vector_js__","__WEBPACK_IMPORTED_MODULE_1__Cell_js__","__WEBPACK_IMPORTED_MODULE_2__Field_js__","__WEBPACK_IMPORTED_MODULE_3__ScalarField_js__","__WEBPACK_IMPORTED_MODULE_4__VectorField_js__","window"],"mappings":"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","file":"leaflet.canvaslayer.field.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 13);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n *  Simple regular cell in a raster\r\n */\nvar Cell = function () {\n    /**\r\n     * A simple cell with a numerical value\r\n     * @param {L.LatLng} center\r\n     * @param {Number|Vector} value\r\n     * @param {Number} xSize\r\n     * @param {Number} ySize\r\n     */\n    function Cell(center, value, xSize) {\n        var ySize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : xSize;\n\n        _classCallCheck(this, Cell);\n\n        this.center = center;\n        this.value = value;\n        this.xSize = xSize;\n        this.ySize = ySize;\n    }\n\n    _createClass(Cell, [{\n        key: \"equals\",\n        value: function equals(anotherCell) {\n            return this.center.equals(anotherCell.center) && this._equalValues(this.value, anotherCell.value) && this.xSize === anotherCell.xSize && this.ySize === anotherCell.ySize;\n        }\n    }, {\n        key: \"_equalValues\",\n        value: function _equalValues(value, anotherValue) {\n            var type = value.constructor.name;\n            var answerFor = {\n                Number: value === anotherValue,\n                Vector: value.u === anotherValue.u && value.v === anotherValue.v\n            };\n            return answerFor[type];\n        }\n\n        /**\r\n         * Bounds for the cell\r\n         * @returns {LatLngBounds}\r\n         */\n\n    }, {\n        key: \"getBounds\",\n        value: function getBounds() {\n            var halfX = this.xSize / 2.0;\n            var halfY = this.ySize / 2.0;\n            var cLat = this.center.lat;\n            var cLng = this.center.lng;\n            var ul = L.latLng([cLat + halfY, cLng - halfX]);\n            var lr = L.latLng([cLat - halfY, cLng + halfX]);\n\n            return L.latLngBounds(L.latLng(lr.lat, ul.lng), L.latLng(ul.lat, lr.lng));\n        }\n    }]);\n\n    return Cell;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Cell);\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Cell__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__turf_inside__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__turf_inside___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__turf_inside__);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n/**\r\n *  Abstract class for a set of values (Vector | Scalar)\r\n *  assigned to a regular 2D-grid (lon-lat), aka 'a Raster source'\r\n */\n\nvar Field = function () {\n    function Field(params) {\n        _classCallCheck(this, Field);\n\n        this.params = params;\n\n        this.nCols = params['nCols'];\n        this.nRows = params['nRows'];\n\n        // alias\n        this.width = params['nCols'];\n        this.height = params['nRows'];\n\n        // ll = lower-left\n        this.xllCorner = params['xllCorner'];\n        this.yllCorner = params['yllCorner'];\n\n        // ur = upper-right\n        this.xurCorner = params['xllCorner'] + params['nCols'] * params['cellXSize'];\n        this.yurCorner = params['yllCorner'] + params['nRows'] * params['cellYSize'];\n\n        this.cellXSize = params['cellXSize'];\n        this.cellYSize = params['cellYSize'];\n\n        this.grid = null; // to be defined by subclasses\n        this.isContinuous = this.xurCorner - this.xllCorner >= 360;\n        this.longitudeNeedsToBeWrapped = this.xurCorner > 180; // [0, 360] --> [-180, 180]\n\n        this._inFilter = null;\n        this._spatialMask = null;\n    }\n\n    /**\r\n     * Builds a grid with a value at each point (either Vector or Number)\r\n     * Original params must include the required input values, following\r\n     * x-ascending & y-descending order (same as in ASCIIGrid)\r\n     * @abstract\r\n     * @private\r\n     * @returns {Array.<Array.<Vector|Number>>} - grid[row][column]--> Vector|Number\r\n     */\n\n\n    _createClass(Field, [{\n        key: '_buildGrid',\n        value: function _buildGrid() {\n            throw new TypeError('Must be overriden');\n        }\n    }, {\n        key: '_updateRange',\n        value: function _updateRange() {\n            this.range = this._calculateRange();\n        }\n\n        /**\r\n         * Number of cells in the grid (rows * cols)\r\n         * @returns {Number}\r\n         */\n\n    }, {\n        key: 'numCells',\n        value: function numCells() {\n            return this.nRows * this.nCols;\n        }\n\n        /**\r\n         * A list with every cell\r\n         * @returns {Array<Cell>} - cells (x-ascending & y-descending order)\r\n         */\n\n    }, {\n        key: 'getCells',\n        value: function getCells() {\n            var stride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n            var cells = [];\n            for (var j = 0; j < this.nRows; j = j + stride) {\n                for (var i = 0; i < this.nCols; i = i + stride) {\n                    var _lonLatAtIndexes2 = this._lonLatAtIndexes(i, j),\n                        _lonLatAtIndexes3 = _slicedToArray(_lonLatAtIndexes2, 2),\n                        lon = _lonLatAtIndexes3[0],\n                        lat = _lonLatAtIndexes3[1];\n\n                    var center = L.latLng(lat, lon);\n                    var value = this._valueAtIndexes(i, j);\n                    var c = new __WEBPACK_IMPORTED_MODULE_0__Cell__[\"a\" /* default */](center, value, this.cellXSize, this.cellYSize);\n                    cells.push(c); // <<\n                }\n            }\n            return cells;\n        }\n\n        /**\r\n         * Apply a filter function to field values\r\n         * @param   {Function} f - boolean function\r\n         */\n\n    }, {\n        key: 'setFilter',\n        value: function setFilter(f) {\n            this._inFilter = f;\n            this._updateRange();\n        }\n\n        /**\r\n         * Apply a spatial mask to field values\r\n         * @param {L.GeoJSON} m \r\n         */\n\n    }, {\n        key: 'setSpatialMask',\n        value: function setSpatialMask(m) {\n            this._spatialMask = m;\n        }\n\n        /**\r\n         * Grid extent\r\n         * @returns {Number[]} [xmin, ymin, xmax, ymax]\r\n         */\n\n    }, {\n        key: 'extent',\n        value: function extent() {\n            var _getWrappedLongitudes2 = this._getWrappedLongitudes(),\n                _getWrappedLongitudes3 = _slicedToArray(_getWrappedLongitudes2, 2),\n                xmin = _getWrappedLongitudes3[0],\n                xmax = _getWrappedLongitudes3[1];\n\n            return [xmin, this.yllCorner, xmax, this.yurCorner];\n        }\n\n        /**\r\n         * [xmin, xmax] in [-180, 180] range\r\n         */\n\n    }, {\n        key: '_getWrappedLongitudes',\n        value: function _getWrappedLongitudes() {\n            var xmin = this.xllCorner;\n            var xmax = this.xurCorner;\n\n            if (this.longitudeNeedsToBeWrapped) {\n                if (this.isContinuous) {\n                    xmin = -180;\n                    xmax = 180;\n                } else {\n                    // not sure about this (just one particular case, but others...?)\n                    xmax = this.xurCorner - 360;\n                    xmin = this.xllCorner - 360;\n                    /* eslint-disable no-console */\n                    // console.warn(`are these xmin: ${xmin} & xmax: ${xmax} OK?`);\n                    // TODO: Better throw an exception on no-controlled situations.\n                    /* eslint-enable no-console */\n                }\n            }\n            return [xmin, xmax];\n        }\n\n        /**\r\n         * Returns whether or not the grid contains the point, considering\r\n         * the spatialMask if it has been previously set\r\n         * @param   {Number} lon - longitude\r\n         * @param   {Number} lat - latitude\r\n         * @returns {Boolean}\r\n         */\n\n    }, {\n        key: 'contains',\n        value: function contains(lon, lat) {\n            if (this._spatialMask) {\n                return this._pointInMask(lon, lat);\n            }\n            return this._pointInExtent(lon, lat);\n        }\n\n        /**\r\n         * Checks if coordinates are inside the Extent (considering wrapped longitudes if needed)\r\n         * @param {Number} lon \r\n         * @param {Number} lat \r\n         */\n\n    }, {\n        key: '_pointInExtent',\n        value: function _pointInExtent(lon, lat) {\n            var _getWrappedLongitudes4 = this._getWrappedLongitudes(),\n                _getWrappedLongitudes5 = _slicedToArray(_getWrappedLongitudes4, 2),\n                xmin = _getWrappedLongitudes5[0],\n                xmax = _getWrappedLongitudes5[1];\n\n            var longitudeIn = lon >= xmin && lon <= xmax;\n            var latitudeIn = lat >= this.yllCorner && lat <= this.yurCorner;\n            return longitudeIn && latitudeIn;\n        }\n\n        /**\r\n         * Check if coordinates are inside the spatialMask (Point in Polygon analysis)\r\n         * @param {Number} lon \r\n         * @param {Number} lat \r\n         */\n\n    }, {\n        key: '_pointInMask',\n        value: function _pointInMask(lon, lat) {\n            var pt = {\n                type: 'Feature',\n                geometry: {\n                    type: 'Point',\n                    coordinates: [lon, lat] // geojson, lon-lat order !\n                },\n                properties: {}\n            };\n            var poly = this._spatialMask;\n            return __WEBPACK_IMPORTED_MODULE_1__turf_inside___default()(pt, poly);\n        }\n\n        /**\r\n         * Returns if the grid doesn't contain the point\r\n         * @param   {Number} lon - longitude\r\n         * @param   {Number} lat - latitude\r\n         * @returns {Boolean}\r\n         */\n\n    }, {\n        key: 'notContains',\n        value: function notContains(lon, lat) {\n            return !this.contains(lon, lat);\n        }\n\n        /**\r\n         * Interpolated value at lon-lat coordinates (bilinear method)\r\n         * @param   {Number} longitude\r\n         * @param   {Number} latitude\r\n         * @returns {Vector|Number} [u, v, magnitude]\r\n         *                          \r\n         * Source: https://github.com/cambecc/earth > product.js\r\n         */\n\n    }, {\n        key: 'interpolatedValueAt',\n        value: function interpolatedValueAt(lon, lat) {\n            if (this.notContains(lon, lat)) return null;\n\n            var _getDecimalIndexes2 = this._getDecimalIndexes(lon, lat),\n                _getDecimalIndexes3 = _slicedToArray(_getDecimalIndexes2, 2),\n                i = _getDecimalIndexes3[0],\n                j = _getDecimalIndexes3[1];\n\n            return this.interpolatedValueAtIndexes(i, j);\n        }\n\n        /**\r\n         * Interpolated value at i-j indexes (bilinear method)\r\n         * @param   {Number} i\r\n         * @param   {Number} j\r\n         * @returns {Vector|Number} [u, v, magnitude]\r\n         *\r\n         * Source: https://github.com/cambecc/earth > product.js\r\n         */\n\n    }, {\n        key: 'interpolatedValueAtIndexes',\n        value: function interpolatedValueAtIndexes(i, j) {\n            //         1      2           After converting  and  to fractional grid indexes i and j, we find the\n            //        fi  i   ci          four points 'G' that enclose point (i, j). These points are at the four\n            //         | =1.4 |           corners specified by the floor and ceiling of i and j. For example, given\n            //      ---G--|---G--- fj 8   i = 1.4 and j = 8.3, the four surrounding grid points are (1, 8), (2, 8),\n            //    j ___|_ .   |           (1, 9) and (2, 9).\n            //  =8.3   |      |\n            //      ---G------G--- cj 9   Note that for wrapped grids, the first column is duplicated as the last\n            //         |      |           column, so the index ci can be used without taking a modulo.\n\n            var indexes = this._getFourSurroundingIndexes(i, j);\n\n            var _indexes = _slicedToArray(indexes, 4),\n                fi = _indexes[0],\n                ci = _indexes[1],\n                fj = _indexes[2],\n                cj = _indexes[3];\n\n            var values = this._getFourSurroundingValues(fi, ci, fj, cj);\n            if (values) {\n                var _values = _slicedToArray(values, 4),\n                    g00 = _values[0],\n                    g10 = _values[1],\n                    g01 = _values[2],\n                    g11 = _values[3];\n\n                return this._doInterpolation(i - fi, j - fj, g00, g10, g01, g11);\n            }\n            return null;\n        }\n\n        /**\r\n         * Get decimal indexes\r\n         * @private\r\n         * @param {Number} lon\r\n         * @param {Number} lat\r\n         * @returns {Array}    [[Description]]\r\n         */\n\n    }, {\n        key: '_getDecimalIndexes',\n        value: function _getDecimalIndexes(lon, lat) {\n            if (this.longitudeNeedsToBeWrapped && lon < this.xllCorner) {\n                lon = lon + 360;\n            }\n            var i = (lon - this.xllCorner) / this.cellXSize;\n            var j = (this.yurCorner - lat) / this.cellYSize;\n            return [i, j];\n        }\n\n        /**\r\n         * Get surrounding indexes (integer), clampling on borders\r\n         * @private\r\n         * @param   {Number} i - decimal index\r\n         * @param   {Number} j - decimal index\r\n         * @returns {Array} [fi, ci, fj, cj]\r\n         */\n\n    }, {\n        key: '_getFourSurroundingIndexes',\n        value: function _getFourSurroundingIndexes(i, j) {\n            var fi = Math.floor(i);\n            var ci = fi + 1;\n            // duplicate colum to simplify interpolation logic (wrapped value)\n            if (this.isContinuous && ci >= this.nCols) {\n                ci = 0;\n            }\n            ci = this._clampColumnIndex(ci);\n\n            var fj = this._clampRowIndex(Math.floor(j));\n            var cj = this._clampRowIndex(fj + 1);\n\n            return [fi, ci, fj, cj];\n        }\n\n        /**\r\n         * Get four surrounding values or null if not available,\r\n         * from 4 integer indexes\r\n         * @private\r\n         * @param   {Number} fi\r\n         * @param   {Number} ci\r\n         * @param   {Number} fj\r\n         * @param   {Number} cj\r\n         * @returns {Array} \r\n         */\n\n    }, {\n        key: '_getFourSurroundingValues',\n        value: function _getFourSurroundingValues(fi, ci, fj, cj) {\n            var row;\n            if (row = this.grid[fj]) {\n                // upper row ^^\n                var g00 = row[fi]; // << left\n                var g10 = row[ci]; // right >>\n                if (this._isValid(g00) && this._isValid(g10) && (row = this.grid[cj])) {\n                    // lower row vv\n                    var g01 = row[fi]; // << left\n                    var g11 = row[ci]; // right >>\n                    if (this._isValid(g01) && this._isValid(g11)) {\n                        return [g00, g10, g01, g11]; // 4 values found!\n                    }\n                }\n            }\n            return null;\n        }\n\n        /**\r\n         * Nearest value at lon-lat coordinates\r\n         * @param   {Number} longitude\r\n         * @param   {Number} latitude\r\n         * @returns {Vector|Number}\r\n         */\n\n    }, {\n        key: 'valueAt',\n        value: function valueAt(lon, lat) {\n            if (this.notContains(lon, lat)) return null;\n\n            var _getDecimalIndexes4 = this._getDecimalIndexes(lon, lat),\n                _getDecimalIndexes5 = _slicedToArray(_getDecimalIndexes4, 2),\n                i = _getDecimalIndexes5[0],\n                j = _getDecimalIndexes5[1];\n\n            var ii = Math.floor(i);\n            var jj = Math.floor(j);\n\n            var ci = this._clampColumnIndex(ii);\n            var cj = this._clampRowIndex(jj);\n\n            var value = this._valueAtIndexes(ci, cj);\n            if (this._inFilter) {\n                if (!this._inFilter(value)) return null;\n            }\n\n            return value;\n        }\n\n        /**\r\n         * Returns whether or not the field has a value at the point\r\n         * @param   {Number} lon - longitude\r\n         * @param   {Number} lat - latitude\r\n         * @returns {Boolean}\r\n         */\n\n    }, {\n        key: 'hasValueAt',\n        value: function hasValueAt(lon, lat) {\n            var value = this.valueAt(lon, lat);\n            var hasValue = value !== null;\n\n            var included = true;\n            if (this._inFilter) {\n                included = this._inFilter(value);\n            }\n            return hasValue && included;\n        }\n\n        /**\r\n         * Returns if the grid has no value at the point\r\n         * @param   {Number} lon - longitude\r\n         * @param   {Number} lat - latitude\r\n         * @returns {Boolean}\r\n         */\n\n    }, {\n        key: 'notHasValueAt',\n        value: function notHasValueAt(lon, lat) {\n            return !this.hasValueAt(lon, lat);\n        }\n\n        /**\r\n         * Gives a random position to 'o' inside the grid\r\n         * @param {Object} [o] - an object (eg. a particle)\r\n         * @returns {{x: Number, y: Number}} - object with x, y (lon, lat)\r\n         */\n\n    }, {\n        key: 'randomPosition',\n        value: function randomPosition() {\n            var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            var i = Math.random() * this.nCols | 0;\n            var j = Math.random() * this.nRows | 0;\n\n            o.x = this._longitudeAtX(i);\n            o.y = this._latitudeAtY(j);\n\n            return o;\n        }\n\n        /**\r\n         * Value for grid indexes\r\n         * @param   {Number} i - column index (integer)\r\n         * @param   {Number} j - row index (integer)\r\n         * @returns {Vector|Number}\r\n         */\n\n    }, {\n        key: '_valueAtIndexes',\n        value: function _valueAtIndexes(i, j) {\n            return this.grid[j][i]; // <-- j,i !!\n        }\n\n        /**\r\n         * Lon-Lat for grid indexes\r\n         * @param   {Number} i - column index (integer)\r\n         * @param   {Number} j - row index (integer)\r\n         * @returns {Number[]} [lon, lat]\r\n         */\n\n    }, {\n        key: '_lonLatAtIndexes',\n        value: function _lonLatAtIndexes(i, j) {\n            var lon = this._longitudeAtX(i);\n            var lat = this._latitudeAtY(j);\n\n            return [lon, lat];\n        }\n\n        /**\r\n         * Longitude for grid-index\r\n         * @param   {Number} i - column index (integer)\r\n         * @returns {Number} longitude at the center of the cell\r\n         */\n\n    }, {\n        key: '_longitudeAtX',\n        value: function _longitudeAtX(i) {\n            var halfXPixel = this.cellXSize / 2.0;\n            var lon = this.xllCorner + halfXPixel + i * this.cellXSize;\n            if (this.longitudeNeedsToBeWrapped) {\n                lon = lon > 180 ? lon - 360 : lon;\n            }\n            return lon;\n        }\n\n        /**\r\n         * Latitude for grid-index\r\n         * @param   {Number} j - row index (integer)\r\n         * @returns {Number} latitude at the center of the cell\r\n         */\n\n    }, {\n        key: '_latitudeAtY',\n        value: function _latitudeAtY(j) {\n            var halfYPixel = this.cellYSize / 2.0;\n            return this.yurCorner - halfYPixel - j * this.cellYSize;\n        }\n\n        /**\r\n         * Apply the interpolation\r\n         * @abstract\r\n         * @private\r\n         */\n        /* eslint-disable no-unused-vars */\n\n    }, {\n        key: '_doInterpolation',\n        value: function _doInterpolation(x, y, g00, g10, g01, g11) {\n            throw new TypeError('Must be overriden');\n        }\n        /* eslint-disable no-unused-vars */\n\n        /**\r\n         * Check the column index is inside the field,\r\n         * adjusting to min or max when needed\r\n         * @private\r\n         * @param   {Number} ii - index\r\n         * @returns {Number} i - inside the allowed indexes\r\n         */\n\n    }, {\n        key: '_clampColumnIndex',\n        value: function _clampColumnIndex(ii) {\n            var i = ii;\n            if (ii < 0) {\n                i = 0;\n            }\n            var maxCol = this.nCols - 1;\n            if (ii > maxCol) {\n                i = maxCol;\n            }\n            return i;\n        }\n\n        /**\r\n         * Check the row index is inside the field,\r\n         * adjusting to min or max when needed\r\n         * @private\r\n         * @param   {Number} jj index\r\n         * @returns {Number} j - inside the allowed indexes\r\n         */\n\n    }, {\n        key: '_clampRowIndex',\n        value: function _clampRowIndex(jj) {\n            var j = jj;\n            if (jj < 0) {\n                j = 0;\n            }\n            var maxRow = this.nRows - 1;\n            if (jj > maxRow) {\n                j = maxRow;\n            }\n            return j;\n        }\n\n        /**\r\n         * Is valid (not 'null' nor 'undefined')\r\n         * @private\r\n         * @param   {Object} x object\r\n         * @returns {Boolean}\r\n         */\n\n    }, {\n        key: '_isValid',\n        value: function _isValid(x) {\n            return x !== null && x !== undefined;\n        }\n    }]);\n\n    return Field;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Field);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Field__ = __webpack_require__(1);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n/**\r\n * Scalar Field\r\n */\n\nvar ScalarField = function (_Field) {\n    _inherits(ScalarField, _Field);\n\n    _createClass(ScalarField, null, [{\n        key: 'fromASCIIGrid',\n\n        /**\r\n         * Creates a ScalarField from the content of an ASCIIGrid file\r\n         * @param   {String}   asc\r\n         * @returns {ScalarField}\r\n         */\n        value: function fromASCIIGrid(asc) {\n            var scaleFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n            //console.time('ScalarField from ASC');\n\n            var lines = asc.split('\\n');\n\n            // Header\n            var header = ScalarField._parseASCIIGridHeader(lines.slice(0, 6));\n\n            // Data (left-right and top-down)\n            var zs = [];\n            for (var i = 6; i < lines.length; i++) {\n                var line = lines[i].trim();\n                if (line === '') break;\n\n                var items = line.split(' ');\n                items.forEach(function (it) {\n                    var floatItem = parseFloat(it);\n                    var v = floatItem !== header.noDataValue ? floatItem * scaleFactor : null;\n                    zs.push(v);\n                });\n            }\n            var p = header;\n            p.zs = zs;\n\n            //console.timeEnd('ScalarField from ASC');\n            return new ScalarField(p);\n        }\n\n        /**\r\n         * Parse an ASCII Grid header, made with 6 lines\r\n         * It allows the use of XLLCORNER/YLLCORNER or XLLCENTER/YLLCENTER conventions\r\n         * @param {Array.String} headerLines\r\n         */\n\n    }, {\n        key: '_parseASCIIGridHeader',\n        value: function _parseASCIIGridHeader(headerLines) {\n            try {\n                var headerItems = headerLines.map(function (line) {\n                    var items = line.split(' ').filter(function (i) {\n                        return i != '';\n                    });\n                    var param = items[0].trim().toUpperCase();\n                    var value = parseFloat(items[1].trim());\n                    return _defineProperty({}, param, value);\n                });\n\n                var usesCorner = 'XLLCORNER' in headerItems[2];\n                var cellSize = headerItems[4]['CELLSIZE'];\n\n                var header = {\n                    nCols: parseInt(headerItems[0]['NCOLS']),\n                    nRows: parseInt(headerItems[1]['NROWS']),\n                    xllCorner: usesCorner ? headerItems[2]['XLLCORNER'] : headerItems[2]['XLLCENTER'] - cellSize / 2,\n                    yllCorner: usesCorner ? headerItems[3]['YLLCORNER'] : headerItems[3]['YLLCENTER'] - cellSize / 2,\n                    cellXSize: cellSize,\n                    cellYSize: cellSize,\n                    noDataValue: headerItems[5]['NODATA_VALUE']\n                };\n                return header;\n            } catch (err) {\n                throw new Error('Not a valid ASCIIGrid Header: ' + err);\n            }\n        }\n\n        /**\r\n         * Creates a ScalarField from the content of a GeoTIFF file\r\n         * @param   {ArrayBuffer}   data\r\n         * @param   {Number}   bandIndex\r\n         * @returns {ScalarField}\r\n         */\n\n    }, {\n        key: 'fromGeoTIFF',\n        value: function fromGeoTIFF(data) {\n            var bandIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n            return ScalarField.multipleFromGeoTIFF(data, [bandIndex])[0];\n        }\n\n        /**\r\n         * Creates a ScalarField array (one per band) from the content of a GeoTIFF file\r\n         * @param   {ArrayBuffer}   data\r\n         * @param   {Array}   bandIndexes - if not provided all bands are returned\r\n         * @returns {Array.<ScalarField>}\r\n         */\n\n    }, {\n        key: 'multipleFromGeoTIFF',\n        value: function multipleFromGeoTIFF(data, bandIndexes) {\n            //console.time('ScalarField from GeoTIFF');\n\n            var tiff = GeoTIFF.parse(data); // geotiff.js\n            var image = tiff.getImage();\n            var rasters = image.readRasters();\n            var tiepoint = image.getTiePoints()[0];\n            var fileDirectory = image.getFileDirectory();\n\n            var _fileDirectory$ModelP = _slicedToArray(fileDirectory.ModelPixelScale, 2),\n                xScale = _fileDirectory$ModelP[0],\n                yScale = _fileDirectory$ModelP[1];\n\n            if (typeof bandIndexes === 'undefined' || bandIndexes.length === 0) {\n                bandIndexes = [].concat(_toConsumableArray(Array(rasters.length).keys()));\n            }\n\n            var scalarFields = [];\n            scalarFields = bandIndexes.map(function (bandIndex) {\n                var zs = rasters[bandIndex]; // left-right and top-down order\n\n                if (fileDirectory.GDAL_NODATA) {\n                    var noData = parseFloat(fileDirectory.GDAL_NODATA);\n                    // console.log(noData);\n                    var simpleZS = Array.from(zs); // to simple array, so null is allowed | TODO efficiency??\n                    zs = simpleZS.map(function (z) {\n                        return z === noData ? null : z;\n                    });\n                }\n\n                var p = {\n                    nCols: image.getWidth(),\n                    nRows: image.getHeight(),\n                    xllCorner: tiepoint.x,\n                    yllCorner: tiepoint.y - image.getHeight() * yScale,\n                    cellXSize: xScale,\n                    cellYSize: yScale,\n                    zs: zs\n                };\n                return new ScalarField(p);\n            });\n\n            //console.timeEnd('ScalarField from GeoTIFF');\n            return scalarFields;\n        }\n    }]);\n\n    function ScalarField(params) {\n        _classCallCheck(this, ScalarField);\n\n        var _this = _possibleConstructorReturn(this, (ScalarField.__proto__ || Object.getPrototypeOf(ScalarField)).call(this, params));\n\n        _this.zs = params['zs'];\n\n        _this.grid = _this._buildGrid();\n        _this._updateRange();\n        //console.log(`ScalarField created (${this.nCols} x ${this.nRows})`);\n        return _this;\n    }\n\n    /**\r\n     * Builds a grid with a Number at each point, from an array\r\n     * 'zs' following x-ascending & y-descending order\r\n     * (same as in ASCIIGrid)\r\n     * @private\r\n     * @returns {Array.<Array.<Number>>} - grid[row][column]--> Number\r\n     */\n\n\n    _createClass(ScalarField, [{\n        key: '_buildGrid',\n        value: function _buildGrid() {\n            var grid = this._arrayTo2d(this.zs, this.nRows, this.nCols);\n            return grid;\n        }\n    }, {\n        key: '_arrayTo2d',\n        value: function _arrayTo2d(array, nRows, nCols) {\n            var grid = [];\n            var p = 0;\n            for (var j = 0; j < nRows; j++) {\n                var row = [];\n                for (var i = 0; i < nCols; i++, p++) {\n                    var z = array[p];\n                    row[i] = this._isValid(z) ? z : null; // <<<\n                }\n                grid[j] = row;\n            }\n            return grid;\n        }\n    }, {\n        key: '_newDataArrays',\n        value: function _newDataArrays(params) {\n            params['zs'] = [];\n        }\n    }, {\n        key: '_pushValueToArrays',\n        value: function _pushValueToArrays(params, value) {\n            params['zs'].push(value);\n        }\n    }, {\n        key: '_makeNewFrom',\n        value: function _makeNewFrom(params) {\n            return new ScalarField(params);\n        }\n\n        /**\r\n         * Calculate min & max values\r\n         * @private\r\n         * @returns {Array} - [min, max]\r\n         */\n\n    }, {\n        key: '_calculateRange',\n        value: function _calculateRange() {\n            var data = this.zs;\n            if (this._inFilter) {\n                data = data.filter(this._inFilter);\n            }\n            return [d3.min(data), d3.max(data)];\n        }\n\n        /**\r\n         * Bilinear interpolation for Number\r\n         * https://en.wikipedia.org/wiki/Bilinear_interpolation\r\n         * @param   {Number} x\r\n         * @param   {Number} y\r\n         * @param   {Number} g00\r\n         * @param   {Number} g10\r\n         * @param   {Number} g01\r\n         * @param   {Number} g11\r\n         * @returns {Number}\r\n         */\n\n    }, {\n        key: '_doInterpolation',\n        value: function _doInterpolation(x, y, g00, g10, g01, g11) {\n            var rx = 1 - x;\n            var ry = 1 - y;\n            return g00 * rx * ry + g10 * x * ry + g01 * rx * y + g11 * x * y;\n        }\n    }]);\n\n    return ScalarField;\n}(__WEBPACK_IMPORTED_MODULE_0__Field__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ScalarField);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n *  2D Vector\r\n */\nvar Vector = function () {\n    function Vector(u, v) {\n        _classCallCheck(this, Vector);\n\n        this.u = u;\n        this.v = v;\n    }\n\n    /**\r\n     * Magnitude\r\n     * @returns {Number}\r\n     */\n\n\n    _createClass(Vector, [{\n        key: \"magnitude\",\n        value: function magnitude() {\n            return Math.sqrt(this.u * this.u + this.v * this.v);\n        }\n\n        /**\r\n         * Angle in degrees (0 to 360) --> Towards\r\n         * N is 0 and E is 90\r\n         * @returns {Number}\r\n         */\n\n    }, {\n        key: \"directionTo\",\n        value: function directionTo() {\n            var verticalAngle = Math.atan2(this.u, this.v);\n            var inDegrees = verticalAngle * (180.0 / Math.PI);\n            if (inDegrees < 0) {\n                inDegrees = inDegrees + 360.0;\n            }\n            return inDegrees;\n        }\n\n        /**\r\n         * Angle in degrees (0 to 360) From x-->\r\n         * N is 0 and E is 90\r\n         * @returns {Number}\r\n         */\n\n    }, {\n        key: \"directionFrom\",\n        value: function directionFrom() {\n            var a = this.directionTo();\n            var opposite = (a + 180.0) % 360.0;\n            return opposite;\n        }\n\n        /*\r\n            Degrees --> text\r\n            new Dictionary<int, string>\r\n            {\r\n                //{0, 23, 45, 68, 90, 113, 135, 158, 180, 203, 225, 248, 270, 293, 315, 338, 360};\r\n                {0, 'N'},\r\n                {23, 'NNE'},\r\n                {45, 'NE'},\r\n                {68, 'ENE'},\r\n                {90, 'E'},\r\n                {113, 'ESE'},\r\n                {135, 'SE'},\r\n                {158, 'SSE'},\r\n                {180, 'S'},\r\n                {203, 'SSW'},\r\n                {225, 'SW'},\r\n                {248, 'WSW'},\r\n                {270, 'W'},\r\n                {293, 'WNW'},\r\n                {315, 'NW'},\r\n                {338, 'NNW'},\r\n                {360, 'N'}\r\n            };\r\n        */\n\n    }]);\n\n    return Vector;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vector);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Vector__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Field__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ScalarField__ = __webpack_require__(2);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n/**\r\n *  A set of vectors assigned to a regular 2D-grid (lon-lat)\r\n *  (e.g. a raster representing winds for a region)\r\n */\n\nvar VectorField = function (_Field) {\n    _inherits(VectorField, _Field);\n\n    _createClass(VectorField, null, [{\n        key: 'fromASCIIGrids',\n\n        /**\r\n         * Creates a VectorField from the content of two ASCIIGrid files\r\n         * @param   {String} ascU - with u-component\r\n         * @param   {String} ascV - with v-component\r\n         * @returns {VectorField}\r\n         */\n        value: function fromASCIIGrids(ascU, ascV) {\n            var scaleFactor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n            var u = __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */].fromASCIIGrid(ascU, scaleFactor);\n            var v = __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */].fromASCIIGrid(ascV, scaleFactor);\n            var p = VectorField._paramsFromScalarFields(u, v);\n\n            return new VectorField(p);\n        }\n\n        /**\r\n         * Creates a VectorField from the content of two different Geotiff files\r\n         * @param   {ArrayBuffer} gtU - geotiff data with u-component (band 0)\r\n         * @param   {ArrayBuffer} gtV - geotiff data with v-component (band 0)\r\n         * @returns {VectorField}\r\n         */\n\n    }, {\n        key: 'fromGeoTIFFs',\n        value: function fromGeoTIFFs(gtU, gtV) {\n            var u = __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */].fromGeoTIFF(gtU);\n            var v = __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */].fromGeoTIFF(gtV);\n            var p = VectorField._paramsFromScalarFields(u, v);\n\n            return new VectorField(p);\n        }\n\n        /**\r\n         * Creates a VectorField from the content of Multiband Geotiff\r\n         * @param   {ArrayBuffer} geotiffData - multiband\r\n         * @param   {Array} bandIndexesForUV\r\n         * @returns {VectorField}\r\n         */\n\n    }, {\n        key: 'fromMultibandGeoTIFF',\n        value: function fromMultibandGeoTIFF(geotiffData) {\n            var bandIndexesForUV = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 1];\n\n            var _ScalarField$multiple = __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */].multipleFromGeoTIFF(geotiffData, bandIndexesForUV),\n                _ScalarField$multiple2 = _slicedToArray(_ScalarField$multiple, 2),\n                u = _ScalarField$multiple2[0],\n                v = _ScalarField$multiple2[1];\n\n            var p = VectorField._paramsFromScalarFields(u, v);\n\n            return new VectorField(p);\n        }\n\n        /**\r\n         * Build parameters for VectorField, from 2 ScalarFields.\r\n         * No validation at all (nor interpolation) is applied, so u and v\r\n         * must be 'compatible' from the source\r\n         * @param   {ScalarField} u\r\n         * @param   {ScalarField} v\r\n         * @returns {Object} - parameters to build VectorField\r\n         */\n\n    }, {\n        key: '_paramsFromScalarFields',\n        value: function _paramsFromScalarFields(u, v) {\n            // TODO check u & v compatibility (cellSize...)\n            var p = {\n                nCols: u.nCols,\n                nRows: u.nRows,\n                xllCorner: u.xllCorner,\n                yllCorner: u.yllCorner,\n                cellXSize: u.cellXSize,\n                cellYSize: u.cellYSize,\n                us: u.zs,\n                vs: v.zs\n            };\n            return p;\n        }\n    }]);\n\n    function VectorField(params) {\n        _classCallCheck(this, VectorField);\n\n        var _this = _possibleConstructorReturn(this, (VectorField.__proto__ || Object.getPrototypeOf(VectorField)).call(this, params));\n\n        _this.us = params['us'];\n        _this.vs = params['vs'];\n        _this.grid = _this._buildGrid();\n        _this.range = _this._calculateRange();\n        return _this;\n    }\n\n    /**\r\n     * Get a derived field, from a computation on\r\n     * the VectorField\r\n     * @param   {String} type ['magnitude' | 'directionTo' | 'directionFrom']\r\n     * @returns {ScalarField}\r\n     */\n\n\n    _createClass(VectorField, [{\n        key: 'getScalarField',\n        value: function getScalarField(type) {\n            var f = this._getFunctionFor(type);\n            var p = {\n                nCols: this.params.nCols,\n                nRows: this.params.nRows,\n                xllCorner: this.params.xllCorner,\n                yllCorner: this.params.yllCorner,\n                cellXSize: this.params.cellXSize,\n                cellYSize: this.params.cellYSize,\n                zs: this._applyOnField(f)\n            };\n            return new __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */](p);\n        }\n    }, {\n        key: '_getFunctionFor',\n        value: function _getFunctionFor(type) {\n            return function (u, v) {\n                var uv = new __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* default */](u, v);\n                return uv[type](); // magnitude, directionTo, directionFrom\n            };\n        }\n    }, {\n        key: '_applyOnField',\n        value: function _applyOnField(func) {\n            var zs = [];\n            var n = this.numCells();\n            for (var i = 0; i < n; i++) {\n                var u = this.us[i];\n                var v = this.vs[i];\n                if (this._isValid(u) && this._isValid(v)) {\n                    zs.push(func(u, v));\n                } else {\n                    zs.push(null);\n                }\n            }\n            return zs;\n        }\n\n        /**\r\n         * Builds a grid with a Vector at each point, from two arrays\r\n         * 'us' and 'vs' following x-ascending & y-descending order\r\n         * (same as in ASCIIGrid)\r\n         * @returns {Array.<Array.<Vector>>} - grid[row][column]--> Vector\r\n         */\n\n    }, {\n        key: '_buildGrid',\n        value: function _buildGrid() {\n            var grid = this._arraysTo2d(this.us, this.vs, this.nRows, this.nCols);\n            return grid;\n        }\n    }, {\n        key: '_arraysTo2d',\n        value: function _arraysTo2d(us, vs, nRows, nCols) {\n            var grid = [];\n            var p = 0;\n\n            for (var j = 0; j < nRows; j++) {\n                var row = [];\n                for (var i = 0; i < nCols; i++, p++) {\n                    var u = us[p],\n                        v = vs[p];\n                    var valid = this._isValid(u) && this._isValid(v);\n                    row[i] = valid ? new __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* default */](u, v) : null; // <<<\n                }\n                grid[j] = row;\n            }\n            return grid;\n        }\n    }, {\n        key: '_newDataArrays',\n        value: function _newDataArrays(params) {\n            params['us'] = [];\n            params['vs'] = [];\n        }\n    }, {\n        key: '_pushValueToArrays',\n        value: function _pushValueToArrays(params, value) {\n            //console.log(value);\n            params['us'].push(value.u);\n            params['vs'].push(value.v);\n        }\n    }, {\n        key: '_makeNewFrom',\n        value: function _makeNewFrom(params) {\n            return new VectorField(params);\n        }\n\n        /**\r\n         * Calculate min & max values (magnitude)\r\n         * @private\r\n         * @returns {Array}\r\n         */\n\n    }, {\n        key: '_calculateRange',\n        value: function _calculateRange() {\n            // TODO make a clearer method for getting these vectors...\n            var vectors = this.getCells().map(function (pt) {\n                return pt.value;\n            }).filter(function (v) {\n                return v !== null;\n            });\n\n            if (this._inFilter) {\n                vectors = vectors.filter(this._inFilter);\n            }\n\n            // TODO check memory crash with high num of vectors!\n            var magnitudes = vectors.map(function (v) {\n                return v.magnitude();\n            });\n            var min = d3.min(magnitudes);\n            var max = d3.max(magnitudes);\n\n            return [min, max];\n        }\n\n        /**\r\n         * Bilinear interpolation for Vector\r\n         * https://en.wikipedia.org/wiki/Bilinear_interpolation\r\n         * @param   {Number} x\r\n         * @param   {Number} y\r\n         * @param   {Number[]} g00\r\n         * @param   {Number[]} g10\r\n         * @param   {Number[]} g01\r\n         * @param   {Number[]} g11\r\n         * @returns {Vector}\r\n         */\n\n    }, {\n        key: '_doInterpolation',\n        value: function _doInterpolation(x, y, g00, g10, g01, g11) {\n            var rx = 1 - x;\n            var ry = 1 - y;\n            var a = rx * ry,\n                b = x * ry,\n                c = rx * y,\n                d = x * y;\n            var u = g00.u * a + g10.u * b + g01.u * c + g11.u * d;\n            var v = g00.v * a + g10.v * b + g01.v * c + g11.v * d;\n            return new __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* default */](u, v);\n        }\n\n        /**\r\n         * Is valid (not 'null' nor 'undefined')\r\n         * @private\r\n         * @param   {Object} x object\r\n         * @returns {Boolean}\r\n         */\n\n    }, {\n        key: '_isValid',\n        value: function _isValid(x) {\n            return x !== null && x !== undefined;\n        }\n    }]);\n\n    return VectorField;\n}(__WEBPACK_IMPORTED_MODULE_1__Field__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (VectorField);\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n/**\r\n *   Control for a simple legend with a colorbar\r\n *   References:\r\n *      - http://jsfiddle.net/ramnathv/g8stqcf6/\r\n *      - http://jsfiddle.net/vis4/cYLZH/\r\n */\nL.Control.ColorBar = L.Control.extend({\n    options: {\n        position: 'bottomleft',\n        width: 300, // for colorbar itself (control is wider)\n        height: 15,\n        margin: 15,\n        background: '#fff',\n        textColor: 'black',\n        steps: 100,\n        decimals: 2,\n        units: 'uds', // ej: m/s\n        title: 'Legend', // ej: Ocean Currents\n        labels: [], // empty for no labels\n        textLabels: [], // empty for default labels. Custom labels ej: ['low', 'mid','high'] \n        labelFontSize: 10,\n        labelTextPosition: 'middle' // start | middle | end\n    },\n\n    initialize: function initialize(color, range, options) {\n        this.color = color; // 'chromajs' scale function\n        this.range = range; // [min, max]\n        L.Util.setOptions(this, options);\n    },\n\n    onAdd: function onAdd(map) {\n        this._map = map;\n        var div = L.DomUtil.create('div', 'leaflet-control-colorBar leaflet-bar leaflet-control');\n        div.style.padding = '10px';\n\n        L.DomEvent.addListener(div, 'click', L.DomEvent.stopPropagation).addListener(div, 'click', L.DomEvent.preventDefault);\n        div.style.backgroundColor = this.options.background;\n        div.style.cursor = 'text';\n        div.innerHTML = this.title() + this.palette();\n        return div;\n    },\n\n    title: function title() {\n        var d = document.createElement('div');\n        d3.select(d).append('span').style('color', this.options.textColor).style('display', 'block').style('margin-bottom', '5px').attr('class', 'leaflet-control-colorBar-title').text(this.options.title);\n        return d.innerHTML;\n    },\n\n    palette: function palette() {\n        var d = document.createElement('div');\n        var svg = this._createSvgIn(d);\n\n        this._appendColorBarTo(svg);\n\n        if (this.options.labels) {\n            this._appendLabelsTo(svg);\n        }\n\n        return d.innerHTML;\n    },\n\n    _createSvgIn: function _createSvgIn(d) {\n        var spaceForLabels = this.options.labels ? this.options.margin : 0;\n        var svg = d3.select(d).append('svg').attr('width', this.options.width + this.options.margin * 2).attr('height', this.options.height + spaceForLabels);\n        return svg;\n    },\n\n    _appendColorBarTo: function _appendColorBarTo(svg) {\n        var _this = this;\n\n        var colorPerValue = this._getColorPerValue();\n        var w = this.options.width / colorPerValue.length;\n\n        var groupBars = svg.append('g').attr('id', 'colorBar-buckets');\n        var buckets = groupBars.selectAll('rect').data(colorPerValue).enter().append('rect');\n        buckets.attr('x', function (d, i) {\n            return i * w + _this.options.margin;\n        }).attr('y', function () {\n            return 0;\n        }).attr('height', function () {\n            return _this.options.height;\n        } /*w * 4*/).attr('width', function () {\n            return w;\n        }).attr('stroke-width', 2).attr('stroke-linecap', 'butt').attr('stroke', function (d) {\n            return d.color.hex();\n        }).attr('fill', function (d) {\n            return d.color.hex();\n        });\n        buckets.append('title').text(function (d) {\n            return d.value.toFixed(_this.options.decimals) + ' ' + _this.options.units;\n        });\n    },\n\n    _appendLabelsTo: function _appendLabelsTo(svg) {\n        var _this2 = this;\n\n        var positionPerLabelValue = this._getPositionPerLabelValue();\n        //const w = this.options.width / colorPerValue.length;\n        var groupLabels = svg.append('g').attr('id', 'colorBar-labels');\n        var labels = groupLabels.selectAll('text').data(positionPerLabelValue).enter().append('text');\n        labels.attr('x', function (d) {\n            return d.position + _this2.options.margin;\n        }).attr('y', this.options.height + this.options.margin).attr('font-size', this.options.labelFontSize + 'px').attr('text-anchor', this.options.labelTextPosition).attr('fill', this.options.textColor).attr('class', 'leaflet-control-colorBar-label').text(function (d) {\n            return _this2.options.textLabels ? d.label : '' + d.value.toFixed(_this2.options.decimals);\n        });\n    },\n\n    _getColorPerValue: function _getColorPerValue() {\n        var _this3 = this;\n\n        var _range = _slicedToArray(this.range, 2),\n            min = _range[0],\n            max = _range[1];\n\n        var delta = (max - min) / this.options.steps;\n        var data = d3.range(min, max + delta, delta);\n        var colorPerValue = data.map(function (d) {\n            return {\n                value: d,\n                color: _this3.color(d)\n            };\n        });\n        return colorPerValue;\n    },\n\n    _getPositionPerLabelValue: function _getPositionPerLabelValue() {\n        var _this4 = this;\n\n        var xPositionFor = d3.scaleLinear().range([0, this.options.width]).domain(this.range);\n        var data = this.options.labels;\n        var positionPerLabel = data.map(function (d, index) {\n            return {\n                label: _this4.options.textLabels ? _this4.options.textLabels[index] : '',\n                value: d,\n                position: xPositionFor(d)\n            };\n        });\n        return positionPerLabel;\n    }\n});\n\nL.control.colorBar = function (color, range, options) {\n    return new L.Control.ColorBar(color, range, options);\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n/**\r\n * Abstract class for a Field layer on canvas, aka 'a Raster layer'\r\n * (ScalarField or a VectorField)\r\n */\nL.CanvasLayer.Field = L.CanvasLayer.extend({\n    options: {\n        mouseMoveCursor: {\n            value: 'pointer',\n            noValue: 'default'\n        },\n        opacity: 1,\n        onClick: null,\n        onMouseMove: null,\n        inFilter: null\n    },\n\n    initialize: function initialize(field, options) {\n        L.Util.setOptions(this, options);\n        this._visible = true;\n        if (field) {\n            this.setData(field);\n        }\n    },\n\n    getEvents: function getEvents() {\n        var events = L.CanvasLayer.prototype.getEvents.call(this);\n        events.zoomstart = this._hideCanvas.bind(this);\n        events.zoomend = this._showCanvas.bind(this);\n        return events;\n    },\n\n    onLayerDidMount: function onLayerDidMount() {\n        this._enableIdentify();\n        this._ensureCanvasAlignment();\n    },\n\n    show: function show() {\n        this._visible = true;\n        this._showCanvas();\n        this._enableIdentify();\n    },\n    hide: function hide() {\n        this._visible = false;\n        this._hideCanvas();\n        this._disableIdentify();\n    },\n    isVisible: function isVisible() {\n        return this._visible;\n    },\n    _showCanvas: function _showCanvas() {\n        if (this._canvas && this._visible) {\n            this._canvas.style.visibility = 'visible';\n        }\n    },\n    _hideCanvas: function _hideCanvas() {\n        if (this._canvas) {\n            this._canvas.style.visibility = 'hidden';\n        }\n    },\n    _enableIdentify: function _enableIdentify() {\n        this._map.on('click', this._onClick, this);\n        this._map.on('mousemove', this._onMouseMove, this);\n\n        this.options.onClick && this.on('click', this.options.onClick, this);\n        this.options.onMouseMove && this.on('mousemove', this.options.onMouseMove, this);\n    },\n    _disableIdentify: function _disableIdentify() {\n        this._map.off('click', this._onClick, this);\n        this._map.off('mousemove', this._onMouseMove, this);\n\n        this.options.onClick && this.off('click', this.options.onClick, this);\n        this.options.onMouseMove && this.off('mousemove', this.options.onMouseMove, this);\n    },\n    _ensureCanvasAlignment: function _ensureCanvasAlignment() {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n    },\n\n\n    onLayerWillUnmount: function onLayerWillUnmount() {\n        this._disableIdentify();\n    },\n\n    needRedraw: function needRedraw() {\n        if (this._map && this._field) {\n            L.CanvasLayer.prototype.needRedraw.call(this);\n        }\n    },\n\n\n    /* eslint-disable no-unused-vars */\n    onDrawLayer: function onDrawLayer(viewInfo) {\n        throw new TypeError('Must be overriden');\n    },\n    /* eslint-enable no-unused-vars */\n\n    setData: function setData(field) {\n        this.options.inFilter && field.setFilter(this.options.inFilter);\n        this._field = field;\n        this.needRedraw();\n        this.fire('load');\n    },\n\n    setFilter: function setFilter(f) {\n        this.options.inFilter = f;\n        this._field && this._field.setFilter(f);\n        this.needRedraw();\n    },\n\n    setOpacity: function setOpacity(opacity) {\n        this.options.opacity = opacity;\n\n        if (this._canvas) {\n            this._updateOpacity();\n        }\n        return this;\n    },\n\n    getBounds: function getBounds() {\n        var bb = this._field.extent();\n\n        var southWest = L.latLng(bb[1], bb[0]),\n            northEast = L.latLng(bb[3], bb[2]);\n        var bounds = L.latLngBounds(southWest, northEast);\n        return bounds;\n    },\n\n    _onClick: function _onClick(e) {\n        var v = this._queryValue(e);\n        this.fire('click', v);\n    },\n\n    _onMouseMove: function _onMouseMove(e) {\n        var v = this._queryValue(e);\n        this._changeCursorOn(v);\n        this.fire('mousemove', v);\n    },\n\n    _changeCursorOn: function _changeCursorOn(v) {\n        if (!this.options.mouseMoveCursor) return;\n\n        var _options$mouseMoveCur = this.options.mouseMoveCursor,\n            value = _options$mouseMoveCur.value,\n            noValue = _options$mouseMoveCur.noValue;\n\n        var style = this._map.getContainer().style;\n        style.cursor = v.value !== null ? value : noValue;\n    },\n\n    _updateOpacity: function _updateOpacity() {\n        L.DomUtil.setOpacity(this._canvas, this.options.opacity);\n    },\n\n    _queryValue: function _queryValue(e) {\n        var v = this._field ? this._field.valueAt(e.latlng.lng, e.latlng.lat) : null;\n        var result = {\n            latlng: e.latlng,\n            value: v\n        };\n        return result;\n    },\n\n    _getDrawingContext: function _getDrawingContext() {\n        var g = this._canvas.getContext('2d');\n        g.clearRect(0, 0, this._canvas.width, this._canvas.height);\n        return g;\n    }\n});\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Cell__ = __webpack_require__(0);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n\n\n/**\r\n * ScalarField on canvas (a 'Raster')\r\n */\nL.CanvasLayer.ScalarField = L.CanvasLayer.Field.extend({\n    options: {\n        type: 'colormap', // [colormap|vector]\n        color: null, // function colorFor(value) [e.g. chromajs.scale],\n        interpolate: false, // Change to use interpolation\n        vectorSize: 20, // only used if 'vector'\n        arrowDirection: 'from' // [from|towards]\n    },\n\n    initialize: function initialize(scalarField, options) {\n        L.CanvasLayer.Field.prototype.initialize.call(this, scalarField, options);\n        L.Util.setOptions(this, options);\n    },\n\n    _defaultColorScale: function _defaultColorScale() {\n        return chroma.scale(['white', 'black']).domain(this._field.range);\n    },\n\n    setColor: function setColor(f) {\n        this.options.color = f;\n        this.needRedraw();\n    },\n\n\n    /* eslint-disable no-unused-vars */\n    onDrawLayer: function onDrawLayer(viewInfo) {\n        if (!this.isVisible()) return;\n        this._updateOpacity();\n\n        var r = this._getRendererMethod();\n        //console.time('onDrawLayer');\n        r();\n        //console.timeEnd('onDrawLayer');\n    },\n    /* eslint-enable no-unused-vars */\n\n    _getRendererMethod: function _getRendererMethod() {\n        switch (this.options.type) {\n            case 'colormap':\n                return this._drawImage.bind(this);\n            case 'vector':\n                return this._drawArrows.bind(this);\n            default:\n                throw Error('Unkwown renderer type: ' + this.options.type);\n        }\n    },\n\n    _ensureColor: function _ensureColor() {\n        if (this.options.color === null) {\n            this.setColor(this._defaultColorScale());\n        }\n    },\n\n    _showCanvas: function _showCanvas() {\n        L.CanvasLayer.Field.prototype._showCanvas.call(this);\n        this.needRedraw(); // TODO check spurious redraw (e.g. hide/show without moving map)\n    },\n\n\n    /**\r\n     * Draws the field in an ImageData and applying it with putImageData.\r\n     * Used as a reference: http://geoexamples.com/d3-raster-tools-docs/code_samples/raster-pixels-page.html\r\n     */\n    _drawImage: function _drawImage() {\n        this._ensureColor();\n\n        var ctx = this._getDrawingContext();\n        var width = this._canvas.width;\n        var height = this._canvas.height;\n\n        var img = ctx.createImageData(width, height);\n        var data = img.data;\n\n        this._prepareImageIn(data, width, height);\n        ctx.putImageData(img, 0, 0);\n    },\n\n    /**\r\n     * Prepares the image in data, as array with RGBAs\r\n     * [R1, G1, B1, A1, R2, G2, B2, A2...]\r\n     * @private\r\n     * @param {[[Type]]} data   [[Description]]\r\n     * @param {Numver} width\r\n     * @param {Number} height\r\n     */\n    _prepareImageIn: function _prepareImageIn(data, width, height) {\n        var f = this.options.interpolate ? 'interpolatedValueAt' : 'valueAt';\n\n        var pos = 0;\n        for (var j = 0; j < height; j++) {\n            for (var i = 0; i < width; i++) {\n                var pointCoords = this._map.containerPointToLatLng([i, j]);\n                var lon = pointCoords.lng;\n                var lat = pointCoords.lat;\n\n                var v = this._field[f](lon, lat); // 'valueAt' | 'interpolatedValueAt' || TODO check some 'artifacts'\n                if (v !== null) {\n                    var color = this._getColorFor(v);\n\n                    var _color$rgba = color.rgba(),\n                        _color$rgba2 = _slicedToArray(_color$rgba, 4),\n                        R = _color$rgba2[0],\n                        G = _color$rgba2[1],\n                        B = _color$rgba2[2],\n                        A = _color$rgba2[3];\n\n                    data[pos] = R;\n                    data[pos + 1] = G;\n                    data[pos + 2] = B;\n                    data[pos + 3] = parseInt(A * 255); // not percent in alpha but hex 0-255\n                }\n                pos = pos + 4;\n            }\n        }\n    },\n\n\n    /**\r\n     * Draws the field as a set of arrows. Direction from 0 to 360 is assumed.\r\n     */\n    _drawArrows: function _drawArrows() {\n        var bounds = this._pixelBounds();\n        var pixelSize = (bounds.max.x - bounds.min.x) / this._field.nCols;\n\n        var stride = Math.max(1, Math.floor(1.2 * this.options.vectorSize / pixelSize));\n\n        var ctx = this._getDrawingContext();\n        ctx.strokeStyle = this.options.color;\n\n        var currentBounds = this._map.getBounds();\n\n        for (var y = 0; y < this._field.height; y = y + stride) {\n            for (var x = 0; x < this._field.width; x = x + stride) {\n                var _field$_lonLatAtIndex = this._field._lonLatAtIndexes(x, y),\n                    _field$_lonLatAtIndex2 = _slicedToArray(_field$_lonLatAtIndex, 2),\n                    lon = _field$_lonLatAtIndex2[0],\n                    lat = _field$_lonLatAtIndex2[1];\n\n                var v = this._field.valueAt(lon, lat);\n                var center = L.latLng(lat, lon);\n                if (v !== null && currentBounds.contains(center)) {\n                    var cell = new __WEBPACK_IMPORTED_MODULE_0__Cell__[\"a\" /* default */](center, v, this.cellXSize, this.cellYSize);\n                    this._drawArrow(cell, ctx);\n                }\n            }\n        }\n    },\n\n    _pixelBounds: function _pixelBounds() {\n        var bounds = this.getBounds();\n        var northWest = this._map.latLngToContainerPoint(bounds.getNorthWest());\n        var southEast = this._map.latLngToContainerPoint(bounds.getSouthEast());\n        var pixelBounds = L.bounds(northWest, southEast);\n        return pixelBounds;\n    },\n\n    _drawArrow: function _drawArrow(cell, ctx) {\n        var projected = this._map.latLngToContainerPoint(cell.center);\n\n        // colormap vs. simple color\n        var color = this.options.color;\n        if (typeof color === 'function') {\n            ctx.strokeStyle = color(cell.value);\n        }\n\n        var size = this.options.vectorSize;\n        ctx.save();\n\n        ctx.translate(projected.x, projected.y);\n\n        var rotationRads = (90 + cell.value) * Math.PI / 180; // from, by default\n        if (this.options.arrowDirection === 'towards') {\n            rotationRads = rotationRads + Math.PI;\n        }\n        ctx.rotate(rotationRads);\n\n        ctx.beginPath();\n        ctx.moveTo(-size / 2, 0);\n        ctx.lineTo(+size / 2, 0);\n        ctx.moveTo(size * 0.25, -size * 0.25);\n        ctx.lineTo(+size / 2, 0);\n        ctx.lineTo(size * 0.25, size * 0.25);\n        ctx.stroke();\n        ctx.restore();\n    },\n\n    /**\r\n     * Gets a chroma color for a pixel value, according to 'options.color'\r\n     */\n    _getColorFor: function _getColorFor(v) {\n        var c = this.options.color; // e.g. for a constant 'red'\n        if (typeof c === 'function') {\n            c = this.options.color(v);\n        }\n        var color = chroma(c); // to be more flexible, a chroma color object is always created || TODO improve efficiency\n        return color;\n    }\n});\n\nL.canvasLayer.scalarField = function (scalarField, options) {\n    return new L.CanvasLayer.ScalarField(scalarField, options);\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\r\n *  Simple layer with lon-lat points\r\n *\r\n *  TODO rename to SimplePoint?\r\n */\nL.CanvasLayer.SimpleLonLat = L.CanvasLayer.extend({\n    options: {\n        color: 'gray'\n    },\n\n    initialize: function initialize(points, options) {\n        this.points = points;\n        L.Util.setOptions(this, options);\n    },\n\n    onLayerDidMount: function onLayerDidMount() {\n        // -- prepare custom drawing\n    },\n\n    onLayerWillUnmount: function onLayerWillUnmount() {\n        // -- custom cleanup\n    },\n\n    /* eslint-disable no-unused-vars */\n    setData: function setData(data) {\n        // -- custom data set\n        this.needRedraw(); // -- call to drawLayer\n    },\n    /* eslint-enable no-unused-vars */\n\n    onDrawLayer: function onDrawLayer(viewInfo) {\n        // canvas preparation\n        var g = viewInfo.canvas.getContext('2d');\n        g.clearRect(0, 0, viewInfo.canvas.width, viewInfo.canvas.height);\n        g.fillStyle = this.options.color;\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = this.points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var point = _step.value;\n\n                var p = viewInfo.layer._map.latLngToContainerPoint(point);\n                g.beginPath();\n                //g.arc(p.x, p.y, 1, 0, Math.PI * 2); // circle | TODO style 'function' as parameter?\n                g.fillRect(p.x, p.y, 2, 2); //simple point\n                g.fill();\n                g.closePath();\n                g.stroke();\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    },\n\n    getBounds: function getBounds() {\n        // TODO: bounding with points...\n        var xs = this.points.map(function (pt) {\n            return pt.lng;\n        });\n        var ys = this.points.map(function (pt) {\n            return pt.lat;\n        });\n\n        var xmin = Math.min.apply(Math, _toConsumableArray(xs));\n        var ymin = Math.min.apply(Math, _toConsumableArray(ys));\n        var xmax = Math.max.apply(Math, _toConsumableArray(xs));\n        var ymax = Math.max.apply(Math, _toConsumableArray(ys));\n\n        var southWest = L.latLng(ymin, xmin),\n            northEast = L.latLng(ymax, xmax);\n        var bounds = L.latLngBounds(southWest, northEast); // TODO FIX ERROR ? half-pixel?\n        return bounds;\n    }\n});\n\nL.canvasLayer.simpleLonLat = function (lonslats, options) {\n    return new L.CanvasLayer.SimpleLonLat(lonslats, options);\n};\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n/**\r\n * Animated VectorField on canvas\r\n */\nL.CanvasLayer.VectorFieldAnim = L.CanvasLayer.Field.extend({\n    options: {\n        paths: 800,\n        color: 'white', // html-color | function colorFor(value) [e.g. chromajs.scale]\n        width: 1.0, // number | function widthFor(value)\n        fade: 0.96, // 0 to 1\n        duration: 20, // milliseconds per 'frame'\n        maxAge: 200, // number of maximum frames per path\n        velocityScale: 1 / 5000\n    },\n\n    initialize: function initialize(vectorField, options) {\n        L.CanvasLayer.Field.prototype.initialize.call(this, vectorField, options);\n        L.Util.setOptions(this, options);\n\n        this.timer = null;\n    },\n\n    onLayerDidMount: function onLayerDidMount() {\n        L.CanvasLayer.Field.prototype.onLayerDidMount.call(this);\n        this._map.on('move resize', this._stopAnimation, this);\n    },\n\n    onLayerWillUnmount: function onLayerWillUnmount() {\n        L.CanvasLayer.Field.prototype.onLayerWillUnmount.call(this);\n        this._map.off('move resize', this._stopAnimation, this);\n        this._stopAnimation();\n    },\n\n    _hideCanvas: function _showCanvas() {\n        L.CanvasLayer.Field.prototype._hideCanvas.call(this);\n        this._stopAnimation();\n    },\n\n    onDrawLayer: function onDrawLayer(viewInfo) {\n        if (!this._field || !this.isVisible()) return;\n\n        this._updateOpacity();\n\n        var ctx = this._getDrawingContext();\n        var paths = this._prepareParticlePaths();\n\n        this.timer = d3.timer(function () {\n            _moveParticles();\n            _drawParticles();\n        }, this.options.duration);\n\n        var self = this;\n\n        /**\r\n         * Builds the paths, adding 'particles' on each animation step, considering\r\n         * their properties (age / position source > target)\r\n         */\n        function _moveParticles() {\n            // let screenFactor = 1 / self._map.getZoom(); // consider using a 'screenFactor' to ponderate velocityScale\n            paths.forEach(function (par) {\n                if (par.age > self.options.maxAge) {\n                    // restart, on a random x,y\n                    par.age = 0;\n                    self._field.randomPosition(par);\n                }\n\n                var vector = self._field.valueAt(par.x, par.y);\n                if (vector === null) {\n                    par.age = self.options.maxAge;\n                } else {\n                    // the next point will be...\n                    var xt = par.x + vector.u * self.options.velocityScale; //* screenFactor;\n                    var yt = par.y + vector.v * self.options.velocityScale; //* screenFactor;\n\n                    if (self._field.hasValueAt(xt, yt)) {\n                        par.xt = xt;\n                        par.yt = yt;\n                        par.m = vector.magnitude();\n                    } else {\n                        // not visible anymore...\n                        par.age = self.options.maxAge;\n                    }\n                }\n                par.age += 1;\n            });\n        }\n\n        /**\r\n         * Draws the paths on each step\r\n         */\n        function _drawParticles() {\n            // Previous paths...\n            var prev = ctx.globalCompositeOperation;\n            ctx.globalCompositeOperation = 'destination-in';\n            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n            //ctx.globalCompositeOperation = 'source-over';\n            ctx.globalCompositeOperation = prev;\n\n            // fading paths...\n            ctx.fillStyle = 'rgba(0, 0, 0, ' + self.options.fade + ')';\n            ctx.lineWidth = self.options.width;\n            ctx.strokeStyle = self.options.color;\n\n            // New paths\n            paths.forEach(function (par) {\n                self._drawParticle(viewInfo, ctx, par);\n            });\n        }\n    },\n\n    _drawParticle: function _drawParticle(viewInfo, ctx, par) {\n        var source = new L.latLng(par.y, par.x);\n        var target = new L.latLng(par.yt, par.xt);\n\n        if (viewInfo.bounds.contains(source) && par.age <= this.options.maxAge) {\n            var pA = viewInfo.layer._map.latLngToContainerPoint(source);\n            var pB = viewInfo.layer._map.latLngToContainerPoint(target);\n\n            ctx.beginPath();\n            ctx.moveTo(pA.x, pA.y);\n            ctx.lineTo(pB.x, pB.y);\n\n            // next-step movement\n            par.x = par.xt;\n            par.y = par.yt;\n\n            // colormap vs. simple color\n            var color = this.options.color;\n            if (typeof color === 'function') {\n                ctx.strokeStyle = color(par.m);\n            }\n\n            var width = this.options.width;\n            if (typeof width === 'function') {\n                ctx.lineWidth = width(par.m);\n            }\n\n            ctx.stroke();\n        }\n    },\n\n\n    _prepareParticlePaths: function _prepareParticlePaths() {\n        var paths = [];\n\n        for (var i = 0; i < this.options.paths; i++) {\n            var p = this._field.randomPosition();\n            p.age = this._randomAge();\n            paths.push(p);\n        }\n        return paths;\n    },\n\n    _randomAge: function _randomAge() {\n        return Math.floor(Math.random() * this.options.maxAge);\n    },\n\n    _stopAnimation: function _stopAnimation() {\n        if (this.timer) {\n            this.timer.stop();\n        }\n    }\n});\n\nL.canvasLayer.vectorFieldAnim = function (vectorField, options) {\n    return new L.CanvasLayer.VectorFieldAnim(vectorField, options);\n};\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n/*\r\n  1.0.1 (downloaded from https://github.com/Sumbera/gLayers.Leaflet/releases/tag/v1.0.1)\r\n\r\n  Generic  Canvas Layer for leaflet 0.7 and 1.0-rc,\r\n  copyright Stanislav Sumbera,  2016 , sumbera.com , license MIT\r\n  originally created and motivated by L.CanvasOverlay  available here: https://gist.github.com/Sumbera/11114288\r\n*/\n\nL.CanvasLayer = L.Layer.extend({\n    // -- initialized is called on prototype\n    initialize: function initialize(options) {\n        this._map = null;\n        this._canvas = null;\n        this._frame = null;\n        this._delegate = null;\n        L.setOptions(this, options);\n    },\n\n    delegate: function delegate(del) {\n        this._delegate = del;\n        return this;\n    },\n\n    needRedraw: function needRedraw() {\n        if (!this._frame) {\n            this._frame = L.Util.requestAnimFrame(this.drawLayer, this);\n        }\n        return this;\n    },\n\n    //-------------------------------------------------------------\n    _onLayerDidResize: function _onLayerDidResize(resizeEvent) {\n        this._canvas.width = resizeEvent.newSize.x;\n        this._canvas.height = resizeEvent.newSize.y;\n    },\n    //-------------------------------------------------------------\n    _onLayerDidMove: function _onLayerDidMove() {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n        this.drawLayer();\n    },\n    //-------------------------------------------------------------\n    getEvents: function getEvents() {\n        var events = {\n            resize: this._onLayerDidResize,\n            moveend: this._onLayerDidMove\n        };\n        if (this._map.options.zoomAnimation && L.Browser.any3d) {\n            events.zoomanim = this._animateZoom;\n        }\n\n        return events;\n    },\n    //-------------------------------------------------------------\n    onAdd: function onAdd(map) {\n        this._map = map;\n        this._canvas = L.DomUtil.create('canvas', 'leaflet-layer');\n        this.tiles = {};\n\n        var size = this._map.getSize();\n        this._canvas.width = size.x;\n        this._canvas.height = size.y;\n\n        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\n        L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\n\n        map._panes.overlayPane.appendChild(this._canvas);\n\n        map.on(this.getEvents(), this);\n\n        var del = this._delegate || this;\n        del.onLayerDidMount && del.onLayerDidMount(); // -- callback\n\n        this.needRedraw();\n    },\n\n    //-------------------------------------------------------------\n    onRemove: function onRemove(map) {\n        var del = this._delegate || this;\n        del.onLayerWillUnmount && del.onLayerWillUnmount(); // -- callback\n\n\n        map.getPanes().overlayPane.removeChild(this._canvas);\n\n        map.off(this.getEvents(), this);\n\n        this._canvas = null;\n    },\n\n    //------------------------------------------------------------\n    addTo: function addTo(map) {\n        map.addLayer(this);\n        return this;\n    },\n    // --------------------------------------------------------------------------------\n    LatLonToMercator: function LatLonToMercator(latlon) {\n        return {\n            x: latlon.lng * 6378137 * Math.PI / 180,\n            y: Math.log(Math.tan((90 + latlon.lat) * Math.PI / 360)) * 6378137\n        };\n    },\n\n    //------------------------------------------------------------------------------\n    drawLayer: function drawLayer() {\n        // -- todo make the viewInfo properties  flat objects.\n        var size = this._map.getSize();\n        var bounds = this._map.getBounds();\n        var zoom = this._map.getZoom();\n\n        var center = this.LatLonToMercator(this._map.getCenter());\n        var corner = this.LatLonToMercator(this._map.containerPointToLatLng(this._map.getSize()));\n\n        var del = this._delegate || this;\n        del.onDrawLayer && del.onDrawLayer({\n            layer: this,\n            canvas: this._canvas,\n            bounds: bounds,\n            size: size,\n            zoom: zoom,\n            center: center,\n            corner: corner\n        });\n        this._frame = null;\n    },\n\n    //------------------------------------------------------------------------------\n    _animateZoom: function _animateZoom(e) {\n        var scale = this._map.getZoomScale(e.zoom);\n        var offset = this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), e.zoom, e.center);\n\n        L.DomUtil.setTransform(this._canvas, offset, scale);\n    }\n});\n\nL.canvasLayer = function () {\n    return new L.CanvasLayer();\n};\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar invariant = __webpack_require__(12);\nvar getCoord = invariant.getCoord;\nvar getCoords = invariant.getCoords;\n\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can\n * be convex or concave. The function accounts for holes.\n *\n * @name inside\n * @param {Feature<Point>} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {boolean} [ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.inside(pt, poly);\n * //= true\n */\nmodule.exports = function (point, polygon, ignoreBoundary) {\n    // validation\n    if (!point) throw new Error('point is required');\n    if (!polygon) throw new Error('polygon is required');\n\n    var pt = getCoord(point);\n    var polys = getCoords(polygon);\n    var type = (polygon.geometry) ? polygon.geometry.type : polygon.type;\n    var bbox = polygon.bbox;\n\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) return false;\n\n    // normalize to multipolygon\n    if (type === 'Polygon') polys = [polys];\n\n    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) insidePoly = true;\n        }\n    }\n    return insidePoly;\n};\n\n/**\n * inRing\n *\n * @private\n * @param {[number, number]} pt [x,y]\n * @param {Array<[number, number]>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0], yi = ring[i][1];\n        var xj = ring[j][0], yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) return !ignoreBoundary;\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\n\n/**\n * inBBox\n *\n * @private\n * @param {[number, number]} pt point [x,y]\n * @param {[number, number, number, number]} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n           bbox[1] <= pt[1] &&\n           bbox[2] >= pt[0] &&\n           bbox[3] >= pt[1];\n}\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {string} GeoJSON Geometry Type\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeomType(point)\n * //=\"Point\"\n */\nfunction getGeomType(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    var geom = getGeom(geojson);\n    if (geom) return geom.type;\n}\n\nmodule.exports = {\n    geojsonType: geojsonType,\n    collectionOf: collectionOf,\n    featureOf: featureOf,\n    getCoord: getCoord,\n    getCoords: getCoords,\n    containsNumber: containsNumber,\n    getGeom: getGeom,\n    getGeomType: getGeomType\n};\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Vector_js__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Cell_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Field_js__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ScalarField_js__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__VectorField_js__ = __webpack_require__(4);\n// base\n\nwindow.L.Vector = __WEBPACK_IMPORTED_MODULE_0__Vector_js__[\"a\" /* default */];\n\n\nwindow.L.Cell = __WEBPACK_IMPORTED_MODULE_1__Cell_js__[\"a\" /* default */];\n\n\nwindow.L.Field = __WEBPACK_IMPORTED_MODULE_2__Field_js__[\"a\" /* default */];\n\n\nwindow.L.ScalarField = __WEBPACK_IMPORTED_MODULE_3__ScalarField_js__[\"a\" /* default */];\n\n\nwindow.L.VectorField = __WEBPACK_IMPORTED_MODULE_4__VectorField_js__[\"a\" /* default */];\n\n// layer\n__webpack_require__(10);\n__webpack_require__(8);\n__webpack_require__(6);\n__webpack_require__(7);\n__webpack_require__(9);\n\n// control\n__webpack_require__(5);\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// leaflet.canvaslayer.field.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 13);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ce12273210aff3d0b8d4","/**\r\n *  Simple regular cell in a raster\r\n */\r\nexport default class Cell {\r\n    /**\r\n     * A simple cell with a numerical value\r\n     * @param {L.LatLng} center\r\n     * @param {Number|Vector} value\r\n     * @param {Number} xSize\r\n     * @param {Number} ySize\r\n     */\r\n    constructor(center, value, xSize, ySize = xSize) {\r\n        this.center = center;\r\n        this.value = value;\r\n        this.xSize = xSize;\r\n        this.ySize = ySize;\r\n    }\r\n\r\n    equals(anotherCell) {\r\n        return (\r\n            this.center.equals(anotherCell.center) &&\r\n            this._equalValues(this.value, anotherCell.value) &&\r\n            this.xSize === anotherCell.xSize &&\r\n            this.ySize === anotherCell.ySize\r\n        );\r\n    }\r\n\r\n    _equalValues(value, anotherValue) {\r\n        let type = value.constructor.name;\r\n        let answerFor = {\r\n            Number: value === anotherValue,\r\n            Vector: value.u === anotherValue.u && value.v === anotherValue.v\r\n        };\r\n        return answerFor[type];\r\n    }\r\n\r\n    /**\r\n     * Bounds for the cell\r\n     * @returns {LatLngBounds}\r\n     */\r\n    getBounds() {\r\n        let halfX = this.xSize / 2.0;\r\n        let halfY = this.ySize / 2.0;\r\n        let cLat = this.center.lat;\r\n        let cLng = this.center.lng;\r\n        let ul = L.latLng([cLat + halfY, cLng - halfX]);\r\n        let lr = L.latLng([cLat - halfY, cLng + halfX]);\r\n\r\n        return L.latLngBounds(\r\n            L.latLng(lr.lat, ul.lng),\r\n            L.latLng(ul.lat, lr.lng)\r\n        );\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./Cell.js","import Cell from './Cell';\r\nimport inside from '@turf/inside';\r\n\r\n/**\r\n *  Abstract class for a set of values (Vector | Scalar)\r\n *  assigned to a regular 2D-grid (lon-lat), aka 'a Raster source'\r\n */\r\nexport default class Field {\r\n    constructor(params) {\r\n        this.params = params;\r\n\r\n        this.nCols = params['nCols'];\r\n        this.nRows = params['nRows'];\r\n\r\n        // alias\r\n        this.width = params['nCols'];\r\n        this.height = params['nRows'];\r\n\r\n        // ll = lower-left\r\n        this.xllCorner = params['xllCorner'];\r\n        this.yllCorner = params['yllCorner'];\r\n\r\n        // ur = upper-right\r\n        this.xurCorner =\r\n            params['xllCorner'] + params['nCols'] * params['cellXSize'];\r\n        this.yurCorner =\r\n            params['yllCorner'] + params['nRows'] * params['cellYSize'];\r\n\r\n        this.cellXSize = params['cellXSize'];\r\n        this.cellYSize = params['cellYSize'];\r\n\r\n        this.grid = null; // to be defined by subclasses\r\n        this.isContinuous = this.xurCorner - this.xllCorner >= 360;\r\n        this.longitudeNeedsToBeWrapped = this.xurCorner > 180; // [0, 360] --> [-180, 180]\r\n\r\n        this._inFilter = null;\r\n        this._spatialMask = null;\r\n    }\r\n\r\n    /**\r\n     * Builds a grid with a value at each point (either Vector or Number)\r\n     * Original params must include the required input values, following\r\n     * x-ascending & y-descending order (same as in ASCIIGrid)\r\n     * @abstract\r\n     * @private\r\n     * @returns {Array.<Array.<Vector|Number>>} - grid[row][column]--> Vector|Number\r\n     */\r\n    _buildGrid() {\r\n        throw new TypeError('Must be overriden');\r\n    }\r\n\r\n    _updateRange() {\r\n        this.range = this._calculateRange();\r\n    }\r\n\r\n    /**\r\n     * Number of cells in the grid (rows * cols)\r\n     * @returns {Number}\r\n     */\r\n    numCells() {\r\n        return this.nRows * this.nCols;\r\n    }\r\n\r\n    /**\r\n     * A list with every cell\r\n     * @returns {Array<Cell>} - cells (x-ascending & y-descending order)\r\n     */\r\n    getCells(stride = 1) {\r\n        let cells = [];\r\n        for (let j = 0; j < this.nRows; j = j + stride) {\r\n            for (let i = 0; i < this.nCols; i = i + stride) {\r\n                let [lon, lat] = this._lonLatAtIndexes(i, j);\r\n                let center = L.latLng(lat, lon);\r\n                let value = this._valueAtIndexes(i, j);\r\n                let c = new Cell(center, value, this.cellXSize, this.cellYSize);\r\n                cells.push(c); // <<\r\n            }\r\n        }\r\n        return cells;\r\n    }\r\n\r\n    /**\r\n     * Apply a filter function to field values\r\n     * @param   {Function} f - boolean function\r\n     */\r\n    setFilter(f) {\r\n        this._inFilter = f;\r\n        this._updateRange();\r\n    }\r\n\r\n    /**\r\n     * Apply a spatial mask to field values\r\n     * @param {L.GeoJSON} m \r\n     */\r\n    setSpatialMask(m) {\r\n        this._spatialMask = m;\r\n    }\r\n\r\n    /**\r\n     * Grid extent\r\n     * @returns {Number[]} [xmin, ymin, xmax, ymax]\r\n     */\r\n    extent() {\r\n        let [xmin, xmax] = this._getWrappedLongitudes();\r\n        return [xmin, this.yllCorner, xmax, this.yurCorner];\r\n    }\r\n\r\n    /**\r\n     * [xmin, xmax] in [-180, 180] range\r\n     */\r\n    _getWrappedLongitudes() {\r\n        let xmin = this.xllCorner;\r\n        let xmax = this.xurCorner;\r\n\r\n        if (this.longitudeNeedsToBeWrapped) {\r\n            if (this.isContinuous) {\r\n                xmin = -180;\r\n                xmax = 180;\r\n            } else {\r\n                // not sure about this (just one particular case, but others...?)\r\n                xmax = this.xurCorner - 360;\r\n                xmin = this.xllCorner - 360;\r\n                /* eslint-disable no-console */\r\n                // console.warn(`are these xmin: ${xmin} & xmax: ${xmax} OK?`);\r\n                // TODO: Better throw an exception on no-controlled situations.\r\n                /* eslint-enable no-console */\r\n            }\r\n        }\r\n        return [xmin, xmax];\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the grid contains the point, considering\r\n     * the spatialMask if it has been previously set\r\n     * @param   {Number} lon - longitude\r\n     * @param   {Number} lat - latitude\r\n     * @returns {Boolean}\r\n     */\r\n    contains(lon, lat) {\r\n        if (this._spatialMask) {\r\n            return this._pointInMask(lon, lat);\r\n        }\r\n        return this._pointInExtent(lon, lat);\r\n    }\r\n\r\n    /**\r\n     * Checks if coordinates are inside the Extent (considering wrapped longitudes if needed)\r\n     * @param {Number} lon \r\n     * @param {Number} lat \r\n     */\r\n    _pointInExtent(lon, lat) {\r\n        let [xmin, xmax] = this._getWrappedLongitudes();\r\n        let longitudeIn = lon >= xmin && lon <= xmax;\r\n        let latitudeIn = lat >= this.yllCorner && lat <= this.yurCorner;\r\n        return longitudeIn && latitudeIn;\r\n    }\r\n\r\n    /**\r\n     * Check if coordinates are inside the spatialMask (Point in Polygon analysis)\r\n     * @param {Number} lon \r\n     * @param {Number} lat \r\n     */\r\n    _pointInMask(lon, lat) {\r\n        const pt = {\r\n            type: 'Feature',\r\n            geometry: {\r\n                type: 'Point',\r\n                coordinates: [lon, lat] // geojson, lon-lat order !\r\n            },\r\n            properties: {}\r\n        };\r\n        const poly = this._spatialMask;\r\n        return inside(pt, poly);\r\n    }\r\n\r\n    /**\r\n     * Returns if the grid doesn't contain the point\r\n     * @param   {Number} lon - longitude\r\n     * @param   {Number} lat - latitude\r\n     * @returns {Boolean}\r\n     */\r\n    notContains(lon, lat) {\r\n        return !this.contains(lon, lat);\r\n    }\r\n\r\n    /**\r\n     * Interpolated value at lon-lat coordinates (bilinear method)\r\n     * @param   {Number} longitude\r\n     * @param   {Number} latitude\r\n     * @returns {Vector|Number} [u, v, magnitude]\r\n     *                          \r\n     * Source: https://github.com/cambecc/earth > product.js\r\n     */\r\n    interpolatedValueAt(lon, lat) {\r\n        if (this.notContains(lon, lat)) return null;\r\n\r\n        let [i, j] = this._getDecimalIndexes(lon, lat);\r\n        return this.interpolatedValueAtIndexes(i, j);\r\n    }\r\n\r\n    /**\r\n     * Interpolated value at i-j indexes (bilinear method)\r\n     * @param   {Number} i\r\n     * @param   {Number} j\r\n     * @returns {Vector|Number} [u, v, magnitude]\r\n     *\r\n     * Source: https://github.com/cambecc/earth > product.js\r\n     */\r\n    interpolatedValueAtIndexes(i, j) {\r\n        //         1      2           After converting  and  to fractional grid indexes i and j, we find the\r\n        //        fi  i   ci          four points 'G' that enclose point (i, j). These points are at the four\r\n        //         | =1.4 |           corners specified by the floor and ceiling of i and j. For example, given\r\n        //      ---G--|---G--- fj 8   i = 1.4 and j = 8.3, the four surrounding grid points are (1, 8), (2, 8),\r\n        //    j ___|_ .   |           (1, 9) and (2, 9).\r\n        //  =8.3   |      |\r\n        //      ---G------G--- cj 9   Note that for wrapped grids, the first column is duplicated as the last\r\n        //         |      |           column, so the index ci can be used without taking a modulo.\r\n\r\n        let indexes = this._getFourSurroundingIndexes(i, j);\r\n        let [fi, ci, fj, cj] = indexes;\r\n        let values = this._getFourSurroundingValues(fi, ci, fj, cj);\r\n        if (values) {\r\n            let [g00, g10, g01, g11] = values;\r\n            return this._doInterpolation(i - fi, j - fj, g00, g10, g01, g11);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get decimal indexes\r\n     * @private\r\n     * @param {Number} lon\r\n     * @param {Number} lat\r\n     * @returns {Array}    [[Description]]\r\n     */\r\n    _getDecimalIndexes(lon, lat) {\r\n        if (this.longitudeNeedsToBeWrapped && lon < this.xllCorner) {\r\n            lon = lon + 360;\r\n        }\r\n        let i = (lon - this.xllCorner) / this.cellXSize;\r\n        let j = (this.yurCorner - lat) / this.cellYSize;\r\n        return [i, j];\r\n    }\r\n\r\n    /**\r\n     * Get surrounding indexes (integer), clampling on borders\r\n     * @private\r\n     * @param   {Number} i - decimal index\r\n     * @param   {Number} j - decimal index\r\n     * @returns {Array} [fi, ci, fj, cj]\r\n     */\r\n    _getFourSurroundingIndexes(i, j) {\r\n        let fi = Math.floor(i);\r\n        let ci = fi + 1;\r\n        // duplicate colum to simplify interpolation logic (wrapped value)\r\n        if (this.isContinuous && ci >= this.nCols) {\r\n            ci = 0;\r\n        }\r\n        ci = this._clampColumnIndex(ci);\r\n\r\n        let fj = this._clampRowIndex(Math.floor(j));\r\n        let cj = this._clampRowIndex(fj + 1);\r\n\r\n        return [fi, ci, fj, cj];\r\n    }\r\n\r\n    /**\r\n     * Get four surrounding values or null if not available,\r\n     * from 4 integer indexes\r\n     * @private\r\n     * @param   {Number} fi\r\n     * @param   {Number} ci\r\n     * @param   {Number} fj\r\n     * @param   {Number} cj\r\n     * @returns {Array} \r\n     */\r\n    _getFourSurroundingValues(fi, ci, fj, cj) {\r\n        var row;\r\n        if ((row = this.grid[fj])) {\r\n            // upper row ^^\r\n            var g00 = row[fi]; // << left\r\n            var g10 = row[ci]; // right >>\r\n            if (\r\n                this._isValid(g00) &&\r\n                this._isValid(g10) &&\r\n                (row = this.grid[cj])\r\n            ) {\r\n                // lower row vv\r\n                var g01 = row[fi]; // << left\r\n                var g11 = row[ci]; // right >>\r\n                if (this._isValid(g01) && this._isValid(g11)) {\r\n                    return [g00, g10, g01, g11]; // 4 values found!\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Nearest value at lon-lat coordinates\r\n     * @param   {Number} longitude\r\n     * @param   {Number} latitude\r\n     * @returns {Vector|Number}\r\n     */\r\n    valueAt(lon, lat) {\r\n        if (this.notContains(lon, lat)) return null;\r\n\r\n        let [i, j] = this._getDecimalIndexes(lon, lat);\r\n        let ii = Math.floor(i);\r\n        let jj = Math.floor(j);\r\n\r\n        const ci = this._clampColumnIndex(ii);\r\n        const cj = this._clampRowIndex(jj);\r\n\r\n        let value = this._valueAtIndexes(ci, cj);\r\n        if (this._inFilter) {\r\n            if (!this._inFilter(value)) return null;\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the field has a value at the point\r\n     * @param   {Number} lon - longitude\r\n     * @param   {Number} lat - latitude\r\n     * @returns {Boolean}\r\n     */\r\n    hasValueAt(lon, lat) {\r\n        let value = this.valueAt(lon, lat);\r\n        let hasValue = value !== null;\r\n\r\n        let included = true;\r\n        if (this._inFilter) {\r\n            included = this._inFilter(value);\r\n        }\r\n        return hasValue && included;\r\n    }\r\n\r\n    /**\r\n     * Returns if the grid has no value at the point\r\n     * @param   {Number} lon - longitude\r\n     * @param   {Number} lat - latitude\r\n     * @returns {Boolean}\r\n     */\r\n    notHasValueAt(lon, lat) {\r\n        return !this.hasValueAt(lon, lat);\r\n    }\r\n\r\n    /**\r\n     * Gives a random position to 'o' inside the grid\r\n     * @param {Object} [o] - an object (eg. a particle)\r\n     * @returns {{x: Number, y: Number}} - object with x, y (lon, lat)\r\n     */\r\n    randomPosition(o = {}) {\r\n        let i = (Math.random() * this.nCols) | 0;\r\n        let j = (Math.random() * this.nRows) | 0;\r\n\r\n        o.x = this._longitudeAtX(i);\r\n        o.y = this._latitudeAtY(j);\r\n\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Value for grid indexes\r\n     * @param   {Number} i - column index (integer)\r\n     * @param   {Number} j - row index (integer)\r\n     * @returns {Vector|Number}\r\n     */\r\n    _valueAtIndexes(i, j) {\r\n        return this.grid[j][i]; // <-- j,i !!\r\n    }\r\n\r\n    /**\r\n     * Lon-Lat for grid indexes\r\n     * @param   {Number} i - column index (integer)\r\n     * @param   {Number} j - row index (integer)\r\n     * @returns {Number[]} [lon, lat]\r\n     */\r\n    _lonLatAtIndexes(i, j) {\r\n        let lon = this._longitudeAtX(i);\r\n        let lat = this._latitudeAtY(j);\r\n\r\n        return [lon, lat];\r\n    }\r\n\r\n    /**\r\n     * Longitude for grid-index\r\n     * @param   {Number} i - column index (integer)\r\n     * @returns {Number} longitude at the center of the cell\r\n     */\r\n    _longitudeAtX(i) {\r\n        let halfXPixel = this.cellXSize / 2.0;\r\n        let lon = this.xllCorner + halfXPixel + i * this.cellXSize;\r\n        if (this.longitudeNeedsToBeWrapped) {\r\n            lon = lon > 180 ? lon - 360 : lon;\r\n        }\r\n        return lon;\r\n    }\r\n\r\n    /**\r\n     * Latitude for grid-index\r\n     * @param   {Number} j - row index (integer)\r\n     * @returns {Number} latitude at the center of the cell\r\n     */\r\n    _latitudeAtY(j) {\r\n        let halfYPixel = this.cellYSize / 2.0;\r\n        return this.yurCorner - halfYPixel - j * this.cellYSize;\r\n    }\r\n\r\n    /**\r\n     * Apply the interpolation\r\n     * @abstract\r\n     * @private\r\n     */\r\n    /* eslint-disable no-unused-vars */\r\n    _doInterpolation(x, y, g00, g10, g01, g11) {\r\n        throw new TypeError('Must be overriden');\r\n    }\r\n    /* eslint-disable no-unused-vars */\r\n\r\n    /**\r\n     * Check the column index is inside the field,\r\n     * adjusting to min or max when needed\r\n     * @private\r\n     * @param   {Number} ii - index\r\n     * @returns {Number} i - inside the allowed indexes\r\n     */\r\n    _clampColumnIndex(ii) {\r\n        let i = ii;\r\n        if (ii < 0) {\r\n            i = 0;\r\n        }\r\n        let maxCol = this.nCols - 1;\r\n        if (ii > maxCol) {\r\n            i = maxCol;\r\n        }\r\n        return i;\r\n    }\r\n\r\n    /**\r\n     * Check the row index is inside the field,\r\n     * adjusting to min or max when needed\r\n     * @private\r\n     * @param   {Number} jj index\r\n     * @returns {Number} j - inside the allowed indexes\r\n     */\r\n    _clampRowIndex(jj) {\r\n        let j = jj;\r\n        if (jj < 0) {\r\n            j = 0;\r\n        }\r\n        let maxRow = this.nRows - 1;\r\n        if (jj > maxRow) {\r\n            j = maxRow;\r\n        }\r\n        return j;\r\n    }\r\n\r\n    /**\r\n     * Is valid (not 'null' nor 'undefined')\r\n     * @private\r\n     * @param   {Object} x object\r\n     * @returns {Boolean}\r\n     */\r\n    _isValid(x) {\r\n        return x !== null && x !== undefined;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./Field.js","import Field from './Field';\r\n\r\n/**\r\n * Scalar Field\r\n */\r\nexport default class ScalarField extends Field {\r\n    /**\r\n     * Creates a ScalarField from the content of an ASCIIGrid file\r\n     * @param   {String}   asc\r\n     * @returns {ScalarField}\r\n     */\r\n    static fromASCIIGrid(asc, scaleFactor = 1) {\r\n        //console.time('ScalarField from ASC');\r\n\r\n        let lines = asc.split('\\n');\r\n\r\n        // Header\r\n        var header = ScalarField._parseASCIIGridHeader(lines.slice(0, 6));\r\n\r\n        // Data (left-right and top-down)\r\n        let zs = [];\r\n        for (let i = 6; i < lines.length; i++) {\r\n            let line = lines[i].trim();\r\n            if (line === '') break;\r\n\r\n            let items = line.split(' ');\r\n            items.forEach(it => {\r\n                let floatItem = parseFloat(it);\r\n                let v =\r\n                    floatItem !== header.noDataValue ?\r\n                    floatItem * scaleFactor :\r\n                    null;\r\n                zs.push(v);\r\n            });\r\n        }\r\n        let p = header;\r\n        p.zs = zs;\r\n\r\n        //console.timeEnd('ScalarField from ASC');\r\n        return new ScalarField(p);\r\n    }\r\n\r\n    /**\r\n     * Parse an ASCII Grid header, made with 6 lines\r\n     * It allows the use of XLLCORNER/YLLCORNER or XLLCENTER/YLLCENTER conventions\r\n     * @param {Array.String} headerLines\r\n     */\r\n    static _parseASCIIGridHeader(headerLines) {\r\n        try {\r\n            const headerItems = headerLines.map(line => {\r\n                var items = line.split(' ').filter(i => i != '');\r\n                var param = items[0].trim().toUpperCase();\r\n                var value = parseFloat(items[1].trim());\r\n                return {\r\n                    [param]: value\r\n                };\r\n            });\r\n\r\n            const usesCorner = 'XLLCORNER' in headerItems[2];\r\n            const cellSize = headerItems[4]['CELLSIZE'];\r\n\r\n            const header = {\r\n                nCols: parseInt(headerItems[0]['NCOLS']),\r\n                nRows: parseInt(headerItems[1]['NROWS']),\r\n                xllCorner: usesCorner ?\r\n                    headerItems[2]['XLLCORNER'] :\r\n                    headerItems[2]['XLLCENTER'] - cellSize / 2,\r\n                yllCorner: usesCorner ?\r\n                    headerItems[3]['YLLCORNER'] :\r\n                    headerItems[3]['YLLCENTER'] - cellSize / 2,\r\n                cellXSize: cellSize,\r\n                cellYSize: cellSize,\r\n                noDataValue: headerItems[5]['NODATA_VALUE']\r\n            };\r\n            return header;\r\n        } catch (err) {\r\n            throw new Error(`Not a valid ASCIIGrid Header: ${err}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a ScalarField from the content of a GeoTIFF file\r\n     * @param   {ArrayBuffer}   data\r\n     * @param   {Number}   bandIndex\r\n     * @returns {ScalarField}\r\n     */\r\n    static fromGeoTIFF(data, bandIndex = 0) {\r\n        return ScalarField.multipleFromGeoTIFF(data, [bandIndex])[0];\r\n    }\r\n\r\n    /**\r\n     * Creates a ScalarField array (one per band) from the content of a GeoTIFF file\r\n     * @param   {ArrayBuffer}   data\r\n     * @param   {Array}   bandIndexes - if not provided all bands are returned\r\n     * @returns {Array.<ScalarField>}\r\n     */\r\n    static multipleFromGeoTIFF(data, bandIndexes) {\r\n        //console.time('ScalarField from GeoTIFF');\r\n\r\n        let tiff = GeoTIFF.parse(data); // geotiff.js\r\n        let image = tiff.getImage();\r\n        let rasters = image.readRasters();\r\n        let tiepoint = image.getTiePoints()[0];\r\n        let fileDirectory = image.getFileDirectory();\r\n        let [xScale, yScale] = fileDirectory.ModelPixelScale;\r\n\r\n        if (typeof bandIndexes === 'undefined' || bandIndexes.length === 0) {\r\n            bandIndexes = [...Array(rasters.length).keys()];\r\n        }\r\n\r\n        let scalarFields = [];\r\n        scalarFields = bandIndexes.map(function (bandIndex) {\r\n            let zs = rasters[bandIndex]; // left-right and top-down order\r\n\r\n            if (fileDirectory.GDAL_NODATA) {\r\n                let noData = parseFloat(fileDirectory.GDAL_NODATA);\r\n                // console.log(noData);\r\n                let simpleZS = Array.from(zs); // to simple array, so null is allowed | TODO efficiency??\r\n                zs = simpleZS.map(function (z) {\r\n                    return z === noData ? null : z;\r\n                });\r\n            }\r\n\r\n            let p = {\r\n                nCols: image.getWidth(),\r\n                nRows: image.getHeight(),\r\n                xllCorner: tiepoint.x,\r\n                yllCorner: tiepoint.y - image.getHeight() * yScale,\r\n                cellXSize: xScale,\r\n                cellYSize: yScale,\r\n                zs: zs\r\n            };\r\n            return new ScalarField(p);\r\n        });\r\n\r\n        //console.timeEnd('ScalarField from GeoTIFF');\r\n        return scalarFields;\r\n    }\r\n\r\n    constructor(params) {\r\n        super(params);\r\n        this.zs = params['zs'];\r\n\r\n        this.grid = this._buildGrid();\r\n        this._updateRange();\r\n        //console.log(`ScalarField created (${this.nCols} x ${this.nRows})`);\r\n    }\r\n\r\n    /**\r\n     * Builds a grid with a Number at each point, from an array\r\n     * 'zs' following x-ascending & y-descending order\r\n     * (same as in ASCIIGrid)\r\n     * @private\r\n     * @returns {Array.<Array.<Number>>} - grid[row][column]--> Number\r\n     */\r\n    _buildGrid() {\r\n        let grid = this._arrayTo2d(this.zs, this.nRows, this.nCols);\r\n        return grid;\r\n    }\r\n\r\n    _arrayTo2d(array, nRows, nCols) {\r\n        let grid = [];\r\n        let p = 0;\r\n        for (var j = 0; j < nRows; j++) {\r\n            var row = [];\r\n            for (var i = 0; i < nCols; i++, p++) {\r\n                let z = array[p];\r\n                row[i] = this._isValid(z) ? z : null; // <<<\r\n            }\r\n            grid[j] = row;\r\n        }\r\n        return grid;\r\n    }\r\n\r\n    _newDataArrays(params) {\r\n        params['zs'] = [];\r\n    }\r\n\r\n    _pushValueToArrays(params, value) {\r\n        params['zs'].push(value);\r\n    }\r\n\r\n    _makeNewFrom(params) {\r\n        return new ScalarField(params);\r\n    }\r\n\r\n    /**\r\n     * Calculate min & max values\r\n     * @private\r\n     * @returns {Array} - [min, max]\r\n     */\r\n    _calculateRange() {\r\n        var data = this.zs;\r\n        if (this._inFilter) {\r\n            data = data.filter(this._inFilter);\r\n        }\r\n        return [d3.min(data), d3.max(data)];\r\n    }\r\n\r\n    /**\r\n     * Bilinear interpolation for Number\r\n     * https://en.wikipedia.org/wiki/Bilinear_interpolation\r\n     * @param   {Number} x\r\n     * @param   {Number} y\r\n     * @param   {Number} g00\r\n     * @param   {Number} g10\r\n     * @param   {Number} g01\r\n     * @param   {Number} g11\r\n     * @returns {Number}\r\n     */\r\n    _doInterpolation(x, y, g00, g10, g01, g11) {\r\n        var rx = 1 - x;\r\n        var ry = 1 - y;\r\n        return g00 * rx * ry + g10 * x * ry + g01 * rx * y + g11 * x * y;\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./ScalarField.js","/**\r\n *  2D Vector\r\n */\r\nexport default class Vector {\r\n\r\n    constructor(u, v) {\r\n        this.u = u;\r\n        this.v = v;\r\n    }\r\n\r\n    /**\r\n     * Magnitude\r\n     * @returns {Number}\r\n     */\r\n    magnitude() {\r\n        return Math.sqrt(this.u * this.u + this.v * this.v);\r\n    }\r\n\r\n    /**\r\n     * Angle in degrees (0 to 360) --> Towards\r\n     * N is 0 and E is 90\r\n     * @returns {Number}\r\n     */\r\n    directionTo() {\r\n        let verticalAngle = Math.atan2(this.u, this.v);\r\n        let inDegrees = verticalAngle * (180.0 / Math.PI);\r\n        if (inDegrees < 0) {\r\n            inDegrees = inDegrees + 360.0;\r\n        }\r\n        return inDegrees;\r\n    }\r\n\r\n    /**\r\n     * Angle in degrees (0 to 360) From x-->\r\n     * N is 0 and E is 90\r\n     * @returns {Number}\r\n     */\r\n    directionFrom() {\r\n        let a = this.directionTo();\r\n        let opposite = (a + 180.0) % 360.0;\r\n        return opposite;\r\n    }\r\n\r\n    /*\r\n        Degrees --> text\r\n        new Dictionary<int, string>\r\n        {\r\n            //{0, 23, 45, 68, 90, 113, 135, 158, 180, 203, 225, 248, 270, 293, 315, 338, 360};\r\n            {0, 'N'},\r\n            {23, 'NNE'},\r\n            {45, 'NE'},\r\n            {68, 'ENE'},\r\n            {90, 'E'},\r\n            {113, 'ESE'},\r\n            {135, 'SE'},\r\n            {158, 'SSE'},\r\n            {180, 'S'},\r\n            {203, 'SSW'},\r\n            {225, 'SW'},\r\n            {248, 'WSW'},\r\n            {270, 'W'},\r\n            {293, 'WNW'},\r\n            {315, 'NW'},\r\n            {338, 'NNW'},\r\n            {360, 'N'}\r\n        };\r\n    */\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./Vector.js","import Vector from './Vector';\r\nimport Field from './Field';\r\nimport ScalarField from './ScalarField';\r\n\r\n/**\r\n *  A set of vectors assigned to a regular 2D-grid (lon-lat)\r\n *  (e.g. a raster representing winds for a region)\r\n */\r\nexport default class VectorField extends Field {\r\n    /**\r\n     * Creates a VectorField from the content of two ASCIIGrid files\r\n     * @param   {String} ascU - with u-component\r\n     * @param   {String} ascV - with v-component\r\n     * @returns {VectorField}\r\n     */\r\n    static fromASCIIGrids(ascU, ascV, scaleFactor = 1) {\r\n        let u = ScalarField.fromASCIIGrid(ascU, scaleFactor);\r\n        let v = ScalarField.fromASCIIGrid(ascV, scaleFactor);\r\n        let p = VectorField._paramsFromScalarFields(u, v);\r\n\r\n        return new VectorField(p);\r\n    }\r\n\r\n    /**\r\n     * Creates a VectorField from the content of two different Geotiff files\r\n     * @param   {ArrayBuffer} gtU - geotiff data with u-component (band 0)\r\n     * @param   {ArrayBuffer} gtV - geotiff data with v-component (band 0)\r\n     * @returns {VectorField}\r\n     */\r\n    static fromGeoTIFFs(gtU, gtV) {\r\n        let u = ScalarField.fromGeoTIFF(gtU);\r\n        let v = ScalarField.fromGeoTIFF(gtV);\r\n        let p = VectorField._paramsFromScalarFields(u, v);\r\n\r\n        return new VectorField(p);\r\n    }\r\n\r\n    /**\r\n     * Creates a VectorField from the content of Multiband Geotiff\r\n     * @param   {ArrayBuffer} geotiffData - multiband\r\n     * @param   {Array} bandIndexesForUV\r\n     * @returns {VectorField}\r\n     */\r\n    static fromMultibandGeoTIFF(geotiffData, bandIndexesForUV = [0, 1]) {\r\n        let [u, v] = ScalarField.multipleFromGeoTIFF(\r\n            geotiffData,\r\n            bandIndexesForUV\r\n        );\r\n        let p = VectorField._paramsFromScalarFields(u, v);\r\n\r\n        return new VectorField(p);\r\n    }\r\n\r\n    /**\r\n     * Build parameters for VectorField, from 2 ScalarFields.\r\n     * No validation at all (nor interpolation) is applied, so u and v\r\n     * must be 'compatible' from the source\r\n     * @param   {ScalarField} u\r\n     * @param   {ScalarField} v\r\n     * @returns {Object} - parameters to build VectorField\r\n     */\r\n    static _paramsFromScalarFields(u, v) {\r\n        // TODO check u & v compatibility (cellSize...)\r\n        let p = {\r\n            nCols: u.nCols,\r\n            nRows: u.nRows,\r\n            xllCorner: u.xllCorner,\r\n            yllCorner: u.yllCorner,\r\n            cellXSize: u.cellXSize,\r\n            cellYSize: u.cellYSize,\r\n            us: u.zs,\r\n            vs: v.zs\r\n        };\r\n        return p;\r\n    }\r\n\r\n    constructor(params) {\r\n        super(params);\r\n\r\n        this.us = params['us'];\r\n        this.vs = params['vs'];\r\n        this.grid = this._buildGrid();\r\n        this.range = this._calculateRange();\r\n    }\r\n\r\n    /**\r\n     * Get a derived field, from a computation on\r\n     * the VectorField\r\n     * @param   {String} type ['magnitude' | 'directionTo' | 'directionFrom']\r\n     * @returns {ScalarField}\r\n     */\r\n    getScalarField(type) {\r\n        let f = this._getFunctionFor(type);\r\n        let p = {\r\n            nCols: this.params.nCols,\r\n            nRows: this.params.nRows,\r\n            xllCorner: this.params.xllCorner,\r\n            yllCorner: this.params.yllCorner,\r\n            cellXSize: this.params.cellXSize,\r\n            cellYSize: this.params.cellYSize,\r\n            zs: this._applyOnField(f)\r\n        };\r\n        return new ScalarField(p);\r\n    }\r\n\r\n    _getFunctionFor(type) {\r\n        return function(u, v) {\r\n            let uv = new Vector(u, v);\r\n            return uv[type](); // magnitude, directionTo, directionFrom\r\n        };\r\n    }\r\n\r\n    _applyOnField(func) {\r\n        let zs = [];\r\n        let n = this.numCells();\r\n        for (var i = 0; i < n; i++) {\r\n            let u = this.us[i];\r\n            let v = this.vs[i];\r\n            if (this._isValid(u) && this._isValid(v)) {\r\n                zs.push(func(u, v));\r\n            } else {\r\n                zs.push(null);\r\n            }\r\n        }\r\n        return zs;\r\n    }\r\n\r\n    /**\r\n     * Builds a grid with a Vector at each point, from two arrays\r\n     * 'us' and 'vs' following x-ascending & y-descending order\r\n     * (same as in ASCIIGrid)\r\n     * @returns {Array.<Array.<Vector>>} - grid[row][column]--> Vector\r\n     */\r\n    _buildGrid() {\r\n        let grid = this._arraysTo2d(this.us, this.vs, this.nRows, this.nCols);\r\n        return grid;\r\n    }\r\n\r\n    _arraysTo2d(us, vs, nRows, nCols) {\r\n        let grid = [];\r\n        let p = 0;\r\n\r\n        for (var j = 0; j < nRows; j++) {\r\n            var row = [];\r\n            for (var i = 0; i < nCols; i++, p++) {\r\n                let u = us[p],\r\n                    v = vs[p];\r\n                let valid = this._isValid(u) && this._isValid(v);\r\n                row[i] = valid ? new Vector(u, v) : null; // <<<\r\n            }\r\n            grid[j] = row;\r\n        }\r\n        return grid;\r\n    }\r\n\r\n    _newDataArrays(params) {\r\n        params['us'] = [];\r\n        params['vs'] = [];\r\n    }\r\n    _pushValueToArrays(params, value) {\r\n        //console.log(value);\r\n        params['us'].push(value.u);\r\n        params['vs'].push(value.v);\r\n    }\r\n    _makeNewFrom(params) {\r\n        return new VectorField(params);\r\n    }\r\n\r\n    /**\r\n     * Calculate min & max values (magnitude)\r\n     * @private\r\n     * @returns {Array}\r\n     */\r\n    _calculateRange() {\r\n        // TODO make a clearer method for getting these vectors...\r\n        let vectors = this.getCells()\r\n            .map(pt => pt.value)\r\n            .filter(function(v) {\r\n                return v !== null;\r\n            });\r\n\r\n        if (this._inFilter) {\r\n            vectors = vectors.filter(this._inFilter);\r\n        }\r\n\r\n        // TODO check memory crash with high num of vectors!\r\n        let magnitudes = vectors.map(v => v.magnitude());\r\n        let min = d3.min(magnitudes);\r\n        let max = d3.max(magnitudes);\r\n\r\n        return [min, max];\r\n    }\r\n\r\n    /**\r\n     * Bilinear interpolation for Vector\r\n     * https://en.wikipedia.org/wiki/Bilinear_interpolation\r\n     * @param   {Number} x\r\n     * @param   {Number} y\r\n     * @param   {Number[]} g00\r\n     * @param   {Number[]} g10\r\n     * @param   {Number[]} g01\r\n     * @param   {Number[]} g11\r\n     * @returns {Vector}\r\n     */\r\n    _doInterpolation(x, y, g00, g10, g01, g11) {\r\n        var rx = 1 - x;\r\n        var ry = 1 - y;\r\n        var a = rx * ry,\r\n            b = x * ry,\r\n            c = rx * y,\r\n            d = x * y;\r\n        var u = g00.u * a + g10.u * b + g01.u * c + g11.u * d;\r\n        var v = g00.v * a + g10.v * b + g01.v * c + g11.v * d;\r\n        return new Vector(u, v);\r\n    }\r\n\r\n    /**\r\n     * Is valid (not 'null' nor 'undefined')\r\n     * @private\r\n     * @param   {Object} x object\r\n     * @returns {Boolean}\r\n     */\r\n    _isValid(x) {\r\n        return x !== null && x !== undefined;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./VectorField.js","/**\r\n *   Control for a simple legend with a colorbar\r\n *   References:\r\n *      - http://jsfiddle.net/ramnathv/g8stqcf6/\r\n *      - http://jsfiddle.net/vis4/cYLZH/\r\n */\r\nL.Control.ColorBar = L.Control.extend({\r\n    options: {\r\n        position: 'bottomleft',\r\n        width: 300, // for colorbar itself (control is wider)\r\n        height: 15,\r\n        margin: 15,\r\n        background: '#fff',\r\n        textColor: 'black',\r\n        steps: 100,\r\n        decimals: 2,\r\n        units: 'uds', // ej: m/s\r\n        title: 'Legend', // ej: Ocean Currents\r\n        labels: [], // empty for no labels\r\n        textLabels: [], // empty for default labels. Custom labels ej: ['low', 'mid','high'] \r\n        labelFontSize: 10,\r\n        labelTextPosition: 'middle' // start | middle | end\r\n    },\r\n\r\n    initialize: function (color, range, options) {\r\n        this.color = color; // 'chromajs' scale function\r\n        this.range = range; // [min, max]\r\n        L.Util.setOptions(this, options);\r\n    },\r\n\r\n    onAdd: function (map) {\r\n        this._map = map;\r\n        let div = L.DomUtil.create(\r\n            'div',\r\n            'leaflet-control-colorBar leaflet-bar leaflet-control'\r\n        );\r\n        div.style.padding = '10px';\r\n\r\n        L.DomEvent\r\n            .addListener(div, 'click', L.DomEvent.stopPropagation)\r\n            .addListener(div, 'click', L.DomEvent.preventDefault);\r\n        div.style.backgroundColor = this.options.background;\r\n        div.style.cursor = 'text';\r\n        div.innerHTML = this.title() + this.palette();\r\n        return div;\r\n    },\r\n\r\n    title: function () {\r\n        let d = document.createElement('div');\r\n        d3\r\n            .select(d)\r\n            .append('span')\r\n            .style('color', this.options.textColor)\r\n            .style('display', 'block')\r\n            .style('margin-bottom', '5px')\r\n            .attr('class', 'leaflet-control-colorBar-title')\r\n            .text(this.options.title);\r\n        return d.innerHTML;\r\n    },\r\n\r\n    palette: function () {\r\n        let d = document.createElement('div');\r\n        let svg = this._createSvgIn(d);\r\n\r\n        this._appendColorBarTo(svg);\r\n\r\n        if (this.options.labels) {\r\n            this._appendLabelsTo(svg);\r\n        }\r\n\r\n        return d.innerHTML;\r\n    },\r\n\r\n    _createSvgIn: function (d) {\r\n        let spaceForLabels = this.options.labels ? this.options.margin : 0;\r\n        let svg = d3\r\n            .select(d)\r\n            .append('svg')\r\n            .attr('width', this.options.width + this.options.margin * 2)\r\n            .attr('height', this.options.height + spaceForLabels);\r\n        return svg;\r\n    },\r\n\r\n    _appendColorBarTo: function (svg) {\r\n        const colorPerValue = this._getColorPerValue();\r\n        const w = this.options.width / colorPerValue.length;\r\n\r\n        let groupBars = svg.append('g').attr('id', 'colorBar-buckets');\r\n        let buckets = groupBars\r\n            .selectAll('rect')\r\n            .data(colorPerValue)\r\n            .enter()\r\n            .append('rect');\r\n        buckets\r\n            .attr('x', (d, i) => i * w + this.options.margin)\r\n            .attr('y', () => 0)\r\n            .attr('height', () => this.options.height /*w * 4*/ )\r\n            .attr('width', () => w)\r\n            .attr('stroke-width', 2)\r\n            .attr('stroke-linecap', 'butt')\r\n            .attr('stroke', d => d.color.hex())\r\n            .attr('fill', d => d.color.hex());\r\n        buckets\r\n            .append('title')\r\n            .text(\r\n                d =>\r\n                `${d.value.toFixed(this.options.decimals)} ${this.options\r\n                        .units}`\r\n            );\r\n    },\r\n\r\n    _appendLabelsTo: function (svg) {\r\n        const positionPerLabelValue = this._getPositionPerLabelValue();\r\n        //const w = this.options.width / colorPerValue.length;\r\n        let groupLabels = svg.append('g').attr('id', 'colorBar-labels');\r\n        let labels = groupLabels\r\n            .selectAll('text')\r\n            .data(positionPerLabelValue)\r\n            .enter()\r\n            .append('text');\r\n        labels\r\n            .attr('x', d => d.position + this.options.margin)\r\n            .attr('y', this.options.height + this.options.margin)\r\n            .attr('font-size', `${this.options.labelFontSize}px`)\r\n            .attr('text-anchor', this.options.labelTextPosition)\r\n            .attr('fill', this.options.textColor)\r\n            .attr('class', 'leaflet-control-colorBar-label')\r\n            .text(d => this.options.textLabels ? d.label : `${d.value.toFixed(this.options.decimals)}`);\r\n    },\r\n\r\n    _getColorPerValue: function () {\r\n        const [min, max] = this.range;\r\n        let delta = (max - min) / this.options.steps;\r\n        let data = d3.range(min, max + delta, delta);\r\n        let colorPerValue = data.map(d => {\r\n            return {\r\n                value: d,\r\n                color: this.color(d)\r\n            };\r\n        });\r\n        return colorPerValue;\r\n    },\r\n\r\n    _getPositionPerLabelValue: function () {\r\n        var xPositionFor = d3\r\n            .scaleLinear()\r\n            .range([0, this.options.width])\r\n            .domain(this.range);\r\n        let data = this.options.labels;\r\n        let positionPerLabel = data.map((d, index) => {\r\n            return {\r\n                label: this.options.textLabels ? this.options.textLabels[index] : '',\r\n                value: d,\r\n                position: xPositionFor(d)\r\n            };\r\n        });\r\n        return positionPerLabel;\r\n    }\r\n});\r\n\r\nL.control.colorBar = function (color, range, options) {\r\n    return new L.Control.ColorBar(color, range, options);\r\n};\n\n\n// WEBPACK FOOTER //\n// ./control/L.Control.ColorBar.js","/**\r\n * Abstract class for a Field layer on canvas, aka 'a Raster layer'\r\n * (ScalarField or a VectorField)\r\n */\r\nL.CanvasLayer.Field = L.CanvasLayer.extend({\r\n    options: {\r\n        mouseMoveCursor: {\r\n            value: 'pointer',\r\n            noValue: 'default'\r\n        },\r\n        opacity: 1,\r\n        onClick: null,\r\n        onMouseMove: null,\r\n        inFilter: null\r\n    },\r\n\r\n    initialize: function(field, options) {\r\n        L.Util.setOptions(this, options);\r\n        this._visible = true;\r\n        if (field) {\r\n            this.setData(field);\r\n        }\r\n    },\r\n\r\n    getEvents: function() {\r\n        var events = L.CanvasLayer.prototype.getEvents.call(this);\r\n        events.zoomstart = this._hideCanvas.bind(this);\r\n        events.zoomend = this._showCanvas.bind(this);\r\n        return events;\r\n    },\r\n\r\n    onLayerDidMount: function() {\r\n        this._enableIdentify();\r\n        this._ensureCanvasAlignment();\r\n    },\r\n\r\n    show() {\r\n        this._visible = true;\r\n        this._showCanvas();\r\n        this._enableIdentify();\r\n    },\r\n\r\n    hide() {\r\n        this._visible = false;\r\n        this._hideCanvas();\r\n        this._disableIdentify();\r\n    },\r\n\r\n    isVisible() {\r\n        return this._visible;\r\n    },\r\n\r\n    _showCanvas() {\r\n        if (this._canvas && this._visible) {\r\n            this._canvas.style.visibility = 'visible';\r\n        }\r\n    },\r\n\r\n    _hideCanvas() {\r\n        if (this._canvas) {\r\n            this._canvas.style.visibility = 'hidden';\r\n        }\r\n    },\r\n\r\n    _enableIdentify() {\r\n        this._map.on('click', this._onClick, this);\r\n        this._map.on('mousemove', this._onMouseMove, this);\r\n\r\n        this.options.onClick && this.on('click', this.options.onClick, this);\r\n        this.options.onMouseMove &&\r\n            this.on('mousemove', this.options.onMouseMove, this);\r\n    },\r\n\r\n    _disableIdentify() {\r\n        this._map.off('click', this._onClick, this);\r\n        this._map.off('mousemove', this._onMouseMove, this);\r\n\r\n        this.options.onClick && this.off('click', this.options.onClick, this);\r\n        this.options.onMouseMove &&\r\n            this.off('mousemove', this.options.onMouseMove, this);\r\n    },\r\n\r\n    _ensureCanvasAlignment() {\r\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\r\n        L.DomUtil.setPosition(this._canvas, topLeft);\r\n    },\r\n\r\n    onLayerWillUnmount: function() {\r\n        this._disableIdentify();\r\n    },\r\n\r\n    needRedraw() {\r\n        if (this._map && this._field) {\r\n            L.CanvasLayer.prototype.needRedraw.call(this);\r\n        }\r\n    },\r\n\r\n    /* eslint-disable no-unused-vars */\r\n    onDrawLayer: function(viewInfo) {\r\n        throw new TypeError('Must be overriden');\r\n    },\r\n    /* eslint-enable no-unused-vars */\r\n\r\n    setData: function(field) {\r\n        this.options.inFilter && field.setFilter(this.options.inFilter);\r\n        this._field = field;\r\n        this.needRedraw();\r\n        this.fire('load');\r\n    },\r\n\r\n    setFilter: function(f) {\r\n        this.options.inFilter = f;\r\n        this._field && this._field.setFilter(f);\r\n        this.needRedraw();\r\n    },\r\n\r\n    setOpacity: function(opacity) {\r\n        this.options.opacity = opacity;\r\n\r\n        if (this._canvas) {\r\n            this._updateOpacity();\r\n        }\r\n        return this;\r\n    },\r\n\r\n    getBounds: function() {\r\n        let bb = this._field.extent();\r\n\r\n        let southWest = L.latLng(bb[1], bb[0]),\r\n            northEast = L.latLng(bb[3], bb[2]);\r\n        let bounds = L.latLngBounds(southWest, northEast);\r\n        return bounds;\r\n    },\r\n\r\n    _onClick: function(e) {\r\n        let v = this._queryValue(e);\r\n        this.fire('click', v);\r\n    },\r\n\r\n    _onMouseMove: function(e) {\r\n        let v = this._queryValue(e);\r\n        this._changeCursorOn(v);\r\n        this.fire('mousemove', v);\r\n    },\r\n\r\n    _changeCursorOn: function(v) {\r\n        if (!this.options.mouseMoveCursor) return;\r\n\r\n        let { value, noValue } = this.options.mouseMoveCursor;\r\n        let style = this._map.getContainer().style;\r\n        style.cursor = v.value !== null ? value : noValue;\r\n    },\r\n\r\n    _updateOpacity: function() {\r\n        L.DomUtil.setOpacity(this._canvas, this.options.opacity);\r\n    },\r\n\r\n    _queryValue: function(e) {\r\n        let v = this._field\r\n            ? this._field.valueAt(e.latlng.lng, e.latlng.lat)\r\n            : null;\r\n        let result = {\r\n            latlng: e.latlng,\r\n            value: v\r\n        };\r\n        return result;\r\n    },\r\n\r\n    _getDrawingContext: function() {\r\n        let g = this._canvas.getContext('2d');\r\n        g.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        return g;\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./layer/L.CanvasLayer.Field.js","import Cell from '../Cell';\r\n\r\n/**\r\n * ScalarField on canvas (a 'Raster')\r\n */\r\nL.CanvasLayer.ScalarField = L.CanvasLayer.Field.extend({\r\n    options: {\r\n        type: 'colormap', // [colormap|vector]\r\n        color: null, // function colorFor(value) [e.g. chromajs.scale],\r\n        interpolate: false, // Change to use interpolation\r\n        vectorSize: 20, // only used if 'vector'\r\n        arrowDirection: 'from' // [from|towards]\r\n    },\r\n\r\n    initialize: function(scalarField, options) {\r\n        L.CanvasLayer.Field.prototype.initialize.call(\r\n            this,\r\n            scalarField,\r\n            options\r\n        );\r\n        L.Util.setOptions(this, options);\r\n    },\r\n\r\n    _defaultColorScale: function() {\r\n        return chroma.scale(['white', 'black']).domain(this._field.range);\r\n    },\r\n\r\n    setColor(f) {\r\n        this.options.color = f;\r\n        this.needRedraw();\r\n    },\r\n\r\n    /* eslint-disable no-unused-vars */\r\n    onDrawLayer: function(viewInfo) {\r\n        if (!this.isVisible()) return;\r\n        this._updateOpacity();\r\n\r\n        let r = this._getRendererMethod();\r\n        //console.time('onDrawLayer');\r\n        r();\r\n        //console.timeEnd('onDrawLayer');\r\n    },\r\n    /* eslint-enable no-unused-vars */\r\n\r\n    _getRendererMethod: function() {\r\n        switch (this.options.type) {\r\n            case 'colormap':\r\n                return this._drawImage.bind(this);\r\n            case 'vector':\r\n                return this._drawArrows.bind(this);\r\n            default:\r\n                throw Error(`Unkwown renderer type: ${this.options.type}`);\r\n        }\r\n    },\r\n\r\n    _ensureColor: function() {\r\n        if (this.options.color === null) {\r\n            this.setColor(this._defaultColorScale());\r\n        }\r\n    },\r\n\r\n    _showCanvas() {\r\n        L.CanvasLayer.Field.prototype._showCanvas.call(this);\r\n        this.needRedraw(); // TODO check spurious redraw (e.g. hide/show without moving map)\r\n    },\r\n\r\n    /**\r\n     * Draws the field in an ImageData and applying it with putImageData.\r\n     * Used as a reference: http://geoexamples.com/d3-raster-tools-docs/code_samples/raster-pixels-page.html\r\n     */\r\n    _drawImage: function() {\r\n        this._ensureColor();\r\n\r\n        let ctx = this._getDrawingContext();\r\n        let width = this._canvas.width;\r\n        let height = this._canvas.height;\r\n\r\n        let img = ctx.createImageData(width, height);\r\n        let data = img.data;\r\n\r\n        this._prepareImageIn(data, width, height);\r\n        ctx.putImageData(img, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Prepares the image in data, as array with RGBAs\r\n     * [R1, G1, B1, A1, R2, G2, B2, A2...]\r\n     * @private\r\n     * @param {[[Type]]} data   [[Description]]\r\n     * @param {Numver} width\r\n     * @param {Number} height\r\n     */\r\n    _prepareImageIn(data, width, height) {\r\n        let f = this.options.interpolate ? 'interpolatedValueAt' : 'valueAt';\r\n\r\n        let pos = 0;\r\n        for (let j = 0; j < height; j++) {\r\n            for (let i = 0; i < width; i++) {\r\n                let pointCoords = this._map.containerPointToLatLng([i, j]);\r\n                let lon = pointCoords.lng;\r\n                let lat = pointCoords.lat;\r\n\r\n                let v = this._field[f](lon, lat); // 'valueAt' | 'interpolatedValueAt' || TODO check some 'artifacts'\r\n                if (v !== null) {\r\n                    let color = this._getColorFor(v);\r\n                    let [R, G, B, A] = color.rgba();\r\n                    data[pos] = R;\r\n                    data[pos + 1] = G;\r\n                    data[pos + 2] = B;\r\n                    data[pos + 3] = parseInt(A * 255); // not percent in alpha but hex 0-255\r\n                }\r\n                pos = pos + 4;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Draws the field as a set of arrows. Direction from 0 to 360 is assumed.\r\n     */\r\n    _drawArrows: function() {\r\n        const bounds = this._pixelBounds();\r\n        const pixelSize = (bounds.max.x - bounds.min.x) / this._field.nCols;\r\n\r\n        var stride = Math.max(\r\n            1,\r\n            Math.floor(1.2 * this.options.vectorSize / pixelSize)\r\n        );\r\n\r\n        const ctx = this._getDrawingContext();\r\n        ctx.strokeStyle = this.options.color;\r\n\r\n        var currentBounds = this._map.getBounds();\r\n\r\n        for (var y = 0; y < this._field.height; y = y + stride) {\r\n            for (var x = 0; x < this._field.width; x = x + stride) {\r\n                let [lon, lat] = this._field._lonLatAtIndexes(x, y);\r\n                let v = this._field.valueAt(lon, lat);\r\n                let center = L.latLng(lat, lon);\r\n                if (v !== null && currentBounds.contains(center)) {\r\n                    let cell = new Cell(\r\n                        center,\r\n                        v,\r\n                        this.cellXSize,\r\n                        this.cellYSize\r\n                    );\r\n                    this._drawArrow(cell, ctx);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    _pixelBounds: function() {\r\n        const bounds = this.getBounds();\r\n        const northWest = this._map.latLngToContainerPoint(\r\n            bounds.getNorthWest()\r\n        );\r\n        const southEast = this._map.latLngToContainerPoint(\r\n            bounds.getSouthEast()\r\n        );\r\n        var pixelBounds = L.bounds(northWest, southEast);\r\n        return pixelBounds;\r\n    },\r\n\r\n    _drawArrow: function(cell, ctx) {\r\n        var projected = this._map.latLngToContainerPoint(cell.center);\r\n\r\n        // colormap vs. simple color\r\n        let color = this.options.color;\r\n        if (typeof color === 'function') {\r\n            ctx.strokeStyle = color(cell.value);\r\n        }\r\n\r\n        const size = this.options.vectorSize;\r\n        ctx.save();\r\n\r\n        ctx.translate(projected.x, projected.y);\r\n\r\n        let rotationRads = (90 + cell.value) * Math.PI / 180; // from, by default\r\n        if (this.options.arrowDirection === 'towards') {\r\n            rotationRads = rotationRads + Math.PI;\r\n        }\r\n        ctx.rotate(rotationRads);\r\n\r\n        ctx.beginPath();\r\n        ctx.moveTo(-size / 2, 0);\r\n        ctx.lineTo(+size / 2, 0);\r\n        ctx.moveTo(size * 0.25, -size * 0.25);\r\n        ctx.lineTo(+size / 2, 0);\r\n        ctx.lineTo(size * 0.25, size * 0.25);\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Gets a chroma color for a pixel value, according to 'options.color'\r\n     */\r\n    _getColorFor(v) {\r\n        let c = this.options.color; // e.g. for a constant 'red'\r\n        if (typeof c === 'function') {\r\n            c = this.options.color(v);\r\n        }\r\n        let color = chroma(c); // to be more flexible, a chroma color object is always created || TODO improve efficiency\r\n        return color;\r\n    }\r\n});\r\n\r\nL.canvasLayer.scalarField = function(scalarField, options) {\r\n    return new L.CanvasLayer.ScalarField(scalarField, options);\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./layer/L.CanvasLayer.ScalarField.js","/**\r\n *  Simple layer with lon-lat points\r\n *\r\n *  TODO rename to SimplePoint?\r\n */\r\nL.CanvasLayer.SimpleLonLat = L.CanvasLayer.extend({\r\n    options: {\r\n        color: 'gray'\r\n    },\r\n\r\n    initialize: function(points, options) {\r\n        this.points = points;\r\n        L.Util.setOptions(this, options);\r\n    },\r\n\r\n    onLayerDidMount: function() {\r\n        // -- prepare custom drawing\r\n    },\r\n\r\n    onLayerWillUnmount: function() {\r\n        // -- custom cleanup\r\n    },\r\n\r\n    /* eslint-disable no-unused-vars */\r\n    setData: function(data) {\r\n        // -- custom data set\r\n        this.needRedraw(); // -- call to drawLayer\r\n    },\r\n    /* eslint-enable no-unused-vars */\r\n\r\n    onDrawLayer: function(viewInfo) {\r\n        // canvas preparation\r\n        let g = viewInfo.canvas.getContext('2d');\r\n        g.clearRect(0, 0, viewInfo.canvas.width, viewInfo.canvas.height);\r\n        g.fillStyle = this.options.color;\r\n\r\n        for (let point of this.points) {\r\n            let p = viewInfo.layer._map.latLngToContainerPoint(point);\r\n            g.beginPath();\r\n            //g.arc(p.x, p.y, 1, 0, Math.PI * 2); // circle | TODO style 'function' as parameter?\r\n            g.fillRect(p.x, p.y, 2, 2); //simple point\r\n            g.fill();\r\n            g.closePath();\r\n            g.stroke();\r\n        }\r\n    },\r\n\r\n    getBounds: function() {\r\n        // TODO: bounding with points...\r\n        let xs = this.points.map(pt => pt.lng);\r\n        let ys = this.points.map(pt => pt.lat);\r\n\r\n        let xmin = Math.min(...xs);\r\n        let ymin = Math.min(...ys);\r\n        let xmax = Math.max(...xs);\r\n        let ymax = Math.max(...ys);\r\n\r\n        let southWest = L.latLng(ymin, xmin),\r\n            northEast = L.latLng(ymax, xmax);\r\n        let bounds = L.latLngBounds(southWest, northEast); // TODO FIX ERROR ? half-pixel?\r\n        return bounds;\r\n    }\r\n});\r\n\r\nL.canvasLayer.simpleLonLat = function(lonslats, options) {\r\n    return new L.CanvasLayer.SimpleLonLat(lonslats, options);\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./layer/L.CanvasLayer.SimpleLonLat.js","/**\r\n * Animated VectorField on canvas\r\n */\r\nL.CanvasLayer.VectorFieldAnim = L.CanvasLayer.Field.extend({\r\n    options: {\r\n        paths: 800,\r\n        color: 'white', // html-color | function colorFor(value) [e.g. chromajs.scale]\r\n        width: 1.0, // number | function widthFor(value)\r\n        fade: 0.96, // 0 to 1\r\n        duration: 20, // milliseconds per 'frame'\r\n        maxAge: 200, // number of maximum frames per path\r\n        velocityScale: 1 / 5000\r\n    },\r\n\r\n    initialize: function(vectorField, options) {\r\n        L.CanvasLayer.Field.prototype.initialize.call(\r\n            this,\r\n            vectorField,\r\n            options\r\n        );\r\n        L.Util.setOptions(this, options);\r\n\r\n        this.timer = null;\r\n    },\r\n\r\n    onLayerDidMount: function() {\r\n        L.CanvasLayer.Field.prototype.onLayerDidMount.call(this);\r\n        this._map.on('move resize', this._stopAnimation, this);\r\n    },\r\n\r\n    onLayerWillUnmount: function() {\r\n        L.CanvasLayer.Field.prototype.onLayerWillUnmount.call(this);\r\n        this._map.off('move resize', this._stopAnimation, this);\r\n        this._stopAnimation();\r\n    },\r\n\r\n    _hideCanvas: function _showCanvas() {\r\n        L.CanvasLayer.Field.prototype._hideCanvas.call(this);\r\n        this._stopAnimation();\r\n    },\r\n\r\n    onDrawLayer: function(viewInfo) {\r\n        if (!this._field || !this.isVisible()) return;\r\n\r\n        this._updateOpacity();\r\n\r\n        let ctx = this._getDrawingContext();\r\n        let paths = this._prepareParticlePaths();\r\n\r\n        this.timer = d3.timer(function() {\r\n            _moveParticles();\r\n            _drawParticles();\r\n        }, this.options.duration);\r\n\r\n        let self = this;\r\n\r\n        /**\r\n         * Builds the paths, adding 'particles' on each animation step, considering\r\n         * their properties (age / position source > target)\r\n         */\r\n        function _moveParticles() {\r\n            // let screenFactor = 1 / self._map.getZoom(); // consider using a 'screenFactor' to ponderate velocityScale\r\n            paths.forEach(function(par) {\r\n                if (par.age > self.options.maxAge) {\r\n                    // restart, on a random x,y\r\n                    par.age = 0;\r\n                    self._field.randomPosition(par);\r\n                }\r\n\r\n                let vector = self._field.valueAt(par.x, par.y);\r\n                if (vector === null) {\r\n                    par.age = self.options.maxAge;\r\n                } else {\r\n                    // the next point will be...\r\n                    let xt = par.x + vector.u * self.options.velocityScale; //* screenFactor;\r\n                    let yt = par.y + vector.v * self.options.velocityScale; //* screenFactor;\r\n\r\n                    if (self._field.hasValueAt(xt, yt)) {\r\n                        par.xt = xt;\r\n                        par.yt = yt;\r\n                        par.m = vector.magnitude();\r\n                    } else {\r\n                        // not visible anymore...\r\n                        par.age = self.options.maxAge;\r\n                    }\r\n                }\r\n                par.age += 1;\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Draws the paths on each step\r\n         */\r\n        function _drawParticles() {\r\n            // Previous paths...\r\n            let prev = ctx.globalCompositeOperation;\r\n            ctx.globalCompositeOperation = 'destination-in';\r\n            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n            //ctx.globalCompositeOperation = 'source-over';\r\n            ctx.globalCompositeOperation = prev;\r\n\r\n            // fading paths...\r\n            ctx.fillStyle = `rgba(0, 0, 0, ${self.options.fade})`;\r\n            ctx.lineWidth = self.options.width;\r\n            ctx.strokeStyle = self.options.color;\r\n\r\n            // New paths\r\n            paths.forEach(function(par) {\r\n                self._drawParticle(viewInfo, ctx, par);\r\n            });\r\n        }\r\n    },\r\n\r\n    _drawParticle(viewInfo, ctx, par) {\r\n        let source = new L.latLng(par.y, par.x);\r\n        let target = new L.latLng(par.yt, par.xt);\r\n\r\n        if (\r\n            viewInfo.bounds.contains(source) &&\r\n            par.age <= this.options.maxAge\r\n        ) {\r\n            let pA = viewInfo.layer._map.latLngToContainerPoint(source);\r\n            let pB = viewInfo.layer._map.latLngToContainerPoint(target);\r\n\r\n            ctx.beginPath();\r\n            ctx.moveTo(pA.x, pA.y);\r\n            ctx.lineTo(pB.x, pB.y);\r\n\r\n            // next-step movement\r\n            par.x = par.xt;\r\n            par.y = par.yt;\r\n\r\n            // colormap vs. simple color\r\n            let color = this.options.color;\r\n            if (typeof color === 'function') {\r\n                ctx.strokeStyle = color(par.m);\r\n            }\r\n\r\n            let width = this.options.width;\r\n            if (typeof width === 'function') {\r\n                ctx.lineWidth = width(par.m);\r\n            }\r\n\r\n            ctx.stroke();\r\n        }\r\n    },\r\n\r\n    _prepareParticlePaths: function() {\r\n        let paths = [];\r\n\r\n        for (var i = 0; i < this.options.paths; i++) {\r\n            let p = this._field.randomPosition();\r\n            p.age = this._randomAge();\r\n            paths.push(p);\r\n        }\r\n        return paths;\r\n    },\r\n\r\n    _randomAge: function() {\r\n        return Math.floor(Math.random() * this.options.maxAge);\r\n    },\r\n\r\n    _stopAnimation: function() {\r\n        if (this.timer) {\r\n            this.timer.stop();\r\n        }\r\n    }\r\n});\r\n\r\nL.canvasLayer.vectorFieldAnim = function(vectorField, options) {\r\n    return new L.CanvasLayer.VectorFieldAnim(vectorField, options);\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./layer/L.CanvasLayer.VectorFieldAnim.js","/*\r\n  1.0.1 (downloaded from https://github.com/Sumbera/gLayers.Leaflet/releases/tag/v1.0.1)\r\n\r\n  Generic  Canvas Layer for leaflet 0.7 and 1.0-rc,\r\n  copyright Stanislav Sumbera,  2016 , sumbera.com , license MIT\r\n  originally created and motivated by L.CanvasOverlay  available here: https://gist.github.com/Sumbera/11114288\r\n*/\r\n\r\nL.CanvasLayer = L.Layer.extend({\r\n    // -- initialized is called on prototype\r\n    initialize: function (options) {\r\n        this._map = null;\r\n        this._canvas = null;\r\n        this._frame = null;\r\n        this._delegate = null;\r\n        L.setOptions(this, options);\r\n    },\r\n\r\n    delegate: function (del) {\r\n        this._delegate = del;\r\n        return this;\r\n    },\r\n\r\n    needRedraw: function () {\r\n        if (!this._frame) {\r\n            this._frame = L.Util.requestAnimFrame(this.drawLayer, this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    //-------------------------------------------------------------\r\n    _onLayerDidResize: function (resizeEvent) {\r\n        this._canvas.width = resizeEvent.newSize.x;\r\n        this._canvas.height = resizeEvent.newSize.y;\r\n    },\r\n    //-------------------------------------------------------------\r\n    _onLayerDidMove: function () {\r\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\r\n        L.DomUtil.setPosition(this._canvas, topLeft);\r\n        this.drawLayer();\r\n    },\r\n    //-------------------------------------------------------------\r\n    getEvents: function () {\r\n        var events = {\r\n            resize: this._onLayerDidResize,\r\n            moveend: this._onLayerDidMove\r\n        };\r\n        if (this._map.options.zoomAnimation && L.Browser.any3d) {\r\n            events.zoomanim = this._animateZoom;\r\n        }\r\n\r\n        return events;\r\n    },\r\n    //-------------------------------------------------------------\r\n    onAdd: function (map) {\r\n        this._map = map;\r\n        this._canvas = L.DomUtil.create('canvas', 'leaflet-layer');\r\n        this.tiles = {};\r\n\r\n        var size = this._map.getSize();\r\n        this._canvas.width = size.x;\r\n        this._canvas.height = size.y;\r\n\r\n        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\r\n        L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\r\n\r\n\r\n        map._panes.overlayPane.appendChild(this._canvas);\r\n\r\n        map.on(this.getEvents(), this);\r\n\r\n        var del = this._delegate || this;\r\n        del.onLayerDidMount && del.onLayerDidMount(); // -- callback\r\n\r\n        this.needRedraw();\r\n    },\r\n\r\n    //-------------------------------------------------------------\r\n    onRemove: function (map) {\r\n        var del = this._delegate || this;\r\n        del.onLayerWillUnmount && del.onLayerWillUnmount(); // -- callback\r\n\r\n\r\n        map.getPanes().overlayPane.removeChild(this._canvas);\r\n\r\n        map.off(this.getEvents(), this);\r\n\r\n        this._canvas = null;\r\n\r\n    },\r\n\r\n    //------------------------------------------------------------\r\n    addTo: function (map) {\r\n        map.addLayer(this);\r\n        return this;\r\n    },\r\n    // --------------------------------------------------------------------------------\r\n    LatLonToMercator: function (latlon) {\r\n        return {\r\n            x: latlon.lng * 6378137 * Math.PI / 180,\r\n            y: Math.log(Math.tan((90 + latlon.lat) * Math.PI / 360)) * 6378137\r\n        };\r\n    },\r\n\r\n    //------------------------------------------------------------------------------\r\n    drawLayer: function () {\r\n        // -- todo make the viewInfo properties  flat objects.\r\n        var size = this._map.getSize();\r\n        var bounds = this._map.getBounds();\r\n        var zoom = this._map.getZoom();\r\n\r\n        var center = this.LatLonToMercator(this._map.getCenter());\r\n        var corner = this.LatLonToMercator(this._map.containerPointToLatLng(this._map.getSize()));\r\n\r\n        var del = this._delegate || this;\r\n        del.onDrawLayer && del.onDrawLayer({\r\n            layer: this,\r\n            canvas: this._canvas,\r\n            bounds: bounds,\r\n            size: size,\r\n            zoom: zoom,\r\n            center: center,\r\n            corner: corner\r\n        });\r\n        this._frame = null;\r\n    },\r\n\r\n    //------------------------------------------------------------------------------\r\n    _animateZoom: function (e) {\r\n        var scale = this._map.getZoomScale(e.zoom);\r\n        var offset = this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), e.zoom, e.center);\r\n\r\n        L.DomUtil.setTransform(this._canvas, offset, scale);\r\n    }\r\n});\r\n\r\nL.canvasLayer = function () {\r\n    return new L.CanvasLayer();\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./layer/L.CanvasLayer.js","var invariant = require('@turf/invariant');\nvar getCoord = invariant.getCoord;\nvar getCoords = invariant.getCoords;\n\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can\n * be convex or concave. The function accounts for holes.\n *\n * @name inside\n * @param {Feature<Point>} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {boolean} [ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.inside(pt, poly);\n * //= true\n */\nmodule.exports = function (point, polygon, ignoreBoundary) {\n    // validation\n    if (!point) throw new Error('point is required');\n    if (!polygon) throw new Error('polygon is required');\n\n    var pt = getCoord(point);\n    var polys = getCoords(polygon);\n    var type = (polygon.geometry) ? polygon.geometry.type : polygon.type;\n    var bbox = polygon.bbox;\n\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) return false;\n\n    // normalize to multipolygon\n    if (type === 'Polygon') polys = [polys];\n\n    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) insidePoly = true;\n        }\n    }\n    return insidePoly;\n};\n\n/**\n * inRing\n *\n * @private\n * @param {[number, number]} pt [x,y]\n * @param {Array<[number, number]>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0], yi = ring[i][1];\n        var xj = ring[j][0], yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) return !ignoreBoundary;\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\n\n/**\n * inBBox\n *\n * @private\n * @param {[number, number]} pt point [x,y]\n * @param {[number, number, number, number]} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n           bbox[1] <= pt[1] &&\n           bbox[2] >= pt[0] &&\n           bbox[3] >= pt[1];\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@turf/inside/index.js\n// module id = 11\n// module chunks = 0","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {string} GeoJSON Geometry Type\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeomType(point)\n * //=\"Point\"\n */\nfunction getGeomType(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    var geom = getGeom(geojson);\n    if (geom) return geom.type;\n}\n\nmodule.exports = {\n    geojsonType: geojsonType,\n    collectionOf: collectionOf,\n    featureOf: featureOf,\n    getCoord: getCoord,\n    getCoords: getCoords,\n    containsNumber: containsNumber,\n    getGeom: getGeom,\n    getGeomType: getGeomType\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@turf/invariant/index.js\n// module id = 12\n// module chunks = 0","// base\r\nimport Vector from './Vector.js';\r\nwindow.L.Vector = Vector;\r\n\r\nimport Cell from './Cell.js';\r\nwindow.L.Cell = Cell;\r\n\r\nimport Field from './Field.js';\r\nwindow.L.Field = Field;\r\n\r\nimport ScalarField from './ScalarField.js';\r\nwindow.L.ScalarField = ScalarField;\r\n\r\nimport VectorField from './VectorField.js';\r\nwindow.L.VectorField = VectorField;\r\n\r\n// layer\r\nrequire('./layer/L.CanvasLayer.js');\r\nrequire('./layer/L.CanvasLayer.SimpleLonLat.js');\r\nrequire('./layer/L.CanvasLayer.Field.js');\r\nrequire('./layer/L.CanvasLayer.ScalarField.js');\r\nrequire('./layer/L.CanvasLayer.VectorFieldAnim.js');\r\n\r\n// control\r\nrequire('./control/L.Control.ColorBar.js');\n\n\n// WEBPACK FOOTER //\n// ./_main.js"],"sourceRoot":""}