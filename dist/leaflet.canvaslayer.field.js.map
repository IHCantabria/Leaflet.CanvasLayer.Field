{"version":3,"sources":["webpack:///leaflet.canvaslayer.field.js","webpack:///webpack/bootstrap b9f490ab47c1f9f16469","webpack:///./Cell.js","webpack:///./Field.js","webpack:///./ScalarField.js","webpack:///./Vector.js","webpack:///./VectorField.js","webpack:///./control/L.Control.ColorBar.js","webpack:///./layer/L.CanvasLayer.Field.js","webpack:///./layer/L.CanvasLayer.ScalarField.js","webpack:///./layer/L.CanvasLayer.SimpleLonLat.js","webpack:///./layer/L.CanvasLayer.VectorFieldAnim.js","webpack:///./layer/L.CanvasLayer.js","webpack:///../~/@turf/inside/index.js","webpack:///../~/@turf/invariant/index.js","webpack:///./_main.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","Cell","center","xSize","ySize","arguments","undefined","this","anotherCell","equals","_equalValues","anotherValue","type","constructor","Number","Vector","u","v","halfX","halfY","cLat","lat","cLng","lng","ul","L","latLng","lr","latLngBounds","__WEBPACK_IMPORTED_MODULE_0__Cell__","__WEBPACK_IMPORTED_MODULE_1__turf_inside__","__WEBPACK_IMPORTED_MODULE_1__turf_inside___default","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","push","err","Array","isArray","Field","params","nCols","nRows","width","height","xllCorner","yllCorner","xurCorner","yurCorner","cellXSize","cellYSize","grid","isContinuous","longitudeNeedsToBeWrapped","_inFilter","_spatialMask","range","_calculateRange","stride","cells","j","_lonLatAtIndexes2","_lonLatAtIndexes","_lonLatAtIndexes3","lon","_valueAtIndexes","f","_updateRange","_getWrappedLongitudes2","_getWrappedLongitudes","_getWrappedLongitudes3","xmin","xmax","_pointInMask","_pointInExtent","_getWrappedLongitudes4","_getWrappedLongitudes5","longitudeIn","latitudeIn","pt","geometry","coordinates","properties","poly","contains","notContains","_getDecimalIndexes2","_getDecimalIndexes","_getDecimalIndexes3","interpolatedValueAtIndexes","indexes","_getFourSurroundingIndexes","_indexes","fi","ci","fj","cj","values","_getFourSurroundingValues","_values","g00","g10","g01","g11","_doInterpolation","Math","floor","_clampColumnIndex","_clampRowIndex","row","_isValid","_getDecimalIndexes4","_getDecimalIndexes5","ii","jj","valueAt","hasValue","included","hasValueAt","random","x","_longitudeAtX","y","_latitudeAtY","halfXPixel","halfYPixel","maxCol","maxRow","_toConsumableArray","arr2","from","_defineProperty","obj","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0__Field__","ScalarField","_Field","_this","getPrototypeOf","zs","_buildGrid","asc","scaleFactor","lines","split","header","_parseASCIIGridHeader","slice","line","trim","forEach","it","floatItem","parseFloat","noDataValue","headerLines","headerItems","map","items","filter","toUpperCase","usesCorner","cellSize","parseInt","Error","data","bandIndex","multipleFromGeoTIFF","bandIndexes","tiff","GeoTIFF","parse","image","getImage","rasters","readRasters","tiepoint","getTiePoints","fileDirectory","getFileDirectory","_fileDirectory$ModelP","ModelPixelScale","xScale","yScale","keys","GDAL_NODATA","noData","z","getWidth","getHeight","_arrayTo2d","array","d3","min","max","rx","ry","sqrt","verticalAngle","atan2","inDegrees","PI","directionTo","__WEBPACK_IMPORTED_MODULE_0__Vector__","__WEBPACK_IMPORTED_MODULE_1__Field__","__WEBPACK_IMPORTED_MODULE_2__ScalarField__","VectorField","us","vs","ascU","ascV","fromASCIIGrid","_paramsFromScalarFields","gtU","gtV","fromGeoTIFF","geotiffData","bandIndexesForUV","_ScalarField$multiple","_ScalarField$multiple2","_getFunctionFor","_applyOnField","func","numCells","_arraysTo2d","valid","vectors","getCells","magnitudes","magnitude","a","b","Control","ColorBar","extend","options","position","margin","background","textColor","steps","decimals","units","title","labels","labelFontSize","labelTextPosition","initialize","color","Util","setOptions","onAdd","_map","div","DomUtil","style","padding","DomEvent","addListener","stopPropagation","preventDefault","backgroundColor","cursor","innerHTML","palette","document","createElement","select","append","attr","text","svg","_createSvgIn","_appendColorBarTo","_appendLabelsTo","spaceForLabels","colorPerValue","_getColorPerValue","w","groupBars","buckets","selectAll","enter","hex","toFixed","_this2","positionPerLabelValue","_getPositionPerLabelValue","_this3","_range","delta","xPositionFor","scaleLinear","domain","control","colorBar","CanvasLayer","mouseMoveCursor","noValue","opacity","onClick","onMouseMove","inFilter","field","_visible","setData","getEvents","events","zoomstart","_hideCanvas","bind","zoomend","_showCanvas","onLayerDidMount","_enableIdentify","_ensureCanvasAlignment","show","hide","_disableIdentify","isVisible","_canvas","visibility","on","_onClick","_onMouseMove","off","topLeft","containerPointToLayerPoint","setPosition","onLayerWillUnmount","needRedraw","_field","onDrawLayer","viewInfo","setFilter","fire","setOpacity","_updateOpacity","getBounds","bb","extent","southWest","northEast","e","_queryValue","_changeCursorOn","_options$mouseMoveCur","getContainer","latlng","_getDrawingContext","g","getContext","clearRect","interpolate","vectorSize","arrowDirection","scalarField","_defaultColorScale","chroma","scale","setColor","_getRendererMethod","_drawImage","_drawArrows","_ensureColor","ctx","img","createImageData","_prepareImageIn","putImageData","pos","pointCoords","containerPointToLatLng","_getColorFor","_color$rgba","rgba","_color$rgba2","R","G","B","A","bounds","_pixelBounds","pixelSize","strokeStyle","currentBounds","_field$_lonLatAtIndex","_field$_lonLatAtIndex2","cell","_drawArrow","northWest","latLngToContainerPoint","getNorthWest","southEast","getSouthEast","projected","size","save","translate","rotationRads","rotate","beginPath","moveTo","lineTo","stroke","restore","canvasLayer","SimpleLonLat","points","canvas","fillStyle","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","point","layer","fillRect","fill","closePath","return","xs","ys","apply","ymin","ymax","simpleLonLat","lonslats","VectorFieldAnim","paths","fade","duration","maxAge","velocityScale","vectorField","timer","_stopAnimation","_moveParticles","par","age","randomPosition","vector","xt","yt","_drawParticles","prev","globalCompositeOperation","lineWidth","_drawParticle","_prepareParticlePaths","source","pA","pB","_randomAge","stop","vectorFieldAnim","Layer","_frame","_delegate","delegate","del","requestAnimFrame","drawLayer","_onLayerDidResize","resizeEvent","newSize","_onLayerDidMove","resize","moveend","zoomAnimation","Browser","any3d","zoomanim","_animateZoom","tiles","getSize","animated","addClass","_panes","overlayPane","appendChild","onRemove","getPanes","removeChild","addTo","addLayer","LatLonToMercator","latlon","log","tan","zoom","getZoom","getCenter","corner","getZoomScale","offset","_latLngToNewLayerPoint","setTransform","inRing","ring","ignoreBoundary","isInside","xi","yi","xj","yj","inBBox","bbox","invariant","getCoord","getCoords","polygon","polys","insidePoly","inHole","k","containsNumber","geojsonType","featureOf","feature","collectionOf","featureCollection","features","getGeom","geojson","geometries","getGeomType","geom","__WEBPACK_IMPORTED_MODULE_0__Vector_js__","__WEBPACK_IMPORTED_MODULE_1__Cell_js__","__WEBPACK_IMPORTED_MODULE_2__Field_js__","__WEBPACK_IMPORTED_MODULE_3__ScalarField_js__","__WEBPACK_IMPORTED_MODULE_4__VectorField_js__","window","console"],"mappings":"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","file":"leaflet.canvaslayer.field.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 13);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *  Simple regular cell in a raster\n */\nvar Cell = function () {\n    /**\n     * A simple cell with a numerical value\n     * @param {L.LatLng} center\n     * @param {Number|Vector} value\n     * @param {Number} xSize\n     * @param {Number} ySize\n     */\n    function Cell(center, value, xSize) {\n        var ySize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : xSize;\n\n        _classCallCheck(this, Cell);\n\n        this.center = center;\n        this.value = value;\n        this.xSize = xSize;\n        this.ySize = ySize;\n    }\n\n    _createClass(Cell, [{\n        key: \"equals\",\n        value: function equals(anotherCell) {\n            return this.center.equals(anotherCell.center) && this._equalValues(this.value, anotherCell.value) && this.xSize === anotherCell.xSize && this.ySize === anotherCell.ySize;\n        }\n    }, {\n        key: \"_equalValues\",\n        value: function _equalValues(value, anotherValue) {\n            var type = value.constructor.name;\n            var answerFor = {\n                Number: value === anotherValue,\n                Vector: value.u === anotherValue.u && value.v === anotherValue.v\n            };\n            return answerFor[type];\n        }\n\n        /**\n         * Bounds for the cell\n         * @returns {LatLngBounds}\n         */\n\n    }, {\n        key: \"getBounds\",\n        value: function getBounds() {\n            var halfX = this.xSize / 2.0;\n            var halfY = this.ySize / 2.0;\n            var cLat = this.center.lat;\n            var cLng = this.center.lng;\n            var ul = L.latLng([cLat + halfY, cLng - halfX]);\n            var lr = L.latLng([cLat - halfY, cLng + halfX]);\n\n            return L.latLngBounds(L.latLng(lr.lat, ul.lng), L.latLng(ul.lat, lr.lng));\n        }\n    }]);\n\n    return Cell;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Cell);\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Cell__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__turf_inside__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__turf_inside___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__turf_inside__);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n/**\n *  Abstract class for a set of values (Vector | Scalar)\n *  assigned to a regular 2D-grid (lon-lat), aka 'a Raster source'\n */\n\nvar Field = function () {\n    function Field(params) {\n        _classCallCheck(this, Field);\n\n        this.params = params;\n\n        this.nCols = params['nCols'];\n        this.nRows = params['nRows'];\n\n        // alias\n        this.width = params['nCols'];\n        this.height = params['nRows'];\n\n        // ll = lower-left\n        this.xllCorner = params['xllCorner'];\n        this.yllCorner = params['yllCorner'];\n\n        // ur = upper-right\n        this.xurCorner = params['xllCorner'] + params['nCols'] * params['cellXSize'];\n        this.yurCorner = params['yllCorner'] + params['nRows'] * params['cellYSize'];\n\n        this.cellXSize = params['cellXSize'];\n        this.cellYSize = params['cellYSize'];\n\n        this.grid = null; // to be defined by subclasses\n        this.isContinuous = this.xurCorner - this.xllCorner >= 360;\n        this.longitudeNeedsToBeWrapped = this.xurCorner > 180; // [0, 360] --> [-180, 180]\n\n        this._inFilter = null;\n        this._spatialMask = null;\n    }\n\n    /**\n     * Builds a grid with a value at each point (either Vector or Number)\n     * Original params must include the required input values, following\n     * x-ascending & y-descending order (same as in ASCIIGrid)\n     * @abstract\n     * @private\n     * @returns {Array.<Array.<Vector|Number>>} - grid[row][column]--> Vector|Number\n     */\n\n\n    _createClass(Field, [{\n        key: '_buildGrid',\n        value: function _buildGrid() {\n            throw new TypeError('Must be overriden');\n        }\n    }, {\n        key: '_updateRange',\n        value: function _updateRange() {\n            this.range = this._calculateRange();\n        }\n\n        /**\n         * Number of cells in the grid (rows * cols)\n         * @returns {Number}\n         */\n\n    }, {\n        key: 'numCells',\n        value: function numCells() {\n            return this.nRows * this.nCols;\n        }\n\n        /**\n         * A list with every cell\n         * @returns {Array<Cell>} - cells (x-ascending & y-descending order)\n         */\n\n    }, {\n        key: 'getCells',\n        value: function getCells() {\n            var stride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n            var cells = [];\n            for (var j = 0; j < this.nRows; j = j + stride) {\n                for (var i = 0; i < this.nCols; i = i + stride) {\n                    var _lonLatAtIndexes2 = this._lonLatAtIndexes(i, j),\n                        _lonLatAtIndexes3 = _slicedToArray(_lonLatAtIndexes2, 2),\n                        lon = _lonLatAtIndexes3[0],\n                        lat = _lonLatAtIndexes3[1];\n\n                    var center = L.latLng(lat, lon);\n                    var value = this._valueAtIndexes(i, j);\n                    var c = new __WEBPACK_IMPORTED_MODULE_0__Cell__[\"a\" /* default */](center, value, this.cellXSize, this.cellYSize);\n                    cells.push(c); // <<\n                }\n            }\n            return cells;\n        }\n\n        /**\n         * Apply a filter function to field values\n         * @param   {Function} f - boolean function\n         */\n\n    }, {\n        key: 'setFilter',\n        value: function setFilter(f) {\n            this._inFilter = f;\n            this._updateRange();\n        }\n\n        /**\n         * Apply a spatial mask to field values\n         * @param {L.GeoJSON} m \n         */\n\n    }, {\n        key: 'setSpatialMask',\n        value: function setSpatialMask(m) {\n            this._spatialMask = m;\n        }\n\n        /**\n         * Grid extent\n         * @returns {Number[]} [xmin, ymin, xmax, ymax]\n         */\n\n    }, {\n        key: 'extent',\n        value: function extent() {\n            var _getWrappedLongitudes2 = this._getWrappedLongitudes(),\n                _getWrappedLongitudes3 = _slicedToArray(_getWrappedLongitudes2, 2),\n                xmin = _getWrappedLongitudes3[0],\n                xmax = _getWrappedLongitudes3[1];\n\n            return [xmin, this.yllCorner, xmax, this.yurCorner];\n        }\n\n        /**\n         * [xmin, xmax] in [-180, 180] range\n         */\n\n    }, {\n        key: '_getWrappedLongitudes',\n        value: function _getWrappedLongitudes() {\n            var xmin = this.xllCorner;\n            var xmax = this.xurCorner;\n\n            if (this.longitudeNeedsToBeWrapped) {\n                if (this.isContinuous) {\n                    xmin = -180;\n                    xmax = 180;\n                } else {\n                    // not sure about this (just one particular case, but others...?)\n                    xmax = this.xurCorner - 360;\n                    xmin = this.xllCorner - 360;\n                    /* eslint-disable no-console */\n                    // console.warn(`are these xmin: ${xmin} & xmax: ${xmax} OK?`);\n                    // TODO: Better throw an exception on no-controlled situations.\n                    /* eslint-enable no-console */\n                }\n            }\n            return [xmin, xmax];\n        }\n\n        /**\n         * Returns whether or not the grid contains the point, considering\n         * the spatialMask if it has been previously set\n         * @param   {Number} lon - longitude\n         * @param   {Number} lat - latitude\n         * @returns {Boolean}\n         */\n\n    }, {\n        key: 'contains',\n        value: function contains(lon, lat) {\n            if (this._spatialMask) {\n                return this._pointInMask(lon, lat);\n            }\n            return this._pointInExtent(lon, lat);\n        }\n\n        /**\n         * Checks if coordinates are inside the Extent (considering wrapped longitudes if needed)\n         * @param {Number} lon \n         * @param {Number} lat \n         */\n\n    }, {\n        key: '_pointInExtent',\n        value: function _pointInExtent(lon, lat) {\n            var _getWrappedLongitudes4 = this._getWrappedLongitudes(),\n                _getWrappedLongitudes5 = _slicedToArray(_getWrappedLongitudes4, 2),\n                xmin = _getWrappedLongitudes5[0],\n                xmax = _getWrappedLongitudes5[1];\n\n            var longitudeIn = lon >= xmin && lon <= xmax;\n            var latitudeIn = lat >= this.yllCorner && lat <= this.yurCorner;\n            return longitudeIn && latitudeIn;\n        }\n\n        /**\n         * Check if coordinates are inside the spatialMask (Point in Polygon analysis)\n         * @param {Number} lon \n         * @param {Number} lat \n         */\n\n    }, {\n        key: '_pointInMask',\n        value: function _pointInMask(lon, lat) {\n            var pt = {\n                type: 'Feature',\n                geometry: {\n                    type: 'Point',\n                    coordinates: [lon, lat] // geojson, lon-lat order !\n                },\n                properties: {}\n            };\n            var poly = this._spatialMask;\n            return __WEBPACK_IMPORTED_MODULE_1__turf_inside___default()(pt, poly);\n        }\n\n        /**\n         * Returns if the grid doesn't contain the point\n         * @param   {Number} lon - longitude\n         * @param   {Number} lat - latitude\n         * @returns {Boolean}\n         */\n\n    }, {\n        key: 'notContains',\n        value: function notContains(lon, lat) {\n            return !this.contains(lon, lat);\n        }\n\n        /**\n         * Interpolated value at lon-lat coordinates (bilinear method)\n         * @param   {Number} longitude\n         * @param   {Number} latitude\n         * @returns {Vector|Number} [u, v, magnitude]\n         *                          \n         * Source: https://github.com/cambecc/earth > product.js\n         */\n\n    }, {\n        key: 'interpolatedValueAt',\n        value: function interpolatedValueAt(lon, lat) {\n            if (this.notContains(lon, lat)) return null;\n\n            var _getDecimalIndexes2 = this._getDecimalIndexes(lon, lat),\n                _getDecimalIndexes3 = _slicedToArray(_getDecimalIndexes2, 2),\n                i = _getDecimalIndexes3[0],\n                j = _getDecimalIndexes3[1];\n\n            return this.interpolatedValueAtIndexes(i, j);\n        }\n\n        /**\n         * Interpolated value at i-j indexes (bilinear method)\n         * @param   {Number} i\n         * @param   {Number} j\n         * @returns {Vector|Number} [u, v, magnitude]\n         *\n         * Source: https://github.com/cambecc/earth > product.js\n         */\n\n    }, {\n        key: 'interpolatedValueAtIndexes',\n        value: function interpolatedValueAtIndexes(i, j) {\n            //         1      2           After converting  and  to fractional grid indexes i and j, we find the\n            //        fi  i   ci          four points 'G' that enclose point (i, j). These points are at the four\n            //         | =1.4 |           corners specified by the floor and ceiling of i and j. For example, given\n            //      ---G--|---G--- fj 8   i = 1.4 and j = 8.3, the four surrounding grid points are (1, 8), (2, 8),\n            //    j ___|_ .   |           (1, 9) and (2, 9).\n            //  =8.3   |      |\n            //      ---G------G--- cj 9   Note that for wrapped grids, the first column is duplicated as the last\n            //         |      |           column, so the index ci can be used without taking a modulo.\n\n            var indexes = this._getFourSurroundingIndexes(i, j);\n\n            var _indexes = _slicedToArray(indexes, 4),\n                fi = _indexes[0],\n                ci = _indexes[1],\n                fj = _indexes[2],\n                cj = _indexes[3];\n\n            var values = this._getFourSurroundingValues(fi, ci, fj, cj);\n            if (values) {\n                var _values = _slicedToArray(values, 4),\n                    g00 = _values[0],\n                    g10 = _values[1],\n                    g01 = _values[2],\n                    g11 = _values[3];\n\n                return this._doInterpolation(i - fi, j - fj, g00, g10, g01, g11);\n            }\n            return null;\n        }\n\n        /**\n         * Get decimal indexes\n         * @private\n         * @param {Number} lon\n         * @param {Number} lat\n         * @returns {Array}    [[Description]]\n         */\n\n    }, {\n        key: '_getDecimalIndexes',\n        value: function _getDecimalIndexes(lon, lat) {\n            if (this.longitudeNeedsToBeWrapped && lon < this.xllCorner) {\n                lon = lon + 360;\n            }\n            var i = (lon - this.xllCorner) / this.cellXSize;\n            var j = (this.yurCorner - lat) / this.cellYSize;\n            return [i, j];\n        }\n\n        /**\n         * Get surrounding indexes (integer), clampling on borders\n         * @private\n         * @param   {Number} i - decimal index\n         * @param   {Number} j - decimal index\n         * @returns {Array} [fi, ci, fj, cj]\n         */\n\n    }, {\n        key: '_getFourSurroundingIndexes',\n        value: function _getFourSurroundingIndexes(i, j) {\n            var fi = Math.floor(i);\n            var ci = fi + 1;\n            // duplicate colum to simplify interpolation logic (wrapped value)\n            if (this.isContinuous && ci >= this.nCols) {\n                ci = 0;\n            }\n            ci = this._clampColumnIndex(ci);\n\n            var fj = this._clampRowIndex(Math.floor(j));\n            var cj = this._clampRowIndex(fj + 1);\n\n            return [fi, ci, fj, cj];\n        }\n\n        /**\n         * Get four surrounding values or null if not available,\n         * from 4 integer indexes\n         * @private\n         * @param   {Number} fi\n         * @param   {Number} ci\n         * @param   {Number} fj\n         * @param   {Number} cj\n         * @returns {Array} \n         */\n\n    }, {\n        key: '_getFourSurroundingValues',\n        value: function _getFourSurroundingValues(fi, ci, fj, cj) {\n            var row;\n            if (row = this.grid[fj]) {\n                // upper row ^^\n                var g00 = row[fi]; // << left\n                var g10 = row[ci]; // right >>\n                if (this._isValid(g00) && this._isValid(g10) && (row = this.grid[cj])) {\n                    // lower row vv\n                    var g01 = row[fi]; // << left\n                    var g11 = row[ci]; // right >>\n                    if (this._isValid(g01) && this._isValid(g11)) {\n                        return [g00, g10, g01, g11]; // 4 values found!\n                    }\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Nearest value at lon-lat coordinates\n         * @param   {Number} longitude\n         * @param   {Number} latitude\n         * @returns {Vector|Number}\n         */\n\n    }, {\n        key: 'valueAt',\n        value: function valueAt(lon, lat) {\n            if (this.notContains(lon, lat)) return null;\n\n            var _getDecimalIndexes4 = this._getDecimalIndexes(lon, lat),\n                _getDecimalIndexes5 = _slicedToArray(_getDecimalIndexes4, 2),\n                i = _getDecimalIndexes5[0],\n                j = _getDecimalIndexes5[1];\n\n            var ii = Math.floor(i);\n            var jj = Math.floor(j);\n\n            var ci = this._clampColumnIndex(ii);\n            var cj = this._clampRowIndex(jj);\n\n            var value = this._valueAtIndexes(ci, cj);\n            if (this._inFilter) {\n                if (!this._inFilter(value)) return null;\n            }\n\n            return value;\n        }\n\n        /**\n         * Returns whether or not the field has a value at the point\n         * @param   {Number} lon - longitude\n         * @param   {Number} lat - latitude\n         * @returns {Boolean}\n         */\n\n    }, {\n        key: 'hasValueAt',\n        value: function hasValueAt(lon, lat) {\n            var value = this.valueAt(lon, lat);\n            var hasValue = value !== null;\n\n            var included = true;\n            if (this._inFilter) {\n                included = this._inFilter(value);\n            }\n            return hasValue && included;\n        }\n\n        /**\n         * Returns if the grid has no value at the point\n         * @param   {Number} lon - longitude\n         * @param   {Number} lat - latitude\n         * @returns {Boolean}\n         */\n\n    }, {\n        key: 'notHasValueAt',\n        value: function notHasValueAt(lon, lat) {\n            return !this.hasValueAt(lon, lat);\n        }\n\n        /**\n         * Gives a random position to 'o' inside the grid\n         * @param {Object} [o] - an object (eg. a particle)\n         * @returns {{x: Number, y: Number}} - object with x, y (lon, lat)\n         */\n\n    }, {\n        key: 'randomPosition',\n        value: function randomPosition() {\n            var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            var i = Math.random() * this.nCols | 0;\n            var j = Math.random() * this.nRows | 0;\n\n            o.x = this._longitudeAtX(i);\n            o.y = this._latitudeAtY(j);\n\n            return o;\n        }\n\n        /**\n         * Value for grid indexes\n         * @param   {Number} i - column index (integer)\n         * @param   {Number} j - row index (integer)\n         * @returns {Vector|Number}\n         */\n\n    }, {\n        key: '_valueAtIndexes',\n        value: function _valueAtIndexes(i, j) {\n            return this.grid[j][i]; // <-- j,i !!\n        }\n\n        /**\n         * Lon-Lat for grid indexes\n         * @param   {Number} i - column index (integer)\n         * @param   {Number} j - row index (integer)\n         * @returns {Number[]} [lon, lat]\n         */\n\n    }, {\n        key: '_lonLatAtIndexes',\n        value: function _lonLatAtIndexes(i, j) {\n            var lon = this._longitudeAtX(i);\n            var lat = this._latitudeAtY(j);\n\n            return [lon, lat];\n        }\n\n        /**\n         * Longitude for grid-index\n         * @param   {Number} i - column index (integer)\n         * @returns {Number} longitude at the center of the cell\n         */\n\n    }, {\n        key: '_longitudeAtX',\n        value: function _longitudeAtX(i) {\n            var halfXPixel = this.cellXSize / 2.0;\n            var lon = this.xllCorner + halfXPixel + i * this.cellXSize;\n            if (this.longitudeNeedsToBeWrapped) {\n                lon = lon > 180 ? lon - 360 : lon;\n            }\n            return lon;\n        }\n\n        /**\n         * Latitude for grid-index\n         * @param   {Number} j - row index (integer)\n         * @returns {Number} latitude at the center of the cell\n         */\n\n    }, {\n        key: '_latitudeAtY',\n        value: function _latitudeAtY(j) {\n            var halfYPixel = this.cellYSize / 2.0;\n            return this.yurCorner - halfYPixel - j * this.cellYSize;\n        }\n\n        /**\n         * Apply the interpolation\n         * @abstract\n         * @private\n         */\n        /* eslint-disable no-unused-vars */\n\n    }, {\n        key: '_doInterpolation',\n        value: function _doInterpolation(x, y, g00, g10, g01, g11) {\n            throw new TypeError('Must be overriden');\n        }\n        /* eslint-disable no-unused-vars */\n\n        /**\n         * Check the column index is inside the field,\n         * adjusting to min or max when needed\n         * @private\n         * @param   {Number} ii - index\n         * @returns {Number} i - inside the allowed indexes\n         */\n\n    }, {\n        key: '_clampColumnIndex',\n        value: function _clampColumnIndex(ii) {\n            var i = ii;\n            if (ii < 0) {\n                i = 0;\n            }\n            var maxCol = this.nCols - 1;\n            if (ii > maxCol) {\n                i = maxCol;\n            }\n            return i;\n        }\n\n        /**\n         * Check the row index is inside the field,\n         * adjusting to min or max when needed\n         * @private\n         * @param   {Number} jj index\n         * @returns {Number} j - inside the allowed indexes\n         */\n\n    }, {\n        key: '_clampRowIndex',\n        value: function _clampRowIndex(jj) {\n            var j = jj;\n            if (jj < 0) {\n                j = 0;\n            }\n            var maxRow = this.nRows - 1;\n            if (jj > maxRow) {\n                j = maxRow;\n            }\n            return j;\n        }\n\n        /**\n         * Is valid (not 'null' nor 'undefined')\n         * @private\n         * @param   {Object} x object\n         * @returns {Boolean}\n         */\n\n    }, {\n        key: '_isValid',\n        value: function _isValid(x) {\n            return x !== null && x !== undefined;\n        }\n    }]);\n\n    return Field;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Field);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Field__ = __webpack_require__(1);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n/**\n * Scalar Field\n */\n\nvar ScalarField = function (_Field) {\n    _inherits(ScalarField, _Field);\n\n    _createClass(ScalarField, null, [{\n        key: 'fromASCIIGrid',\n\n        /**\n         * Creates a ScalarField from the content of an ASCIIGrid file\n         * @param   {String}   asc\n         * @returns {ScalarField}\n         */\n        value: function fromASCIIGrid(asc) {\n            var scaleFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n            //console.time('ScalarField from ASC');\n\n            var lines = asc.split('\\n');\n\n            // Header\n            var header = ScalarField._parseASCIIGridHeader(lines.slice(0, 6));\n\n            // Data (left-right and top-down)\n            var zs = [];\n            for (var i = 6; i < lines.length; i++) {\n                var line = lines[i].trim();\n                if (line === '') break;\n\n                var items = line.split(' ');\n                items.forEach(function (it) {\n                    var floatItem = parseFloat(it);\n                    var v = floatItem !== header.noDataValue ? floatItem * scaleFactor : null;\n                    zs.push(v);\n                });\n            }\n            var p = header;\n            p.zs = zs;\n\n            //console.timeEnd('ScalarField from ASC');\n            return new ScalarField(p);\n        }\n\n        /**\n         * Parse an ASCII Grid header, made with 6 lines\n         * It allows the use of XLLCORNER/YLLCORNER or XLLCENTER/YLLCENTER conventions\n         * @param {Array.String} headerLines\n         */\n\n    }, {\n        key: '_parseASCIIGridHeader',\n        value: function _parseASCIIGridHeader(headerLines) {\n            try {\n                var headerItems = headerLines.map(function (line) {\n                    var items = line.split(' ').filter(function (i) {\n                        return i != '';\n                    });\n                    var param = items[0].trim().toUpperCase();\n                    var value = parseFloat(items[1].trim());\n                    return _defineProperty({}, param, value);\n                });\n\n                var usesCorner = 'XLLCORNER' in headerItems[2];\n                var cellSize = headerItems[4]['CELLSIZE'];\n\n                var header = {\n                    nCols: parseInt(headerItems[0]['NCOLS']),\n                    nRows: parseInt(headerItems[1]['NROWS']),\n                    xllCorner: usesCorner ? headerItems[2]['XLLCORNER'] : headerItems[2]['XLLCENTER'] - cellSize,\n                    yllCorner: usesCorner ? headerItems[3]['YLLCORNER'] : headerItems[3]['YLLCENTER'] - cellSize,\n                    cellXSize: cellSize,\n                    cellYSize: cellSize,\n                    noDataValue: headerItems[5]['NODATA_VALUE']\n                };\n                return header;\n            } catch (err) {\n                throw new Error('Not a valid ASCIIGrid Header: ' + err);\n            }\n        }\n\n        /**\n         * Creates a ScalarField from the content of a GeoTIFF file\n         * @param   {ArrayBuffer}   data\n         * @param   {Number}   bandIndex\n         * @returns {ScalarField}\n         */\n\n    }, {\n        key: 'fromGeoTIFF',\n        value: function fromGeoTIFF(data) {\n            var bandIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n            return ScalarField.multipleFromGeoTIFF(data, [bandIndex])[0];\n        }\n\n        /**\n         * Creates a ScalarField array (one per band) from the content of a GeoTIFF file\n         * @param   {ArrayBuffer}   data\n         * @param   {Array}   bandIndexes - if not provided all bands are returned\n         * @returns {Array.<ScalarField>}\n         */\n\n    }, {\n        key: 'multipleFromGeoTIFF',\n        value: function multipleFromGeoTIFF(data, bandIndexes) {\n            //console.time('ScalarField from GeoTIFF');\n\n            var tiff = GeoTIFF.parse(data); // geotiff.js\n            var image = tiff.getImage();\n            var rasters = image.readRasters();\n            var tiepoint = image.getTiePoints()[0];\n            var fileDirectory = image.getFileDirectory();\n\n            var _fileDirectory$ModelP = _slicedToArray(fileDirectory.ModelPixelScale, 2),\n                xScale = _fileDirectory$ModelP[0],\n                yScale = _fileDirectory$ModelP[1];\n\n            if (typeof bandIndexes === 'undefined' || bandIndexes.length === 0) {\n                bandIndexes = [].concat(_toConsumableArray(Array(rasters.length).keys()));\n            }\n\n            var scalarFields = [];\n            scalarFields = bandIndexes.map(function (bandIndex) {\n                var zs = rasters[bandIndex]; // left-right and top-down order\n\n                if (fileDirectory.GDAL_NODATA) {\n                    var noData = parseFloat(fileDirectory.GDAL_NODATA);\n                    // console.log(noData);\n                    var simpleZS = Array.from(zs); // to simple array, so null is allowed | TODO efficiency??\n                    zs = simpleZS.map(function (z) {\n                        return z === noData ? null : z;\n                    });\n                }\n\n                var p = {\n                    nCols: image.getWidth(),\n                    nRows: image.getHeight(),\n                    xllCorner: tiepoint.x,\n                    yllCorner: tiepoint.y - image.getHeight() * yScale,\n                    cellXSize: xScale,\n                    cellYSize: yScale,\n                    zs: zs\n                };\n                return new ScalarField(p);\n            });\n\n            //console.timeEnd('ScalarField from GeoTIFF');\n            return scalarFields;\n        }\n    }]);\n\n    function ScalarField(params) {\n        _classCallCheck(this, ScalarField);\n\n        var _this = _possibleConstructorReturn(this, (ScalarField.__proto__ || Object.getPrototypeOf(ScalarField)).call(this, params));\n\n        _this.zs = params['zs'];\n\n        _this.grid = _this._buildGrid();\n        _this._updateRange();\n        //console.log(`ScalarField created (${this.nCols} x ${this.nRows})`);\n        return _this;\n    }\n\n    /**\n     * Builds a grid with a Number at each point, from an array\n     * 'zs' following x-ascending & y-descending order\n     * (same as in ASCIIGrid)\n     * @private\n     * @returns {Array.<Array.<Number>>} - grid[row][column]--> Number\n     */\n\n\n    _createClass(ScalarField, [{\n        key: '_buildGrid',\n        value: function _buildGrid() {\n            var grid = this._arrayTo2d(this.zs, this.nRows, this.nCols);\n            return grid;\n        }\n    }, {\n        key: '_arrayTo2d',\n        value: function _arrayTo2d(array, nRows, nCols) {\n            var grid = [];\n            var p = 0;\n            for (var j = 0; j < nRows; j++) {\n                var row = [];\n                for (var i = 0; i < nCols; i++, p++) {\n                    var z = array[p];\n                    row[i] = this._isValid(z) ? z : null; // <<<\n                }\n                grid[j] = row;\n            }\n            return grid;\n        }\n    }, {\n        key: '_newDataArrays',\n        value: function _newDataArrays(params) {\n            params['zs'] = [];\n        }\n    }, {\n        key: '_pushValueToArrays',\n        value: function _pushValueToArrays(params, value) {\n            params['zs'].push(value);\n        }\n    }, {\n        key: '_makeNewFrom',\n        value: function _makeNewFrom(params) {\n            return new ScalarField(params);\n        }\n\n        /**\n         * Calculate min & max values\n         * @private\n         * @returns {Array} - [min, max]\n         */\n\n    }, {\n        key: '_calculateRange',\n        value: function _calculateRange() {\n            var data = this.zs;\n            if (this._inFilter) {\n                data = data.filter(this._inFilter);\n            }\n            return [d3.min(data), d3.max(data)];\n        }\n\n        /**\n         * Bilinear interpolation for Number\n         * https://en.wikipedia.org/wiki/Bilinear_interpolation\n         * @param   {Number} x\n         * @param   {Number} y\n         * @param   {Number} g00\n         * @param   {Number} g10\n         * @param   {Number} g01\n         * @param   {Number} g11\n         * @returns {Number}\n         */\n\n    }, {\n        key: '_doInterpolation',\n        value: function _doInterpolation(x, y, g00, g10, g01, g11) {\n            var rx = 1 - x;\n            var ry = 1 - y;\n            return g00 * rx * ry + g10 * x * ry + g01 * rx * y + g11 * x * y;\n        }\n    }]);\n\n    return ScalarField;\n}(__WEBPACK_IMPORTED_MODULE_0__Field__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ScalarField);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *  2D Vector\n */\nvar Vector = function () {\n    function Vector(u, v) {\n        _classCallCheck(this, Vector);\n\n        this.u = u;\n        this.v = v;\n    }\n\n    /**\n     * Magnitude\n     * @returns {Number}\n     */\n\n\n    _createClass(Vector, [{\n        key: \"magnitude\",\n        value: function magnitude() {\n            return Math.sqrt(this.u * this.u + this.v * this.v);\n        }\n\n        /**\n         * Angle in degrees (0 to 360) --> Towards\n         * N is 0 and E is 90\n         * @returns {Number}\n         */\n\n    }, {\n        key: \"directionTo\",\n        value: function directionTo() {\n            var verticalAngle = Math.atan2(this.u, this.v);\n            var inDegrees = verticalAngle * (180.0 / Math.PI);\n            if (inDegrees < 0) {\n                inDegrees = inDegrees + 360.0;\n            }\n            return inDegrees;\n        }\n\n        /**\n         * Angle in degrees (0 to 360) From x-->\n         * N is 0 and E is 90\n         * @returns {Number}\n         */\n\n    }, {\n        key: \"directionFrom\",\n        value: function directionFrom() {\n            var a = this.directionTo();\n            var opposite = (a + 180.0) % 360.0;\n            return opposite;\n        }\n\n        /*\n            Degrees --> text\n            new Dictionary<int, string>\n            {\n                //{0, 23, 45, 68, 90, 113, 135, 158, 180, 203, 225, 248, 270, 293, 315, 338, 360};\n                {0, 'N'},\n                {23, 'NNE'},\n                {45, 'NE'},\n                {68, 'ENE'},\n                {90, 'E'},\n                {113, 'ESE'},\n                {135, 'SE'},\n                {158, 'SSE'},\n                {180, 'S'},\n                {203, 'SSW'},\n                {225, 'SW'},\n                {248, 'WSW'},\n                {270, 'W'},\n                {293, 'WNW'},\n                {315, 'NW'},\n                {338, 'NNW'},\n                {360, 'N'}\n            };\n        */\n\n    }]);\n\n    return Vector;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vector);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Vector__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Field__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ScalarField__ = __webpack_require__(2);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n/**\n *  A set of vectors assigned to a regular 2D-grid (lon-lat)\n *  (e.g. a raster representing winds for a region)\n */\n\nvar VectorField = function (_Field) {\n    _inherits(VectorField, _Field);\n\n    _createClass(VectorField, null, [{\n        key: 'fromASCIIGrids',\n\n        /**\n         * Creates a VectorField from the content of two ASCIIGrid files\n         * @param   {String} ascU - with u-component\n         * @param   {String} ascV - with v-component\n         * @returns {VectorField}\n         */\n        value: function fromASCIIGrids(ascU, ascV) {\n            var scaleFactor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n            var u = __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */].fromASCIIGrid(ascU, scaleFactor);\n            var v = __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */].fromASCIIGrid(ascV, scaleFactor);\n            var p = VectorField._paramsFromScalarFields(u, v);\n\n            return new VectorField(p);\n        }\n\n        /**\n         * Creates a VectorField from the content of two different Geotiff files\n         * @param   {ArrayBuffer} gtU - geotiff data with u-component (band 0)\n         * @param   {ArrayBuffer} gtV - geotiff data with v-component (band 0)\n         * @returns {VectorField}\n         */\n\n    }, {\n        key: 'fromGeoTIFFs',\n        value: function fromGeoTIFFs(gtU, gtV) {\n            var u = __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */].fromGeoTIFF(gtU);\n            var v = __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */].fromGeoTIFF(gtV);\n            var p = VectorField._paramsFromScalarFields(u, v);\n\n            return new VectorField(p);\n        }\n\n        /**\n         * Creates a VectorField from the content of Multiband Geotiff\n         * @param   {ArrayBuffer} geotiffData - multiband\n         * @param   {Array} bandIndexesForUV\n         * @returns {VectorField}\n         */\n\n    }, {\n        key: 'fromMultibandGeoTIFF',\n        value: function fromMultibandGeoTIFF(geotiffData) {\n            var bandIndexesForUV = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 1];\n\n            var _ScalarField$multiple = __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */].multipleFromGeoTIFF(geotiffData, bandIndexesForUV),\n                _ScalarField$multiple2 = _slicedToArray(_ScalarField$multiple, 2),\n                u = _ScalarField$multiple2[0],\n                v = _ScalarField$multiple2[1];\n\n            var p = VectorField._paramsFromScalarFields(u, v);\n\n            return new VectorField(p);\n        }\n\n        /**\n         * Build parameters for VectorField, from 2 ScalarFields.\n         * No validation at all (nor interpolation) is applied, so u and v\n         * must be 'compatible' from the source\n         * @param   {ScalarField} u\n         * @param   {ScalarField} v\n         * @returns {Object} - parameters to build VectorField\n         */\n\n    }, {\n        key: '_paramsFromScalarFields',\n        value: function _paramsFromScalarFields(u, v) {\n            // TODO check u & v compatibility (cellSize...)\n            var p = {\n                nCols: u.nCols,\n                nRows: u.nRows,\n                xllCorner: u.xllCorner,\n                yllCorner: u.yllCorner,\n                cellXSize: u.cellXSize,\n                cellYSize: u.cellYSize,\n                us: u.zs,\n                vs: v.zs\n            };\n            return p;\n        }\n    }]);\n\n    function VectorField(params) {\n        _classCallCheck(this, VectorField);\n\n        var _this = _possibleConstructorReturn(this, (VectorField.__proto__ || Object.getPrototypeOf(VectorField)).call(this, params));\n\n        _this.us = params['us'];\n        _this.vs = params['vs'];\n        _this.grid = _this._buildGrid();\n        _this.range = _this._calculateRange();\n        return _this;\n    }\n\n    /**\n     * Get a derived field, from a computation on\n     * the VectorField\n     * @param   {String} type ['magnitude' | 'directionTo' | 'directionFrom']\n     * @returns {ScalarField}\n     */\n\n\n    _createClass(VectorField, [{\n        key: 'getScalarField',\n        value: function getScalarField(type) {\n            var f = this._getFunctionFor(type);\n            var p = {\n                nCols: this.params.nCols,\n                nRows: this.params.nRows,\n                xllCorner: this.params.xllCorner,\n                yllCorner: this.params.yllCorner,\n                cellXSize: this.params.cellXSize,\n                cellYSize: this.params.cellYSize,\n                zs: this._applyOnField(f)\n            };\n            return new __WEBPACK_IMPORTED_MODULE_2__ScalarField__[\"a\" /* default */](p);\n        }\n    }, {\n        key: '_getFunctionFor',\n        value: function _getFunctionFor(type) {\n            return function (u, v) {\n                var uv = new __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* default */](u, v);\n                return uv[type](); // magnitude, directionTo, directionFrom\n            };\n        }\n    }, {\n        key: '_applyOnField',\n        value: function _applyOnField(func) {\n            var zs = [];\n            var n = this.numCells();\n            for (var i = 0; i < n; i++) {\n                var u = this.us[i];\n                var v = this.vs[i];\n                if (this._isValid(u) && this._isValid(v)) {\n                    zs.push(func(u, v));\n                } else {\n                    zs.push(null);\n                }\n            }\n            return zs;\n        }\n\n        /**\n         * Builds a grid with a Vector at each point, from two arrays\n         * 'us' and 'vs' following x-ascending & y-descending order\n         * (same as in ASCIIGrid)\n         * @returns {Array.<Array.<Vector>>} - grid[row][column]--> Vector\n         */\n\n    }, {\n        key: '_buildGrid',\n        value: function _buildGrid() {\n            var grid = this._arraysTo2d(this.us, this.vs, this.nRows, this.nCols);\n            return grid;\n        }\n    }, {\n        key: '_arraysTo2d',\n        value: function _arraysTo2d(us, vs, nRows, nCols) {\n            var grid = [];\n            var p = 0;\n\n            for (var j = 0; j < nRows; j++) {\n                var row = [];\n                for (var i = 0; i < nCols; i++, p++) {\n                    var u = us[p],\n                        v = vs[p];\n                    var valid = this._isValid(u) && this._isValid(v);\n                    row[i] = valid ? new __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* default */](u, v) : null; // <<<\n                }\n                grid[j] = row;\n            }\n            return grid;\n        }\n    }, {\n        key: '_newDataArrays',\n        value: function _newDataArrays(params) {\n            params['us'] = [];\n            params['vs'] = [];\n        }\n    }, {\n        key: '_pushValueToArrays',\n        value: function _pushValueToArrays(params, value) {\n            //console.log(value);\n            params['us'].push(value.u);\n            params['vs'].push(value.v);\n        }\n    }, {\n        key: '_makeNewFrom',\n        value: function _makeNewFrom(params) {\n            return new VectorField(params);\n        }\n\n        /**\n         * Calculate min & max values (magnitude)\n         * @private\n         * @returns {Array}\n         */\n\n    }, {\n        key: '_calculateRange',\n        value: function _calculateRange() {\n            // TODO make a clearer method for getting these vectors...\n            var vectors = this.getCells().map(function (pt) {\n                return pt.value;\n            }).filter(function (v) {\n                return v !== null;\n            });\n\n            if (this._inFilter) {\n                vectors = vectors.filter(this._inFilter);\n            }\n\n            // TODO check memory crash with high num of vectors!\n            var magnitudes = vectors.map(function (v) {\n                return v.magnitude();\n            });\n            var min = d3.min(magnitudes);\n            var max = d3.max(magnitudes);\n\n            return [min, max];\n        }\n\n        /**\n         * Bilinear interpolation for Vector\n         * https://en.wikipedia.org/wiki/Bilinear_interpolation\n         * @param   {Number} x\n         * @param   {Number} y\n         * @param   {Number[]} g00\n         * @param   {Number[]} g10\n         * @param   {Number[]} g01\n         * @param   {Number[]} g11\n         * @returns {Vector}\n         */\n\n    }, {\n        key: '_doInterpolation',\n        value: function _doInterpolation(x, y, g00, g10, g01, g11) {\n            var rx = 1 - x;\n            var ry = 1 - y;\n            var a = rx * ry,\n                b = x * ry,\n                c = rx * y,\n                d = x * y;\n            var u = g00.u * a + g10.u * b + g01.u * c + g11.u * d;\n            var v = g00.v * a + g10.v * b + g01.v * c + g11.v * d;\n            return new __WEBPACK_IMPORTED_MODULE_0__Vector__[\"a\" /* default */](u, v);\n        }\n\n        /**\n         * Is valid (not 'null' nor 'undefined')\n         * @private\n         * @param   {Object} x object\n         * @returns {Boolean}\n         */\n\n    }, {\n        key: '_isValid',\n        value: function _isValid(x) {\n            return x !== null && x !== undefined;\n        }\n    }]);\n\n    return VectorField;\n}(__WEBPACK_IMPORTED_MODULE_1__Field__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (VectorField);\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n/**\n *   Control for a simple legend with a colorbar\n *   References:\n *      - http://jsfiddle.net/ramnathv/g8stqcf6/\n *      - http://jsfiddle.net/vis4/cYLZH/\n */\nL.Control.ColorBar = L.Control.extend({\n    options: {\n        position: 'bottomleft',\n        width: 300, // for colorbar itself (control is wider)\n        height: 15,\n        margin: 15,\n        background: '#fff',\n        textColor: 'black',\n        steps: 100,\n        decimals: 2,\n        units: 'uds', // ej: m/s\n        title: 'Legend', // ej: Ocean Currents\n        labels: [], // empty for no labels\n        labelFontSize: 10,\n        labelTextPosition: 'middle' // start | middle | end\n    },\n\n    initialize: function initialize(color, range, options) {\n        this.color = color; // 'chromajs' scale function\n        this.range = range; // [min, max]\n        L.Util.setOptions(this, options);\n    },\n\n    onAdd: function onAdd(map) {\n        this._map = map;\n        var div = L.DomUtil.create('div', 'leaflet-control-colorBar leaflet-bar leaflet-control');\n        div.style.padding = '10px';\n\n        L.DomEvent.addListener(div, 'click', L.DomEvent.stopPropagation).addListener(div, 'click', L.DomEvent.preventDefault);\n        div.style.backgroundColor = this.options.background;\n        div.style.cursor = 'text';\n        div.innerHTML = this.title() + this.palette();\n        return div;\n    },\n\n    title: function title() {\n        var d = document.createElement('div');\n        d3.select(d).append('span').style('color', this.options.textColor).style('display', 'block').style('margin-bottom', '5px').attr('class', 'leaflet-control-colorBar-title').text(this.options.title);\n        return d.innerHTML;\n    },\n\n    palette: function palette() {\n        var d = document.createElement('div');\n        var svg = this._createSvgIn(d);\n\n        this._appendColorBarTo(svg);\n\n        if (this.options.labels) {\n            this._appendLabelsTo(svg);\n        }\n\n        return d.innerHTML;\n    },\n\n    _createSvgIn: function _createSvgIn(d) {\n        var spaceForLabels = this.options.labels ? this.options.margin : 0;\n        var svg = d3.select(d).append('svg').attr('width', this.options.width + this.options.margin * 2).attr('height', this.options.height + spaceForLabels);\n        return svg;\n    },\n\n    _appendColorBarTo: function _appendColorBarTo(svg) {\n        var _this = this;\n\n        var colorPerValue = this._getColorPerValue();\n        var w = this.options.width / colorPerValue.length;\n\n        var groupBars = svg.append('g').attr('id', 'colorBar-buckets');\n        var buckets = groupBars.selectAll('rect').data(colorPerValue).enter().append('rect');\n        buckets.attr('x', function (d, i) {\n            return i * w + _this.options.margin;\n        }).attr('y', function () {\n            return 0;\n        }).attr('height', function () {\n            return _this.options.height;\n        } /*w * 4*/).attr('width', function () {\n            return w;\n        }).attr('stroke-width', 2).attr('stroke-linecap', 'butt').attr('stroke', function (d) {\n            return d.color.hex();\n        }).attr('fill', function (d) {\n            return d.color.hex();\n        });\n        buckets.append('title').text(function (d) {\n            return d.value.toFixed(_this.options.decimals) + ' ' + _this.options.units;\n        });\n    },\n\n    _appendLabelsTo: function _appendLabelsTo(svg) {\n        var _this2 = this;\n\n        var positionPerLabelValue = this._getPositionPerLabelValue();\n        //const w = this.options.width / colorPerValue.length;\n        var groupLabels = svg.append('g').attr('id', 'colorBar-labels');\n        var labels = groupLabels.selectAll('text').data(positionPerLabelValue).enter().append('text');\n        labels.attr('x', function (d) {\n            return d.position + _this2.options.margin;\n        }).attr('y', this.options.height + this.options.margin).attr('font-size', this.options.labelFontSize + 'px').attr('text-anchor', this.options.labelTextPosition).attr('fill', this.options.textColor).attr('class', 'leaflet-control-colorBar-label').text(function (d) {\n            return '' + d.value.toFixed(_this2.options.decimals);\n        });\n    },\n\n    _getColorPerValue: function _getColorPerValue() {\n        var _this3 = this;\n\n        var _range = _slicedToArray(this.range, 2),\n            min = _range[0],\n            max = _range[1];\n\n        var delta = (max - min) / this.options.steps;\n        var data = d3.range(min, max + delta, delta);\n        var colorPerValue = data.map(function (d) {\n            return {\n                value: d,\n                color: _this3.color(d)\n            };\n        });\n        return colorPerValue;\n    },\n\n    _getPositionPerLabelValue: function _getPositionPerLabelValue() {\n        var xPositionFor = d3.scaleLinear().range([0, this.options.width]).domain(this.range);\n        var data = this.options.labels;\n        var positionPerLabel = data.map(function (d) {\n            return {\n                value: d,\n                position: xPositionFor(d)\n            };\n        });\n        return positionPerLabel;\n    }\n});\n\nL.control.colorBar = function (color, range, options) {\n    return new L.Control.ColorBar(color, range, options);\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n/**\n * Abstract class for a Field layer on canvas, aka 'a Raster layer'\n * (ScalarField or a VectorField)\n */\nL.CanvasLayer.Field = L.CanvasLayer.extend({\n    options: {\n        mouseMoveCursor: {\n            value: 'pointer',\n            noValue: 'default'\n        },\n        opacity: 1,\n        onClick: null,\n        onMouseMove: null,\n        inFilter: null\n    },\n\n    initialize: function initialize(field, options) {\n        L.Util.setOptions(this, options);\n        this._visible = true;\n        if (field) {\n            this.setData(field);\n        }\n    },\n\n    getEvents: function getEvents() {\n        var events = L.CanvasLayer.prototype.getEvents.call(this);\n        events.zoomstart = this._hideCanvas.bind(this);\n        events.zoomend = this._showCanvas.bind(this);\n        return events;\n    },\n\n    onLayerDidMount: function onLayerDidMount() {\n        this._enableIdentify();\n        this._ensureCanvasAlignment();\n    },\n\n    show: function show() {\n        this._visible = true;\n        this._showCanvas();\n        this._enableIdentify();\n    },\n    hide: function hide() {\n        this._visible = false;\n        this._hideCanvas();\n        this._disableIdentify();\n    },\n    isVisible: function isVisible() {\n        return this._visible;\n    },\n    _showCanvas: function _showCanvas() {\n        if (this._canvas && this._visible) {\n            this._canvas.style.visibility = 'visible';\n        }\n    },\n    _hideCanvas: function _hideCanvas() {\n        if (this._canvas) {\n            this._canvas.style.visibility = 'hidden';\n        }\n    },\n    _enableIdentify: function _enableIdentify() {\n        this._map.on('click', this._onClick, this);\n        this._map.on('mousemove', this._onMouseMove, this);\n\n        this.options.onClick && this.on('click', this.options.onClick, this);\n        this.options.onMouseMove && this.on('mousemove', this.options.onMouseMove, this);\n    },\n    _disableIdentify: function _disableIdentify() {\n        this._map.off('click', this._onClick, this);\n        this._map.off('mousemove', this._onMouseMove, this);\n\n        this.options.onClick && this.off('click', this.options.onClick, this);\n        this.options.onMouseMove && this.off('mousemove', this.options.onMouseMove, this);\n    },\n    _ensureCanvasAlignment: function _ensureCanvasAlignment() {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n    },\n\n\n    onLayerWillUnmount: function onLayerWillUnmount() {\n        this._disableIdentify();\n    },\n\n    needRedraw: function needRedraw() {\n        if (this._map && this._field) {\n            L.CanvasLayer.prototype.needRedraw.call(this);\n        }\n    },\n\n\n    /* eslint-disable no-unused-vars */\n    onDrawLayer: function onDrawLayer(viewInfo) {\n        throw new TypeError('Must be overriden');\n    },\n    /* eslint-enable no-unused-vars */\n\n    setData: function setData(field) {\n        this.options.inFilter && field.setFilter(this.options.inFilter);\n        this._field = field;\n        this.needRedraw();\n        this.fire('load');\n    },\n\n    setFilter: function setFilter(f) {\n        this.options.inFilter = f;\n        this._field && this._field.setFilter(f);\n        this.needRedraw();\n    },\n\n    setOpacity: function setOpacity(opacity) {\n        this.options.opacity = opacity;\n\n        if (this._canvas) {\n            this._updateOpacity();\n        }\n        return this;\n    },\n\n    getBounds: function getBounds() {\n        var bb = this._field.extent();\n\n        var southWest = L.latLng(bb[1], bb[0]),\n            northEast = L.latLng(bb[3], bb[2]);\n        var bounds = L.latLngBounds(southWest, northEast);\n        return bounds;\n    },\n\n    _onClick: function _onClick(e) {\n        var v = this._queryValue(e);\n        this.fire('click', v);\n    },\n\n    _onMouseMove: function _onMouseMove(e) {\n        var v = this._queryValue(e);\n        this._changeCursorOn(v);\n        this.fire('mousemove', v);\n    },\n\n    _changeCursorOn: function _changeCursorOn(v) {\n        if (!this.options.mouseMoveCursor) return;\n\n        var _options$mouseMoveCur = this.options.mouseMoveCursor,\n            value = _options$mouseMoveCur.value,\n            noValue = _options$mouseMoveCur.noValue;\n\n        var style = this._map.getContainer().style;\n        style.cursor = v.value !== null ? value : noValue;\n    },\n\n    _updateOpacity: function _updateOpacity() {\n        L.DomUtil.setOpacity(this._canvas, this.options.opacity);\n    },\n\n    _queryValue: function _queryValue(e) {\n        var v = this._field ? this._field.valueAt(e.latlng.lng, e.latlng.lat) : null;\n        var result = {\n            latlng: e.latlng,\n            value: v\n        };\n        return result;\n    },\n\n    _getDrawingContext: function _getDrawingContext() {\n        var g = this._canvas.getContext('2d');\n        g.clearRect(0, 0, this._canvas.width, this._canvas.height);\n        return g;\n    }\n});\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Cell__ = __webpack_require__(0);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n\n\n/**\n * ScalarField on canvas (a 'Raster')\n */\nL.CanvasLayer.ScalarField = L.CanvasLayer.Field.extend({\n    options: {\n        type: 'colormap', // [colormap|vector]\n        color: null, // function colorFor(value) [e.g. chromajs.scale],\n        interpolate: false, // Change to use interpolation\n        vectorSize: 20, // only used if 'vector'\n        arrowDirection: 'from' // [from|towards]\n    },\n\n    initialize: function initialize(scalarField, options) {\n        L.CanvasLayer.Field.prototype.initialize.call(this, scalarField, options);\n        L.Util.setOptions(this, options);\n    },\n\n    _defaultColorScale: function _defaultColorScale() {\n        return chroma.scale(['white', 'black']).domain(this._field.range);\n    },\n\n    setColor: function setColor(f) {\n        this.options.color = f;\n        this.needRedraw();\n    },\n\n\n    /* eslint-disable no-unused-vars */\n    onDrawLayer: function onDrawLayer(viewInfo) {\n        if (!this.isVisible()) return;\n        this._updateOpacity();\n\n        var r = this._getRendererMethod();\n        //console.time('onDrawLayer');\n        r();\n        //console.timeEnd('onDrawLayer');\n    },\n    /* eslint-enable no-unused-vars */\n\n    _getRendererMethod: function _getRendererMethod() {\n        switch (this.options.type) {\n            case 'colormap':\n                return this._drawImage.bind(this);\n            case 'vector':\n                return this._drawArrows.bind(this);\n            default:\n                throw Error('Unkwown renderer type: ' + this.options.type);\n        }\n    },\n\n    _ensureColor: function _ensureColor() {\n        if (this.options.color === null) {\n            this.setColor(this._defaultColorScale());\n        }\n    },\n\n    _showCanvas: function _showCanvas() {\n        L.CanvasLayer.Field.prototype._showCanvas.call(this);\n        this.needRedraw(); // TODO check spurious redraw (e.g. hide/show without moving map)\n    },\n\n\n    /**\n     * Draws the field in an ImageData and applying it with putImageData.\n     * Used as a reference: http://geoexamples.com/d3-raster-tools-docs/code_samples/raster-pixels-page.html\n     */\n    _drawImage: function _drawImage() {\n        this._ensureColor();\n\n        var ctx = this._getDrawingContext();\n        var width = this._canvas.width;\n        var height = this._canvas.height;\n\n        var img = ctx.createImageData(width, height);\n        var data = img.data;\n\n        this._prepareImageIn(data, width, height);\n        ctx.putImageData(img, 0, 0);\n    },\n\n    /**\n     * Prepares the image in data, as array with RGBAs\n     * [R1, G1, B1, A1, R2, G2, B2, A2...]\n     * @private\n     * @param {[[Type]]} data   [[Description]]\n     * @param {Numver} width\n     * @param {Number} height\n     */\n    _prepareImageIn: function _prepareImageIn(data, width, height) {\n        var f = this.options.interpolate ? 'interpolatedValueAt' : 'valueAt';\n\n        var pos = 0;\n        for (var j = 0; j < height; j++) {\n            for (var i = 0; i < width; i++) {\n                var pointCoords = this._map.containerPointToLatLng([i, j]);\n                var lon = pointCoords.lng;\n                var lat = pointCoords.lat;\n\n                var v = this._field[f](lon, lat); // 'valueAt' | 'interpolatedValueAt' || TODO check some 'artifacts'\n                if (v !== null) {\n                    var color = this._getColorFor(v);\n\n                    var _color$rgba = color.rgba(),\n                        _color$rgba2 = _slicedToArray(_color$rgba, 4),\n                        R = _color$rgba2[0],\n                        G = _color$rgba2[1],\n                        B = _color$rgba2[2],\n                        A = _color$rgba2[3];\n\n                    data[pos] = R;\n                    data[pos + 1] = G;\n                    data[pos + 2] = B;\n                    data[pos + 3] = parseInt(A * 255); // not percent in alpha but hex 0-255\n                }\n                pos = pos + 4;\n            }\n        }\n    },\n\n\n    /**\n     * Draws the field as a set of arrows. Direction from 0 to 360 is assumed.\n     */\n    _drawArrows: function _drawArrows() {\n        var bounds = this._pixelBounds();\n        var pixelSize = (bounds.max.x - bounds.min.x) / this._field.nCols;\n\n        var stride = Math.max(1, Math.floor(1.2 * this.options.vectorSize / pixelSize));\n\n        var ctx = this._getDrawingContext();\n        ctx.strokeStyle = this.options.color;\n\n        var currentBounds = this._map.getBounds();\n\n        for (var y = 0; y < this._field.height; y = y + stride) {\n            for (var x = 0; x < this._field.width; x = x + stride) {\n                var _field$_lonLatAtIndex = this._field._lonLatAtIndexes(x, y),\n                    _field$_lonLatAtIndex2 = _slicedToArray(_field$_lonLatAtIndex, 2),\n                    lon = _field$_lonLatAtIndex2[0],\n                    lat = _field$_lonLatAtIndex2[1];\n\n                var v = this._field.valueAt(lon, lat);\n                var center = L.latLng(lat, lon);\n                if (v !== null && currentBounds.contains(center)) {\n                    var cell = new __WEBPACK_IMPORTED_MODULE_0__Cell__[\"a\" /* default */](center, v, this.cellXSize, this.cellYSize);\n                    this._drawArrow(cell, ctx);\n                }\n            }\n        }\n    },\n\n    _pixelBounds: function _pixelBounds() {\n        var bounds = this.getBounds();\n        var northWest = this._map.latLngToContainerPoint(bounds.getNorthWest());\n        var southEast = this._map.latLngToContainerPoint(bounds.getSouthEast());\n        var pixelBounds = L.bounds(northWest, southEast);\n        return pixelBounds;\n    },\n\n    _drawArrow: function _drawArrow(cell, ctx) {\n        var projected = this._map.latLngToContainerPoint(cell.center);\n\n        // colormap vs. simple color\n        var color = this.options.color;\n        if (typeof color === 'function') {\n            ctx.strokeStyle = color(cell.value);\n        }\n\n        var size = this.options.vectorSize;\n        ctx.save();\n\n        ctx.translate(projected.x, projected.y);\n\n        var rotationRads = (90 + cell.value) * Math.PI / 180; // from, by default\n        if (this.options.arrowDirection === 'towards') {\n            rotationRads = rotationRads + Math.PI;\n        }\n        ctx.rotate(rotationRads);\n\n        ctx.beginPath();\n        ctx.moveTo(-size / 2, 0);\n        ctx.lineTo(+size / 2, 0);\n        ctx.moveTo(size * 0.25, -size * 0.25);\n        ctx.lineTo(+size / 2, 0);\n        ctx.lineTo(size * 0.25, size * 0.25);\n        ctx.stroke();\n        ctx.restore();\n    },\n\n    /**\n     * Gets a chroma color for a pixel value, according to 'options.color'\n     */\n    _getColorFor: function _getColorFor(v) {\n        var c = this.options.color; // e.g. for a constant 'red'\n        if (typeof c === 'function') {\n            c = this.options.color(v);\n        }\n        var color = chroma(c); // to be more flexible, a chroma color object is always created || TODO improve efficiency\n        return color;\n    }\n});\n\nL.canvasLayer.scalarField = function (scalarField, options) {\n    return new L.CanvasLayer.ScalarField(scalarField, options);\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n *  Simple layer with lon-lat points\n *\n *  TODO rename to SimplePoint?\n */\nL.CanvasLayer.SimpleLonLat = L.CanvasLayer.extend({\n    options: {\n        color: 'gray'\n    },\n\n    initialize: function initialize(points, options) {\n        this.points = points;\n        L.Util.setOptions(this, options);\n    },\n\n    onLayerDidMount: function onLayerDidMount() {\n        // -- prepare custom drawing\n    },\n\n    onLayerWillUnmount: function onLayerWillUnmount() {\n        // -- custom cleanup\n    },\n\n    /* eslint-disable no-unused-vars */\n    setData: function setData(data) {\n        // -- custom data set\n        this.needRedraw(); // -- call to drawLayer\n    },\n    /* eslint-enable no-unused-vars */\n\n    onDrawLayer: function onDrawLayer(viewInfo) {\n        // canvas preparation\n        var g = viewInfo.canvas.getContext('2d');\n        g.clearRect(0, 0, viewInfo.canvas.width, viewInfo.canvas.height);\n        g.fillStyle = this.options.color;\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = this.points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var point = _step.value;\n\n                var p = viewInfo.layer._map.latLngToContainerPoint(point);\n                g.beginPath();\n                //g.arc(p.x, p.y, 1, 0, Math.PI * 2); // circle | TODO style 'function' as parameter?\n                g.fillRect(p.x, p.y, 2, 2); //simple point\n                g.fill();\n                g.closePath();\n                g.stroke();\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    },\n\n    getBounds: function getBounds() {\n        // TODO: bounding with points...\n        var xs = this.points.map(function (pt) {\n            return pt.lng;\n        });\n        var ys = this.points.map(function (pt) {\n            return pt.lat;\n        });\n\n        var xmin = Math.min.apply(Math, _toConsumableArray(xs));\n        var ymin = Math.min.apply(Math, _toConsumableArray(ys));\n        var xmax = Math.max.apply(Math, _toConsumableArray(xs));\n        var ymax = Math.max.apply(Math, _toConsumableArray(ys));\n\n        var southWest = L.latLng(ymin, xmin),\n            northEast = L.latLng(ymax, xmax);\n        var bounds = L.latLngBounds(southWest, northEast); // TODO FIX ERROR ? half-pixel?\n        return bounds;\n    }\n});\n\nL.canvasLayer.simpleLonLat = function (lonslats, options) {\n    return new L.CanvasLayer.SimpleLonLat(lonslats, options);\n};\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n/**\n * Animated VectorField on canvas\n */\nL.CanvasLayer.VectorFieldAnim = L.CanvasLayer.Field.extend({\n    options: {\n        paths: 800,\n        color: 'white', // html-color | function colorFor(value) [e.g. chromajs.scale]\n        width: 1.0, // number | function widthFor(value)\n        fade: 0.96, // 0 to 1\n        duration: 20, // milliseconds per 'frame'\n        maxAge: 200, // number of maximum frames per path\n        velocityScale: 1 / 5000\n    },\n\n    initialize: function initialize(vectorField, options) {\n        L.CanvasLayer.Field.prototype.initialize.call(this, vectorField, options);\n        L.Util.setOptions(this, options);\n\n        this.timer = null;\n    },\n\n    onLayerDidMount: function onLayerDidMount() {\n        L.CanvasLayer.Field.prototype.onLayerDidMount.call(this);\n        this._map.on('move resize', this._stopAnimation, this);\n    },\n\n    onLayerWillUnmount: function onLayerWillUnmount() {\n        L.CanvasLayer.Field.prototype.onLayerWillUnmount.call(this);\n        this._map.off('move resize', this._stopAnimation, this);\n        this._stopAnimation();\n    },\n\n    _hideCanvas: function _showCanvas() {\n        L.CanvasLayer.Field.prototype._hideCanvas.call(this);\n        this._stopAnimation();\n    },\n\n    onDrawLayer: function onDrawLayer(viewInfo) {\n        if (!this._field || !this.isVisible()) return;\n\n        this._updateOpacity();\n\n        var ctx = this._getDrawingContext();\n        var paths = this._prepareParticlePaths();\n\n        this.timer = d3.timer(function () {\n            _moveParticles();\n            _drawParticles();\n        }, this.options.duration);\n\n        var self = this;\n\n        /**\n         * Builds the paths, adding 'particles' on each animation step, considering\n         * their properties (age / position source > target)\n         */\n        function _moveParticles() {\n            // let screenFactor = 1 / self._map.getZoom(); // consider using a 'screenFactor' to ponderate velocityScale\n            paths.forEach(function (par) {\n                if (par.age > self.options.maxAge) {\n                    // restart, on a random x,y\n                    par.age = 0;\n                    self._field.randomPosition(par);\n                }\n\n                var vector = self._field.valueAt(par.x, par.y);\n                if (vector === null) {\n                    par.age = self.options.maxAge;\n                } else {\n                    // the next point will be...\n                    var xt = par.x + vector.u * self.options.velocityScale; //* screenFactor;\n                    var yt = par.y + vector.v * self.options.velocityScale; //* screenFactor;\n\n                    if (self._field.hasValueAt(xt, yt)) {\n                        par.xt = xt;\n                        par.yt = yt;\n                        par.m = vector.magnitude();\n                    } else {\n                        // not visible anymore...\n                        par.age = self.options.maxAge;\n                    }\n                }\n                par.age += 1;\n            });\n        }\n\n        /**\n         * Draws the paths on each step\n         */\n        function _drawParticles() {\n            // Previous paths...\n            var prev = ctx.globalCompositeOperation;\n            ctx.globalCompositeOperation = 'destination-in';\n            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n            //ctx.globalCompositeOperation = 'source-over';\n            ctx.globalCompositeOperation = prev;\n\n            // fading paths...\n            ctx.fillStyle = 'rgba(0, 0, 0, ' + self.options.fade + ')';\n            ctx.lineWidth = self.options.width;\n            ctx.strokeStyle = self.options.color;\n\n            // New paths\n            paths.forEach(function (par) {\n                self._drawParticle(viewInfo, ctx, par);\n            });\n        }\n    },\n\n    _drawParticle: function _drawParticle(viewInfo, ctx, par) {\n        var source = new L.latLng(par.y, par.x);\n        var target = new L.latLng(par.yt, par.xt);\n\n        if (viewInfo.bounds.contains(source) && par.age <= this.options.maxAge) {\n            var pA = viewInfo.layer._map.latLngToContainerPoint(source);\n            var pB = viewInfo.layer._map.latLngToContainerPoint(target);\n\n            ctx.beginPath();\n            ctx.moveTo(pA.x, pA.y);\n            ctx.lineTo(pB.x, pB.y);\n\n            // next-step movement\n            par.x = par.xt;\n            par.y = par.yt;\n\n            // colormap vs. simple color\n            var color = this.options.color;\n            if (typeof color === 'function') {\n                ctx.strokeStyle = color(par.m);\n            }\n\n            var width = this.options.width;\n            if (typeof width === 'function') {\n                ctx.lineWidth = width(par.m);\n            }\n\n            ctx.stroke();\n        }\n    },\n\n\n    _prepareParticlePaths: function _prepareParticlePaths() {\n        var paths = [];\n\n        for (var i = 0; i < this.options.paths; i++) {\n            var p = this._field.randomPosition();\n            p.age = this._randomAge();\n            paths.push(p);\n        }\n        return paths;\n    },\n\n    _randomAge: function _randomAge() {\n        return Math.floor(Math.random() * this.options.maxAge);\n    },\n\n    _stopAnimation: function _stopAnimation() {\n        if (this.timer) {\n            this.timer.stop();\n        }\n    }\n});\n\nL.canvasLayer.vectorFieldAnim = function (vectorField, options) {\n    return new L.CanvasLayer.VectorFieldAnim(vectorField, options);\n};\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n/*\n  1.0.1 (downloaded from https://github.com/Sumbera/gLayers.Leaflet/releases/tag/v1.0.1)\n\n  Generic  Canvas Layer for leaflet 0.7 and 1.0-rc,\n  copyright Stanislav Sumbera,  2016 , sumbera.com , license MIT\n  originally created and motivated by L.CanvasOverlay  available here: https://gist.github.com/Sumbera/11114288\n*/\n\nL.CanvasLayer = L.Layer.extend({\n    // -- initialized is called on prototype\n    initialize: function initialize(options) {\n        this._map = null;\n        this._canvas = null;\n        this._frame = null;\n        this._delegate = null;\n        L.setOptions(this, options);\n    },\n\n    delegate: function delegate(del) {\n        this._delegate = del;\n        return this;\n    },\n\n    needRedraw: function needRedraw() {\n        if (!this._frame) {\n            this._frame = L.Util.requestAnimFrame(this.drawLayer, this);\n        }\n        return this;\n    },\n\n    //-------------------------------------------------------------\n    _onLayerDidResize: function _onLayerDidResize(resizeEvent) {\n        this._canvas.width = resizeEvent.newSize.x;\n        this._canvas.height = resizeEvent.newSize.y;\n    },\n    //-------------------------------------------------------------\n    _onLayerDidMove: function _onLayerDidMove() {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n        this.drawLayer();\n    },\n    //-------------------------------------------------------------\n    getEvents: function getEvents() {\n        var events = {\n            resize: this._onLayerDidResize,\n            moveend: this._onLayerDidMove\n        };\n        if (this._map.options.zoomAnimation && L.Browser.any3d) {\n            events.zoomanim = this._animateZoom;\n        }\n\n        return events;\n    },\n    //-------------------------------------------------------------\n    onAdd: function onAdd(map) {\n        this._map = map;\n        this._canvas = L.DomUtil.create('canvas', 'leaflet-layer');\n        this.tiles = {};\n\n        var size = this._map.getSize();\n        this._canvas.width = size.x;\n        this._canvas.height = size.y;\n\n        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\n        L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\n\n        map._panes.overlayPane.appendChild(this._canvas);\n\n        map.on(this.getEvents(), this);\n\n        var del = this._delegate || this;\n        del.onLayerDidMount && del.onLayerDidMount(); // -- callback\n\n        this.needRedraw();\n    },\n\n    //-------------------------------------------------------------\n    onRemove: function onRemove(map) {\n        var del = this._delegate || this;\n        del.onLayerWillUnmount && del.onLayerWillUnmount(); // -- callback\n\n\n        map.getPanes().overlayPane.removeChild(this._canvas);\n\n        map.off(this.getEvents(), this);\n\n        this._canvas = null;\n    },\n\n    //------------------------------------------------------------\n    addTo: function addTo(map) {\n        map.addLayer(this);\n        return this;\n    },\n    // --------------------------------------------------------------------------------\n    LatLonToMercator: function LatLonToMercator(latlon) {\n        return {\n            x: latlon.lng * 6378137 * Math.PI / 180,\n            y: Math.log(Math.tan((90 + latlon.lat) * Math.PI / 360)) * 6378137\n        };\n    },\n\n    //------------------------------------------------------------------------------\n    drawLayer: function drawLayer() {\n        // -- todo make the viewInfo properties  flat objects.\n        var size = this._map.getSize();\n        var bounds = this._map.getBounds();\n        var zoom = this._map.getZoom();\n\n        var center = this.LatLonToMercator(this._map.getCenter());\n        var corner = this.LatLonToMercator(this._map.containerPointToLatLng(this._map.getSize()));\n\n        var del = this._delegate || this;\n        del.onDrawLayer && del.onDrawLayer({\n            layer: this,\n            canvas: this._canvas,\n            bounds: bounds,\n            size: size,\n            zoom: zoom,\n            center: center,\n            corner: corner\n        });\n        this._frame = null;\n    },\n\n    //------------------------------------------------------------------------------\n    _animateZoom: function _animateZoom(e) {\n        var scale = this._map.getZoomScale(e.zoom);\n        var offset = this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), e.zoom, e.center);\n\n        L.DomUtil.setTransform(this._canvas, offset, scale);\n    }\n});\n\nL.canvasLayer = function () {\n    return new L.CanvasLayer();\n};\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar invariant = __webpack_require__(12);\nvar getCoord = invariant.getCoord;\nvar getCoords = invariant.getCoords;\n\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can\n * be convex or concave. The function accounts for holes.\n *\n * @name inside\n * @param {Feature<Point>} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {boolean} [ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.inside(pt, poly);\n * //= true\n */\nmodule.exports = function (point, polygon, ignoreBoundary) {\n    // validation\n    if (!point) throw new Error('point is required');\n    if (!polygon) throw new Error('polygon is required');\n\n    var pt = getCoord(point);\n    var polys = getCoords(polygon);\n    var type = (polygon.geometry) ? polygon.geometry.type : polygon.type;\n    var bbox = polygon.bbox;\n\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) return false;\n\n    // normalize to multipolygon\n    if (type === 'Polygon') polys = [polys];\n\n    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) insidePoly = true;\n        }\n    }\n    return insidePoly;\n};\n\n/**\n * inRing\n *\n * @private\n * @param {[number, number]} pt [x,y]\n * @param {Array<[number, number]>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0], yi = ring[i][1];\n        var xj = ring[j][0], yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) return !ignoreBoundary;\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\n\n/**\n * inBBox\n *\n * @private\n * @param {[number, number]} pt point [x,y]\n * @param {[number, number, number, number]} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n           bbox[1] <= pt[1] &&\n           bbox[2] >= pt[0] &&\n           bbox[3] >= pt[1];\n}\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {string} GeoJSON Geometry Type\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeomType(point)\n * //=\"Point\"\n */\nfunction getGeomType(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    var geom = getGeom(geojson);\n    if (geom) return geom.type;\n}\n\nmodule.exports = {\n    geojsonType: geojsonType,\n    collectionOf: collectionOf,\n    featureOf: featureOf,\n    getCoord: getCoord,\n    getCoords: getCoords,\n    containsNumber: containsNumber,\n    getGeom: getGeom,\n    getGeomType: getGeomType\n};\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Vector_js__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Cell_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Field_js__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ScalarField_js__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__VectorField_js__ = __webpack_require__(4);\n// base\n\nwindow.L.Vector = __WEBPACK_IMPORTED_MODULE_0__Vector_js__[\"a\" /* default */];\n\n\nwindow.L.Cell = __WEBPACK_IMPORTED_MODULE_1__Cell_js__[\"a\" /* default */];\n\n\nwindow.L.Field = __WEBPACK_IMPORTED_MODULE_2__Field_js__[\"a\" /* default */];\n\n\nwindow.L.ScalarField = __WEBPACK_IMPORTED_MODULE_3__ScalarField_js__[\"a\" /* default */];\n\n\nwindow.L.VectorField = __WEBPACK_IMPORTED_MODULE_4__VectorField_js__[\"a\" /* default */];\n\n// layer\n__webpack_require__(10);\n__webpack_require__(8);\n__webpack_require__(6);\n__webpack_require__(7);\n__webpack_require__(9);\n\n// control\n__webpack_require__(5);\n\n/* eslint-disable no-console */\nconsole.log('leaflet.canvaslayer.field v1.4.1');\n/* eslint-enable no-console */\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// leaflet.canvaslayer.field.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 13);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b9f490ab47c1f9f16469","/**\n *  Simple regular cell in a raster\n */\nexport default class Cell {\n    /**\n     * A simple cell with a numerical value\n     * @param {L.LatLng} center\n     * @param {Number|Vector} value\n     * @param {Number} xSize\n     * @param {Number} ySize\n     */\n    constructor(center, value, xSize, ySize = xSize) {\n        this.center = center;\n        this.value = value;\n        this.xSize = xSize;\n        this.ySize = ySize;\n    }\n\n    equals(anotherCell) {\n        return (\n            this.center.equals(anotherCell.center) &&\n            this._equalValues(this.value, anotherCell.value) &&\n            this.xSize === anotherCell.xSize &&\n            this.ySize === anotherCell.ySize\n        );\n    }\n\n    _equalValues(value, anotherValue) {\n        let type = value.constructor.name;\n        let answerFor = {\n            Number: value === anotherValue,\n            Vector: value.u === anotherValue.u && value.v === anotherValue.v\n        };\n        return answerFor[type];\n    }\n\n    /**\n     * Bounds for the cell\n     * @returns {LatLngBounds}\n     */\n    getBounds() {\n        let halfX = this.xSize / 2.0;\n        let halfY = this.ySize / 2.0;\n        let cLat = this.center.lat;\n        let cLng = this.center.lng;\n        let ul = L.latLng([cLat + halfY, cLng - halfX]);\n        let lr = L.latLng([cLat - halfY, cLng + halfX]);\n\n        return L.latLngBounds(\n            L.latLng(lr.lat, ul.lng),\n            L.latLng(ul.lat, lr.lng)\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./Cell.js","import Cell from './Cell';\nimport inside from '@turf/inside';\n\n/**\n *  Abstract class for a set of values (Vector | Scalar)\n *  assigned to a regular 2D-grid (lon-lat), aka 'a Raster source'\n */\nexport default class Field {\n    constructor(params) {\n        this.params = params;\n\n        this.nCols = params['nCols'];\n        this.nRows = params['nRows'];\n\n        // alias\n        this.width = params['nCols'];\n        this.height = params['nRows'];\n\n        // ll = lower-left\n        this.xllCorner = params['xllCorner'];\n        this.yllCorner = params['yllCorner'];\n\n        // ur = upper-right\n        this.xurCorner =\n            params['xllCorner'] + params['nCols'] * params['cellXSize'];\n        this.yurCorner =\n            params['yllCorner'] + params['nRows'] * params['cellYSize'];\n\n        this.cellXSize = params['cellXSize'];\n        this.cellYSize = params['cellYSize'];\n\n        this.grid = null; // to be defined by subclasses\n        this.isContinuous = this.xurCorner - this.xllCorner >= 360;\n        this.longitudeNeedsToBeWrapped = this.xurCorner > 180; // [0, 360] --> [-180, 180]\n\n        this._inFilter = null;\n        this._spatialMask = null;\n    }\n\n    /**\n     * Builds a grid with a value at each point (either Vector or Number)\n     * Original params must include the required input values, following\n     * x-ascending & y-descending order (same as in ASCIIGrid)\n     * @abstract\n     * @private\n     * @returns {Array.<Array.<Vector|Number>>} - grid[row][column]--> Vector|Number\n     */\n    _buildGrid() {\n        throw new TypeError('Must be overriden');\n    }\n\n    _updateRange() {\n        this.range = this._calculateRange();\n    }\n\n    /**\n     * Number of cells in the grid (rows * cols)\n     * @returns {Number}\n     */\n    numCells() {\n        return this.nRows * this.nCols;\n    }\n\n    /**\n     * A list with every cell\n     * @returns {Array<Cell>} - cells (x-ascending & y-descending order)\n     */\n    getCells(stride = 1) {\n        let cells = [];\n        for (let j = 0; j < this.nRows; j = j + stride) {\n            for (let i = 0; i < this.nCols; i = i + stride) {\n                let [lon, lat] = this._lonLatAtIndexes(i, j);\n                let center = L.latLng(lat, lon);\n                let value = this._valueAtIndexes(i, j);\n                let c = new Cell(center, value, this.cellXSize, this.cellYSize);\n                cells.push(c); // <<\n            }\n        }\n        return cells;\n    }\n\n    /**\n     * Apply a filter function to field values\n     * @param   {Function} f - boolean function\n     */\n    setFilter(f) {\n        this._inFilter = f;\n        this._updateRange();\n    }\n\n    /**\n     * Apply a spatial mask to field values\n     * @param {L.GeoJSON} m \n     */\n    setSpatialMask(m) {\n        this._spatialMask = m;\n    }\n\n    /**\n     * Grid extent\n     * @returns {Number[]} [xmin, ymin, xmax, ymax]\n     */\n    extent() {\n        let [xmin, xmax] = this._getWrappedLongitudes();\n        return [xmin, this.yllCorner, xmax, this.yurCorner];\n    }\n\n    /**\n     * [xmin, xmax] in [-180, 180] range\n     */\n    _getWrappedLongitudes() {\n        let xmin = this.xllCorner;\n        let xmax = this.xurCorner;\n\n        if (this.longitudeNeedsToBeWrapped) {\n            if (this.isContinuous) {\n                xmin = -180;\n                xmax = 180;\n            } else {\n                // not sure about this (just one particular case, but others...?)\n                xmax = this.xurCorner - 360;\n                xmin = this.xllCorner - 360;\n                /* eslint-disable no-console */\n                // console.warn(`are these xmin: ${xmin} & xmax: ${xmax} OK?`);\n                // TODO: Better throw an exception on no-controlled situations.\n                /* eslint-enable no-console */\n            }\n        }\n        return [xmin, xmax];\n    }\n\n    /**\n     * Returns whether or not the grid contains the point, considering\n     * the spatialMask if it has been previously set\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    contains(lon, lat) {\n        if (this._spatialMask) {\n            return this._pointInMask(lon, lat);\n        }\n        return this._pointInExtent(lon, lat);\n    }\n\n    /**\n     * Checks if coordinates are inside the Extent (considering wrapped longitudes if needed)\n     * @param {Number} lon \n     * @param {Number} lat \n     */\n    _pointInExtent(lon, lat) {\n        let [xmin, xmax] = this._getWrappedLongitudes();\n        let longitudeIn = lon >= xmin && lon <= xmax;\n        let latitudeIn = lat >= this.yllCorner && lat <= this.yurCorner;\n        return longitudeIn && latitudeIn;\n    }\n\n    /**\n     * Check if coordinates are inside the spatialMask (Point in Polygon analysis)\n     * @param {Number} lon \n     * @param {Number} lat \n     */\n    _pointInMask(lon, lat) {\n        const pt = {\n            type: 'Feature',\n            geometry: {\n                type: 'Point',\n                coordinates: [lon, lat] // geojson, lon-lat order !\n            },\n            properties: {}\n        };\n        const poly = this._spatialMask;\n        return inside(pt, poly);\n    }\n\n    /**\n     * Returns if the grid doesn't contain the point\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    notContains(lon, lat) {\n        return !this.contains(lon, lat);\n    }\n\n    /**\n     * Interpolated value at lon-lat coordinates (bilinear method)\n     * @param   {Number} longitude\n     * @param   {Number} latitude\n     * @returns {Vector|Number} [u, v, magnitude]\n     *                          \n     * Source: https://github.com/cambecc/earth > product.js\n     */\n    interpolatedValueAt(lon, lat) {\n        if (this.notContains(lon, lat)) return null;\n\n        let [i, j] = this._getDecimalIndexes(lon, lat);\n        return this.interpolatedValueAtIndexes(i, j);\n    }\n\n    /**\n     * Interpolated value at i-j indexes (bilinear method)\n     * @param   {Number} i\n     * @param   {Number} j\n     * @returns {Vector|Number} [u, v, magnitude]\n     *\n     * Source: https://github.com/cambecc/earth > product.js\n     */\n    interpolatedValueAtIndexes(i, j) {\n        //         1      2           After converting  and  to fractional grid indexes i and j, we find the\n        //        fi  i   ci          four points 'G' that enclose point (i, j). These points are at the four\n        //         | =1.4 |           corners specified by the floor and ceiling of i and j. For example, given\n        //      ---G--|---G--- fj 8   i = 1.4 and j = 8.3, the four surrounding grid points are (1, 8), (2, 8),\n        //    j ___|_ .   |           (1, 9) and (2, 9).\n        //  =8.3   |      |\n        //      ---G------G--- cj 9   Note that for wrapped grids, the first column is duplicated as the last\n        //         |      |           column, so the index ci can be used without taking a modulo.\n\n        let indexes = this._getFourSurroundingIndexes(i, j);\n        let [fi, ci, fj, cj] = indexes;\n        let values = this._getFourSurroundingValues(fi, ci, fj, cj);\n        if (values) {\n            let [g00, g10, g01, g11] = values;\n            return this._doInterpolation(i - fi, j - fj, g00, g10, g01, g11);\n        }\n        return null;\n    }\n\n    /**\n     * Get decimal indexes\n     * @private\n     * @param {Number} lon\n     * @param {Number} lat\n     * @returns {Array}    [[Description]]\n     */\n    _getDecimalIndexes(lon, lat) {\n        if (this.longitudeNeedsToBeWrapped && lon < this.xllCorner) {\n            lon = lon + 360;\n        }\n        let i = (lon - this.xllCorner) / this.cellXSize;\n        let j = (this.yurCorner - lat) / this.cellYSize;\n        return [i, j];\n    }\n\n    /**\n     * Get surrounding indexes (integer), clampling on borders\n     * @private\n     * @param   {Number} i - decimal index\n     * @param   {Number} j - decimal index\n     * @returns {Array} [fi, ci, fj, cj]\n     */\n    _getFourSurroundingIndexes(i, j) {\n        let fi = Math.floor(i);\n        let ci = fi + 1;\n        // duplicate colum to simplify interpolation logic (wrapped value)\n        if (this.isContinuous && ci >= this.nCols) {\n            ci = 0;\n        }\n        ci = this._clampColumnIndex(ci);\n\n        let fj = this._clampRowIndex(Math.floor(j));\n        let cj = this._clampRowIndex(fj + 1);\n\n        return [fi, ci, fj, cj];\n    }\n\n    /**\n     * Get four surrounding values or null if not available,\n     * from 4 integer indexes\n     * @private\n     * @param   {Number} fi\n     * @param   {Number} ci\n     * @param   {Number} fj\n     * @param   {Number} cj\n     * @returns {Array} \n     */\n    _getFourSurroundingValues(fi, ci, fj, cj) {\n        var row;\n        if ((row = this.grid[fj])) {\n            // upper row ^^\n            var g00 = row[fi]; // << left\n            var g10 = row[ci]; // right >>\n            if (\n                this._isValid(g00) &&\n                this._isValid(g10) &&\n                (row = this.grid[cj])\n            ) {\n                // lower row vv\n                var g01 = row[fi]; // << left\n                var g11 = row[ci]; // right >>\n                if (this._isValid(g01) && this._isValid(g11)) {\n                    return [g00, g10, g01, g11]; // 4 values found!\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Nearest value at lon-lat coordinates\n     * @param   {Number} longitude\n     * @param   {Number} latitude\n     * @returns {Vector|Number}\n     */\n    valueAt(lon, lat) {\n        if (this.notContains(lon, lat)) return null;\n\n        let [i, j] = this._getDecimalIndexes(lon, lat);\n        let ii = Math.floor(i);\n        let jj = Math.floor(j);\n\n        const ci = this._clampColumnIndex(ii);\n        const cj = this._clampRowIndex(jj);\n\n        let value = this._valueAtIndexes(ci, cj);\n        if (this._inFilter) {\n            if (!this._inFilter(value)) return null;\n        }\n\n        return value;\n    }\n\n    /**\n     * Returns whether or not the field has a value at the point\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    hasValueAt(lon, lat) {\n        let value = this.valueAt(lon, lat);\n        let hasValue = value !== null;\n\n        let included = true;\n        if (this._inFilter) {\n            included = this._inFilter(value);\n        }\n        return hasValue && included;\n    }\n\n    /**\n     * Returns if the grid has no value at the point\n     * @param   {Number} lon - longitude\n     * @param   {Number} lat - latitude\n     * @returns {Boolean}\n     */\n    notHasValueAt(lon, lat) {\n        return !this.hasValueAt(lon, lat);\n    }\n\n    /**\n     * Gives a random position to 'o' inside the grid\n     * @param {Object} [o] - an object (eg. a particle)\n     * @returns {{x: Number, y: Number}} - object with x, y (lon, lat)\n     */\n    randomPosition(o = {}) {\n        let i = (Math.random() * this.nCols) | 0;\n        let j = (Math.random() * this.nRows) | 0;\n\n        o.x = this._longitudeAtX(i);\n        o.y = this._latitudeAtY(j);\n\n        return o;\n    }\n\n    /**\n     * Value for grid indexes\n     * @param   {Number} i - column index (integer)\n     * @param   {Number} j - row index (integer)\n     * @returns {Vector|Number}\n     */\n    _valueAtIndexes(i, j) {\n        return this.grid[j][i]; // <-- j,i !!\n    }\n\n    /**\n     * Lon-Lat for grid indexes\n     * @param   {Number} i - column index (integer)\n     * @param   {Number} j - row index (integer)\n     * @returns {Number[]} [lon, lat]\n     */\n    _lonLatAtIndexes(i, j) {\n        let lon = this._longitudeAtX(i);\n        let lat = this._latitudeAtY(j);\n\n        return [lon, lat];\n    }\n\n    /**\n     * Longitude for grid-index\n     * @param   {Number} i - column index (integer)\n     * @returns {Number} longitude at the center of the cell\n     */\n    _longitudeAtX(i) {\n        let halfXPixel = this.cellXSize / 2.0;\n        let lon = this.xllCorner + halfXPixel + i * this.cellXSize;\n        if (this.longitudeNeedsToBeWrapped) {\n            lon = lon > 180 ? lon - 360 : lon;\n        }\n        return lon;\n    }\n\n    /**\n     * Latitude for grid-index\n     * @param   {Number} j - row index (integer)\n     * @returns {Number} latitude at the center of the cell\n     */\n    _latitudeAtY(j) {\n        let halfYPixel = this.cellYSize / 2.0;\n        return this.yurCorner - halfYPixel - j * this.cellYSize;\n    }\n\n    /**\n     * Apply the interpolation\n     * @abstract\n     * @private\n     */\n    /* eslint-disable no-unused-vars */\n    _doInterpolation(x, y, g00, g10, g01, g11) {\n        throw new TypeError('Must be overriden');\n    }\n    /* eslint-disable no-unused-vars */\n\n    /**\n     * Check the column index is inside the field,\n     * adjusting to min or max when needed\n     * @private\n     * @param   {Number} ii - index\n     * @returns {Number} i - inside the allowed indexes\n     */\n    _clampColumnIndex(ii) {\n        let i = ii;\n        if (ii < 0) {\n            i = 0;\n        }\n        let maxCol = this.nCols - 1;\n        if (ii > maxCol) {\n            i = maxCol;\n        }\n        return i;\n    }\n\n    /**\n     * Check the row index is inside the field,\n     * adjusting to min or max when needed\n     * @private\n     * @param   {Number} jj index\n     * @returns {Number} j - inside the allowed indexes\n     */\n    _clampRowIndex(jj) {\n        let j = jj;\n        if (jj < 0) {\n            j = 0;\n        }\n        let maxRow = this.nRows - 1;\n        if (jj > maxRow) {\n            j = maxRow;\n        }\n        return j;\n    }\n\n    /**\n     * Is valid (not 'null' nor 'undefined')\n     * @private\n     * @param   {Object} x object\n     * @returns {Boolean}\n     */\n    _isValid(x) {\n        return x !== null && x !== undefined;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./Field.js","import Field from './Field';\n\n/**\n * Scalar Field\n */\nexport default class ScalarField extends Field {\n    /**\n     * Creates a ScalarField from the content of an ASCIIGrid file\n     * @param   {String}   asc\n     * @returns {ScalarField}\n     */\n    static fromASCIIGrid(asc, scaleFactor = 1) {\n        //console.time('ScalarField from ASC');\n\n        let lines = asc.split('\\n');\n\n        // Header\n        var header = ScalarField._parseASCIIGridHeader(lines.slice(0, 6));\n\n        // Data (left-right and top-down)\n        let zs = [];\n        for (let i = 6; i < lines.length; i++) {\n            let line = lines[i].trim();\n            if (line === '') break;\n\n            let items = line.split(' ');\n            items.forEach(it => {\n                let floatItem = parseFloat(it);\n                let v =\n                    floatItem !== header.noDataValue\n                        ? floatItem * scaleFactor\n                        : null;\n                zs.push(v);\n            });\n        }\n        let p = header;\n        p.zs = zs;\n\n        //console.timeEnd('ScalarField from ASC');\n        return new ScalarField(p);\n    }\n\n    /**\n     * Parse an ASCII Grid header, made with 6 lines\n     * It allows the use of XLLCORNER/YLLCORNER or XLLCENTER/YLLCENTER conventions\n     * @param {Array.String} headerLines\n     */\n    static _parseASCIIGridHeader(headerLines) {\n        try {\n            const headerItems = headerLines.map(line => {\n                var items = line.split(' ').filter(i => i != '');\n                var param = items[0].trim().toUpperCase();\n                var value = parseFloat(items[1].trim());\n                return { [param]: value };\n            });\n\n            const usesCorner = 'XLLCORNER' in headerItems[2];\n            const cellSize = headerItems[4]['CELLSIZE'];\n\n            const header = {\n                nCols: parseInt(headerItems[0]['NCOLS']),\n                nRows: parseInt(headerItems[1]['NROWS']),\n                xllCorner: usesCorner\n                    ? headerItems[2]['XLLCORNER']\n                    : headerItems[2]['XLLCENTER'] - cellSize,\n                yllCorner: usesCorner\n                    ? headerItems[3]['YLLCORNER']\n                    : headerItems[3]['YLLCENTER'] - cellSize,\n                cellXSize: cellSize,\n                cellYSize: cellSize,\n                noDataValue: headerItems[5]['NODATA_VALUE']\n            };\n            return header;\n        } catch (err) {\n            throw new Error(`Not a valid ASCIIGrid Header: ${err}`);\n        }\n    }\n\n    /**\n     * Creates a ScalarField from the content of a GeoTIFF file\n     * @param   {ArrayBuffer}   data\n     * @param   {Number}   bandIndex\n     * @returns {ScalarField}\n     */\n    static fromGeoTIFF(data, bandIndex = 0) {\n        return ScalarField.multipleFromGeoTIFF(data, [bandIndex])[0];\n    }\n\n    /**\n     * Creates a ScalarField array (one per band) from the content of a GeoTIFF file\n     * @param   {ArrayBuffer}   data\n     * @param   {Array}   bandIndexes - if not provided all bands are returned\n     * @returns {Array.<ScalarField>}\n     */\n    static multipleFromGeoTIFF(data, bandIndexes) {\n        //console.time('ScalarField from GeoTIFF');\n\n        let tiff = GeoTIFF.parse(data); // geotiff.js\n        let image = tiff.getImage();\n        let rasters = image.readRasters();\n        let tiepoint = image.getTiePoints()[0];\n        let fileDirectory = image.getFileDirectory();\n        let [xScale, yScale] = fileDirectory.ModelPixelScale;\n\n        if (typeof bandIndexes === 'undefined' || bandIndexes.length === 0) {\n            bandIndexes = [...Array(rasters.length).keys()];\n        }\n\n        let scalarFields = [];\n        scalarFields = bandIndexes.map(function(bandIndex) {\n            let zs = rasters[bandIndex]; // left-right and top-down order\n\n            if (fileDirectory.GDAL_NODATA) {\n                let noData = parseFloat(fileDirectory.GDAL_NODATA);\n                // console.log(noData);\n                let simpleZS = Array.from(zs); // to simple array, so null is allowed | TODO efficiency??\n                zs = simpleZS.map(function(z) {\n                    return z === noData ? null : z;\n                });\n            }\n\n            let p = {\n                nCols: image.getWidth(),\n                nRows: image.getHeight(),\n                xllCorner: tiepoint.x,\n                yllCorner: tiepoint.y - image.getHeight() * yScale,\n                cellXSize: xScale,\n                cellYSize: yScale,\n                zs: zs\n            };\n            return new ScalarField(p);\n        });\n\n        //console.timeEnd('ScalarField from GeoTIFF');\n        return scalarFields;\n    }\n\n    constructor(params) {\n        super(params);\n        this.zs = params['zs'];\n\n        this.grid = this._buildGrid();\n        this._updateRange();\n        //console.log(`ScalarField created (${this.nCols} x ${this.nRows})`);\n    }\n\n    /**\n     * Builds a grid with a Number at each point, from an array\n     * 'zs' following x-ascending & y-descending order\n     * (same as in ASCIIGrid)\n     * @private\n     * @returns {Array.<Array.<Number>>} - grid[row][column]--> Number\n     */\n    _buildGrid() {\n        let grid = this._arrayTo2d(this.zs, this.nRows, this.nCols);\n        return grid;\n    }\n\n    _arrayTo2d(array, nRows, nCols) {\n        let grid = [];\n        let p = 0;\n        for (var j = 0; j < nRows; j++) {\n            var row = [];\n            for (var i = 0; i < nCols; i++, p++) {\n                let z = array[p];\n                row[i] = this._isValid(z) ? z : null; // <<<\n            }\n            grid[j] = row;\n        }\n        return grid;\n    }\n\n    _newDataArrays(params) {\n        params['zs'] = [];\n    }\n\n    _pushValueToArrays(params, value) {\n        params['zs'].push(value);\n    }\n\n    _makeNewFrom(params) {\n        return new ScalarField(params);\n    }\n\n    /**\n     * Calculate min & max values\n     * @private\n     * @returns {Array} - [min, max]\n     */\n    _calculateRange() {\n        var data = this.zs;\n        if (this._inFilter) {\n            data = data.filter(this._inFilter);\n        }\n        return [d3.min(data), d3.max(data)];\n    }\n\n    /**\n     * Bilinear interpolation for Number\n     * https://en.wikipedia.org/wiki/Bilinear_interpolation\n     * @param   {Number} x\n     * @param   {Number} y\n     * @param   {Number} g00\n     * @param   {Number} g10\n     * @param   {Number} g01\n     * @param   {Number} g11\n     * @returns {Number}\n     */\n    _doInterpolation(x, y, g00, g10, g01, g11) {\n        var rx = 1 - x;\n        var ry = 1 - y;\n        return g00 * rx * ry + g10 * x * ry + g01 * rx * y + g11 * x * y;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./ScalarField.js","/**\n *  2D Vector\n */\nexport default class Vector {\n\n    constructor(u, v) {\n        this.u = u;\n        this.v = v;\n    }\n\n    /**\n     * Magnitude\n     * @returns {Number}\n     */\n    magnitude() {\n        return Math.sqrt(this.u * this.u + this.v * this.v);\n    }\n\n    /**\n     * Angle in degrees (0 to 360) --> Towards\n     * N is 0 and E is 90\n     * @returns {Number}\n     */\n    directionTo() {\n        let verticalAngle = Math.atan2(this.u, this.v);\n        let inDegrees = verticalAngle * (180.0 / Math.PI);\n        if (inDegrees < 0) {\n            inDegrees = inDegrees + 360.0;\n        }\n        return inDegrees;\n    }\n\n    /**\n     * Angle in degrees (0 to 360) From x-->\n     * N is 0 and E is 90\n     * @returns {Number}\n     */\n    directionFrom() {\n        let a = this.directionTo();\n        let opposite = (a + 180.0) % 360.0;\n        return opposite;\n    }\n\n    /*\n        Degrees --> text\n        new Dictionary<int, string>\n        {\n            //{0, 23, 45, 68, 90, 113, 135, 158, 180, 203, 225, 248, 270, 293, 315, 338, 360};\n            {0, 'N'},\n            {23, 'NNE'},\n            {45, 'NE'},\n            {68, 'ENE'},\n            {90, 'E'},\n            {113, 'ESE'},\n            {135, 'SE'},\n            {158, 'SSE'},\n            {180, 'S'},\n            {203, 'SSW'},\n            {225, 'SW'},\n            {248, 'WSW'},\n            {270, 'W'},\n            {293, 'WNW'},\n            {315, 'NW'},\n            {338, 'NNW'},\n            {360, 'N'}\n        };\n    */\n}\n\n\n\n// WEBPACK FOOTER //\n// ./Vector.js","import Vector from './Vector';\nimport Field from './Field';\nimport ScalarField from './ScalarField';\n\n/**\n *  A set of vectors assigned to a regular 2D-grid (lon-lat)\n *  (e.g. a raster representing winds for a region)\n */\nexport default class VectorField extends Field {\n    /**\n     * Creates a VectorField from the content of two ASCIIGrid files\n     * @param   {String} ascU - with u-component\n     * @param   {String} ascV - with v-component\n     * @returns {VectorField}\n     */\n    static fromASCIIGrids(ascU, ascV, scaleFactor = 1) {\n        let u = ScalarField.fromASCIIGrid(ascU, scaleFactor);\n        let v = ScalarField.fromASCIIGrid(ascV, scaleFactor);\n        let p = VectorField._paramsFromScalarFields(u, v);\n\n        return new VectorField(p);\n    }\n\n    /**\n     * Creates a VectorField from the content of two different Geotiff files\n     * @param   {ArrayBuffer} gtU - geotiff data with u-component (band 0)\n     * @param   {ArrayBuffer} gtV - geotiff data with v-component (band 0)\n     * @returns {VectorField}\n     */\n    static fromGeoTIFFs(gtU, gtV) {\n        let u = ScalarField.fromGeoTIFF(gtU);\n        let v = ScalarField.fromGeoTIFF(gtV);\n        let p = VectorField._paramsFromScalarFields(u, v);\n\n        return new VectorField(p);\n    }\n\n    /**\n     * Creates a VectorField from the content of Multiband Geotiff\n     * @param   {ArrayBuffer} geotiffData - multiband\n     * @param   {Array} bandIndexesForUV\n     * @returns {VectorField}\n     */\n    static fromMultibandGeoTIFF(geotiffData, bandIndexesForUV = [0, 1]) {\n        let [u, v] = ScalarField.multipleFromGeoTIFF(\n            geotiffData,\n            bandIndexesForUV\n        );\n        let p = VectorField._paramsFromScalarFields(u, v);\n\n        return new VectorField(p);\n    }\n\n    /**\n     * Build parameters for VectorField, from 2 ScalarFields.\n     * No validation at all (nor interpolation) is applied, so u and v\n     * must be 'compatible' from the source\n     * @param   {ScalarField} u\n     * @param   {ScalarField} v\n     * @returns {Object} - parameters to build VectorField\n     */\n    static _paramsFromScalarFields(u, v) {\n        // TODO check u & v compatibility (cellSize...)\n        let p = {\n            nCols: u.nCols,\n            nRows: u.nRows,\n            xllCorner: u.xllCorner,\n            yllCorner: u.yllCorner,\n            cellXSize: u.cellXSize,\n            cellYSize: u.cellYSize,\n            us: u.zs,\n            vs: v.zs\n        };\n        return p;\n    }\n\n    constructor(params) {\n        super(params);\n\n        this.us = params['us'];\n        this.vs = params['vs'];\n        this.grid = this._buildGrid();\n        this.range = this._calculateRange();\n    }\n\n    /**\n     * Get a derived field, from a computation on\n     * the VectorField\n     * @param   {String} type ['magnitude' | 'directionTo' | 'directionFrom']\n     * @returns {ScalarField}\n     */\n    getScalarField(type) {\n        let f = this._getFunctionFor(type);\n        let p = {\n            nCols: this.params.nCols,\n            nRows: this.params.nRows,\n            xllCorner: this.params.xllCorner,\n            yllCorner: this.params.yllCorner,\n            cellXSize: this.params.cellXSize,\n            cellYSize: this.params.cellYSize,\n            zs: this._applyOnField(f)\n        };\n        return new ScalarField(p);\n    }\n\n    _getFunctionFor(type) {\n        return function(u, v) {\n            let uv = new Vector(u, v);\n            return uv[type](); // magnitude, directionTo, directionFrom\n        };\n    }\n\n    _applyOnField(func) {\n        let zs = [];\n        let n = this.numCells();\n        for (var i = 0; i < n; i++) {\n            let u = this.us[i];\n            let v = this.vs[i];\n            if (this._isValid(u) && this._isValid(v)) {\n                zs.push(func(u, v));\n            } else {\n                zs.push(null);\n            }\n        }\n        return zs;\n    }\n\n    /**\n     * Builds a grid with a Vector at each point, from two arrays\n     * 'us' and 'vs' following x-ascending & y-descending order\n     * (same as in ASCIIGrid)\n     * @returns {Array.<Array.<Vector>>} - grid[row][column]--> Vector\n     */\n    _buildGrid() {\n        let grid = this._arraysTo2d(this.us, this.vs, this.nRows, this.nCols);\n        return grid;\n    }\n\n    _arraysTo2d(us, vs, nRows, nCols) {\n        let grid = [];\n        let p = 0;\n\n        for (var j = 0; j < nRows; j++) {\n            var row = [];\n            for (var i = 0; i < nCols; i++, p++) {\n                let u = us[p],\n                    v = vs[p];\n                let valid = this._isValid(u) && this._isValid(v);\n                row[i] = valid ? new Vector(u, v) : null; // <<<\n            }\n            grid[j] = row;\n        }\n        return grid;\n    }\n\n    _newDataArrays(params) {\n        params['us'] = [];\n        params['vs'] = [];\n    }\n    _pushValueToArrays(params, value) {\n        //console.log(value);\n        params['us'].push(value.u);\n        params['vs'].push(value.v);\n    }\n    _makeNewFrom(params) {\n        return new VectorField(params);\n    }\n\n    /**\n     * Calculate min & max values (magnitude)\n     * @private\n     * @returns {Array}\n     */\n    _calculateRange() {\n        // TODO make a clearer method for getting these vectors...\n        let vectors = this.getCells()\n            .map(pt => pt.value)\n            .filter(function(v) {\n                return v !== null;\n            });\n\n        if (this._inFilter) {\n            vectors = vectors.filter(this._inFilter);\n        }\n\n        // TODO check memory crash with high num of vectors!\n        let magnitudes = vectors.map(v => v.magnitude());\n        let min = d3.min(magnitudes);\n        let max = d3.max(magnitudes);\n\n        return [min, max];\n    }\n\n    /**\n     * Bilinear interpolation for Vector\n     * https://en.wikipedia.org/wiki/Bilinear_interpolation\n     * @param   {Number} x\n     * @param   {Number} y\n     * @param   {Number[]} g00\n     * @param   {Number[]} g10\n     * @param   {Number[]} g01\n     * @param   {Number[]} g11\n     * @returns {Vector}\n     */\n    _doInterpolation(x, y, g00, g10, g01, g11) {\n        var rx = 1 - x;\n        var ry = 1 - y;\n        var a = rx * ry,\n            b = x * ry,\n            c = rx * y,\n            d = x * y;\n        var u = g00.u * a + g10.u * b + g01.u * c + g11.u * d;\n        var v = g00.v * a + g10.v * b + g01.v * c + g11.v * d;\n        return new Vector(u, v);\n    }\n\n    /**\n     * Is valid (not 'null' nor 'undefined')\n     * @private\n     * @param   {Object} x object\n     * @returns {Boolean}\n     */\n    _isValid(x) {\n        return x !== null && x !== undefined;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./VectorField.js","/**\n *   Control for a simple legend with a colorbar\n *   References:\n *      - http://jsfiddle.net/ramnathv/g8stqcf6/\n *      - http://jsfiddle.net/vis4/cYLZH/\n */\nL.Control.ColorBar = L.Control.extend({\n    options: {\n        position: 'bottomleft',\n        width: 300, // for colorbar itself (control is wider)\n        height: 15,\n        margin: 15,\n        background: '#fff',\n        textColor: 'black',\n        steps: 100,\n        decimals: 2,\n        units: 'uds', // ej: m/s\n        title: 'Legend', // ej: Ocean Currents\n        labels: [], // empty for no labels\n        labelFontSize: 10,\n        labelTextPosition: 'middle' // start | middle | end\n    },\n\n    initialize: function(color, range, options) {\n        this.color = color; // 'chromajs' scale function\n        this.range = range; // [min, max]\n        L.Util.setOptions(this, options);\n    },\n\n    onAdd: function(map) {\n        this._map = map;\n        let div = L.DomUtil.create(\n            'div',\n            'leaflet-control-colorBar leaflet-bar leaflet-control'\n        );\n        div.style.padding = '10px';\n\n        L.DomEvent\n            .addListener(div, 'click', L.DomEvent.stopPropagation)\n            .addListener(div, 'click', L.DomEvent.preventDefault);\n        div.style.backgroundColor = this.options.background;\n        div.style.cursor = 'text';\n        div.innerHTML = this.title() + this.palette();\n        return div;\n    },\n\n    title: function() {\n        let d = document.createElement('div');\n        d3\n            .select(d)\n            .append('span')\n            .style('color', this.options.textColor)\n            .style('display', 'block')\n            .style('margin-bottom', '5px')\n            .attr('class', 'leaflet-control-colorBar-title')\n            .text(this.options.title);\n        return d.innerHTML;\n    },\n\n    palette: function() {\n        let d = document.createElement('div');\n        let svg = this._createSvgIn(d);\n\n        this._appendColorBarTo(svg);\n\n        if (this.options.labels) {\n            this._appendLabelsTo(svg);\n        }\n\n        return d.innerHTML;\n    },\n\n    _createSvgIn: function(d) {\n        let spaceForLabels = this.options.labels ? this.options.margin : 0;\n        let svg = d3\n            .select(d)\n            .append('svg')\n            .attr('width', this.options.width + this.options.margin * 2)\n            .attr('height', this.options.height + spaceForLabels);\n        return svg;\n    },\n\n    _appendColorBarTo: function(svg) {\n        const colorPerValue = this._getColorPerValue();\n        const w = this.options.width / colorPerValue.length;\n\n        let groupBars = svg.append('g').attr('id', 'colorBar-buckets');\n        let buckets = groupBars\n            .selectAll('rect')\n            .data(colorPerValue)\n            .enter()\n            .append('rect');\n        buckets\n            .attr('x', (d, i) => i * w + this.options.margin)\n            .attr('y', () => 0)\n            .attr('height', () => this.options.height /*w * 4*/)\n            .attr('width', () => w)\n            .attr('stroke-width', 2)\n            .attr('stroke-linecap', 'butt')\n            .attr('stroke', d => d.color.hex())\n            .attr('fill', d => d.color.hex());\n        buckets\n            .append('title')\n            .text(\n                d =>\n                    `${d.value.toFixed(this.options.decimals)} ${this.options\n                        .units}`\n            );\n    },\n\n    _appendLabelsTo: function(svg) {\n        const positionPerLabelValue = this._getPositionPerLabelValue();\n        //const w = this.options.width / colorPerValue.length;\n        let groupLabels = svg.append('g').attr('id', 'colorBar-labels');\n        let labels = groupLabels\n            .selectAll('text')\n            .data(positionPerLabelValue)\n            .enter()\n            .append('text');\n        labels\n            .attr('x', d => d.position + this.options.margin)\n            .attr('y', this.options.height + this.options.margin)\n            .attr('font-size', `${this.options.labelFontSize}px`)\n            .attr('text-anchor', this.options.labelTextPosition)\n            .attr('fill', this.options.textColor)\n            .attr('class', 'leaflet-control-colorBar-label')\n            .text(d => `${d.value.toFixed(this.options.decimals)}`);\n    },\n\n    _getColorPerValue: function() {\n        const [min, max] = this.range;\n        let delta = (max - min) / this.options.steps;\n        let data = d3.range(min, max + delta, delta);\n        let colorPerValue = data.map(d => {\n            return {\n                value: d,\n                color: this.color(d)\n            };\n        });\n        return colorPerValue;\n    },\n\n    _getPositionPerLabelValue: function() {\n        var xPositionFor = d3\n            .scaleLinear()\n            .range([0, this.options.width])\n            .domain(this.range);\n        let data = this.options.labels;\n        let positionPerLabel = data.map(d => {\n            return {\n                value: d,\n                position: xPositionFor(d)\n            };\n        });\n        return positionPerLabel;\n    }\n});\n\nL.control.colorBar = function(color, range, options) {\n    return new L.Control.ColorBar(color, range, options);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./control/L.Control.ColorBar.js","/**\n * Abstract class for a Field layer on canvas, aka 'a Raster layer'\n * (ScalarField or a VectorField)\n */\nL.CanvasLayer.Field = L.CanvasLayer.extend({\n    options: {\n        mouseMoveCursor: {\n            value: 'pointer',\n            noValue: 'default'\n        },\n        opacity: 1,\n        onClick: null,\n        onMouseMove: null,\n        inFilter: null\n    },\n\n    initialize: function(field, options) {\n        L.Util.setOptions(this, options);\n        this._visible = true;\n        if (field) {\n            this.setData(field);\n        }\n    },\n\n    getEvents: function() {\n        var events = L.CanvasLayer.prototype.getEvents.call(this);\n        events.zoomstart = this._hideCanvas.bind(this);\n        events.zoomend = this._showCanvas.bind(this);\n        return events;\n    },\n\n    onLayerDidMount: function() {\n        this._enableIdentify();\n        this._ensureCanvasAlignment();\n    },\n\n    show() {\n        this._visible = true;\n        this._showCanvas();\n        this._enableIdentify();\n    },\n\n    hide() {\n        this._visible = false;\n        this._hideCanvas();\n        this._disableIdentify();\n    },\n\n    isVisible() {\n        return this._visible;\n    },\n\n    _showCanvas() {\n        if (this._canvas && this._visible) {\n            this._canvas.style.visibility = 'visible';\n        }\n    },\n\n    _hideCanvas() {\n        if (this._canvas) {\n            this._canvas.style.visibility = 'hidden';\n        }\n    },\n\n    _enableIdentify() {\n        this._map.on('click', this._onClick, this);\n        this._map.on('mousemove', this._onMouseMove, this);\n\n        this.options.onClick && this.on('click', this.options.onClick, this);\n        this.options.onMouseMove &&\n            this.on('mousemove', this.options.onMouseMove, this);\n    },\n\n    _disableIdentify() {\n        this._map.off('click', this._onClick, this);\n        this._map.off('mousemove', this._onMouseMove, this);\n\n        this.options.onClick && this.off('click', this.options.onClick, this);\n        this.options.onMouseMove &&\n            this.off('mousemove', this.options.onMouseMove, this);\n    },\n\n    _ensureCanvasAlignment() {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n    },\n\n    onLayerWillUnmount: function() {\n        this._disableIdentify();\n    },\n\n    needRedraw() {\n        if (this._map && this._field) {\n            L.CanvasLayer.prototype.needRedraw.call(this);\n        }\n    },\n\n    /* eslint-disable no-unused-vars */\n    onDrawLayer: function(viewInfo) {\n        throw new TypeError('Must be overriden');\n    },\n    /* eslint-enable no-unused-vars */\n\n    setData: function(field) {\n        this.options.inFilter && field.setFilter(this.options.inFilter);\n        this._field = field;\n        this.needRedraw();\n        this.fire('load');\n    },\n\n    setFilter: function(f) {\n        this.options.inFilter = f;\n        this._field && this._field.setFilter(f);\n        this.needRedraw();\n    },\n\n    setOpacity: function(opacity) {\n        this.options.opacity = opacity;\n\n        if (this._canvas) {\n            this._updateOpacity();\n        }\n        return this;\n    },\n\n    getBounds: function() {\n        let bb = this._field.extent();\n\n        let southWest = L.latLng(bb[1], bb[0]),\n            northEast = L.latLng(bb[3], bb[2]);\n        let bounds = L.latLngBounds(southWest, northEast);\n        return bounds;\n    },\n\n    _onClick: function(e) {\n        let v = this._queryValue(e);\n        this.fire('click', v);\n    },\n\n    _onMouseMove: function(e) {\n        let v = this._queryValue(e);\n        this._changeCursorOn(v);\n        this.fire('mousemove', v);\n    },\n\n    _changeCursorOn: function(v) {\n        if (!this.options.mouseMoveCursor) return;\n\n        let { value, noValue } = this.options.mouseMoveCursor;\n        let style = this._map.getContainer().style;\n        style.cursor = v.value !== null ? value : noValue;\n    },\n\n    _updateOpacity: function() {\n        L.DomUtil.setOpacity(this._canvas, this.options.opacity);\n    },\n\n    _queryValue: function(e) {\n        let v = this._field\n            ? this._field.valueAt(e.latlng.lng, e.latlng.lat)\n            : null;\n        let result = {\n            latlng: e.latlng,\n            value: v\n        };\n        return result;\n    },\n\n    _getDrawingContext: function() {\n        let g = this._canvas.getContext('2d');\n        g.clearRect(0, 0, this._canvas.width, this._canvas.height);\n        return g;\n    }\n});\n\n\n\n// WEBPACK FOOTER //\n// ./layer/L.CanvasLayer.Field.js","import Cell from '../Cell';\n\n/**\n * ScalarField on canvas (a 'Raster')\n */\nL.CanvasLayer.ScalarField = L.CanvasLayer.Field.extend({\n    options: {\n        type: 'colormap', // [colormap|vector]\n        color: null, // function colorFor(value) [e.g. chromajs.scale],\n        interpolate: false, // Change to use interpolation\n        vectorSize: 20, // only used if 'vector'\n        arrowDirection: 'from' // [from|towards]\n    },\n\n    initialize: function(scalarField, options) {\n        L.CanvasLayer.Field.prototype.initialize.call(\n            this,\n            scalarField,\n            options\n        );\n        L.Util.setOptions(this, options);\n    },\n\n    _defaultColorScale: function() {\n        return chroma.scale(['white', 'black']).domain(this._field.range);\n    },\n\n    setColor(f) {\n        this.options.color = f;\n        this.needRedraw();\n    },\n\n    /* eslint-disable no-unused-vars */\n    onDrawLayer: function(viewInfo) {\n        if (!this.isVisible()) return;\n        this._updateOpacity();\n\n        let r = this._getRendererMethod();\n        //console.time('onDrawLayer');\n        r();\n        //console.timeEnd('onDrawLayer');\n    },\n    /* eslint-enable no-unused-vars */\n\n    _getRendererMethod: function() {\n        switch (this.options.type) {\n            case 'colormap':\n                return this._drawImage.bind(this);\n            case 'vector':\n                return this._drawArrows.bind(this);\n            default:\n                throw Error(`Unkwown renderer type: ${this.options.type}`);\n        }\n    },\n\n    _ensureColor: function() {\n        if (this.options.color === null) {\n            this.setColor(this._defaultColorScale());\n        }\n    },\n\n    _showCanvas() {\n        L.CanvasLayer.Field.prototype._showCanvas.call(this);\n        this.needRedraw(); // TODO check spurious redraw (e.g. hide/show without moving map)\n    },\n\n    /**\n     * Draws the field in an ImageData and applying it with putImageData.\n     * Used as a reference: http://geoexamples.com/d3-raster-tools-docs/code_samples/raster-pixels-page.html\n     */\n    _drawImage: function() {\n        this._ensureColor();\n\n        let ctx = this._getDrawingContext();\n        let width = this._canvas.width;\n        let height = this._canvas.height;\n\n        let img = ctx.createImageData(width, height);\n        let data = img.data;\n\n        this._prepareImageIn(data, width, height);\n        ctx.putImageData(img, 0, 0);\n    },\n\n    /**\n     * Prepares the image in data, as array with RGBAs\n     * [R1, G1, B1, A1, R2, G2, B2, A2...]\n     * @private\n     * @param {[[Type]]} data   [[Description]]\n     * @param {Numver} width\n     * @param {Number} height\n     */\n    _prepareImageIn(data, width, height) {\n        let f = this.options.interpolate ? 'interpolatedValueAt' : 'valueAt';\n\n        let pos = 0;\n        for (let j = 0; j < height; j++) {\n            for (let i = 0; i < width; i++) {\n                let pointCoords = this._map.containerPointToLatLng([i, j]);\n                let lon = pointCoords.lng;\n                let lat = pointCoords.lat;\n\n                let v = this._field[f](lon, lat); // 'valueAt' | 'interpolatedValueAt' || TODO check some 'artifacts'\n                if (v !== null) {\n                    let color = this._getColorFor(v);\n                    let [R, G, B, A] = color.rgba();\n                    data[pos] = R;\n                    data[pos + 1] = G;\n                    data[pos + 2] = B;\n                    data[pos + 3] = parseInt(A * 255); // not percent in alpha but hex 0-255\n                }\n                pos = pos + 4;\n            }\n        }\n    },\n\n    /**\n     * Draws the field as a set of arrows. Direction from 0 to 360 is assumed.\n     */\n    _drawArrows: function() {\n        const bounds = this._pixelBounds();\n        const pixelSize = (bounds.max.x - bounds.min.x) / this._field.nCols;\n\n        var stride = Math.max(\n            1,\n            Math.floor(1.2 * this.options.vectorSize / pixelSize)\n        );\n\n        const ctx = this._getDrawingContext();\n        ctx.strokeStyle = this.options.color;\n\n        var currentBounds = this._map.getBounds();\n\n        for (var y = 0; y < this._field.height; y = y + stride) {\n            for (var x = 0; x < this._field.width; x = x + stride) {\n                let [lon, lat] = this._field._lonLatAtIndexes(x, y);\n                let v = this._field.valueAt(lon, lat);\n                let center = L.latLng(lat, lon);\n                if (v !== null && currentBounds.contains(center)) {\n                    let cell = new Cell(\n                        center,\n                        v,\n                        this.cellXSize,\n                        this.cellYSize\n                    );\n                    this._drawArrow(cell, ctx);\n                }\n            }\n        }\n    },\n\n    _pixelBounds: function() {\n        const bounds = this.getBounds();\n        const northWest = this._map.latLngToContainerPoint(\n            bounds.getNorthWest()\n        );\n        const southEast = this._map.latLngToContainerPoint(\n            bounds.getSouthEast()\n        );\n        var pixelBounds = L.bounds(northWest, southEast);\n        return pixelBounds;\n    },\n\n    _drawArrow: function(cell, ctx) {\n        var projected = this._map.latLngToContainerPoint(cell.center);\n\n        // colormap vs. simple color\n        let color = this.options.color;\n        if (typeof color === 'function') {\n            ctx.strokeStyle = color(cell.value);\n        }\n\n        const size = this.options.vectorSize;\n        ctx.save();\n\n        ctx.translate(projected.x, projected.y);\n\n        let rotationRads = (90 + cell.value) * Math.PI / 180; // from, by default\n        if (this.options.arrowDirection === 'towards') {\n            rotationRads = rotationRads + Math.PI;\n        }\n        ctx.rotate(rotationRads);\n\n        ctx.beginPath();\n        ctx.moveTo(-size / 2, 0);\n        ctx.lineTo(+size / 2, 0);\n        ctx.moveTo(size * 0.25, -size * 0.25);\n        ctx.lineTo(+size / 2, 0);\n        ctx.lineTo(size * 0.25, size * 0.25);\n        ctx.stroke();\n        ctx.restore();\n    },\n\n    /**\n     * Gets a chroma color for a pixel value, according to 'options.color'\n     */\n    _getColorFor(v) {\n        let c = this.options.color; // e.g. for a constant 'red'\n        if (typeof c === 'function') {\n            c = this.options.color(v);\n        }\n        let color = chroma(c); // to be more flexible, a chroma color object is always created || TODO improve efficiency\n        return color;\n    }\n});\n\nL.canvasLayer.scalarField = function(scalarField, options) {\n    return new L.CanvasLayer.ScalarField(scalarField, options);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./layer/L.CanvasLayer.ScalarField.js","/**\n *  Simple layer with lon-lat points\n *\n *  TODO rename to SimplePoint?\n */\nL.CanvasLayer.SimpleLonLat = L.CanvasLayer.extend({\n    options: {\n        color: 'gray'\n    },\n\n    initialize: function(points, options) {\n        this.points = points;\n        L.Util.setOptions(this, options);\n    },\n\n    onLayerDidMount: function() {\n        // -- prepare custom drawing\n    },\n\n    onLayerWillUnmount: function() {\n        // -- custom cleanup\n    },\n\n    /* eslint-disable no-unused-vars */\n    setData: function(data) {\n        // -- custom data set\n        this.needRedraw(); // -- call to drawLayer\n    },\n    /* eslint-enable no-unused-vars */\n\n    onDrawLayer: function(viewInfo) {\n        // canvas preparation\n        let g = viewInfo.canvas.getContext('2d');\n        g.clearRect(0, 0, viewInfo.canvas.width, viewInfo.canvas.height);\n        g.fillStyle = this.options.color;\n\n        for (let point of this.points) {\n            let p = viewInfo.layer._map.latLngToContainerPoint(point);\n            g.beginPath();\n            //g.arc(p.x, p.y, 1, 0, Math.PI * 2); // circle | TODO style 'function' as parameter?\n            g.fillRect(p.x, p.y, 2, 2); //simple point\n            g.fill();\n            g.closePath();\n            g.stroke();\n        }\n    },\n\n    getBounds: function() {\n        // TODO: bounding with points...\n        let xs = this.points.map(pt => pt.lng);\n        let ys = this.points.map(pt => pt.lat);\n\n        let xmin = Math.min(...xs);\n        let ymin = Math.min(...ys);\n        let xmax = Math.max(...xs);\n        let ymax = Math.max(...ys);\n\n        let southWest = L.latLng(ymin, xmin),\n            northEast = L.latLng(ymax, xmax);\n        let bounds = L.latLngBounds(southWest, northEast); // TODO FIX ERROR ? half-pixel?\n        return bounds;\n    }\n});\n\nL.canvasLayer.simpleLonLat = function(lonslats, options) {\n    return new L.CanvasLayer.SimpleLonLat(lonslats, options);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./layer/L.CanvasLayer.SimpleLonLat.js","/**\n * Animated VectorField on canvas\n */\nL.CanvasLayer.VectorFieldAnim = L.CanvasLayer.Field.extend({\n    options: {\n        paths: 800,\n        color: 'white', // html-color | function colorFor(value) [e.g. chromajs.scale]\n        width: 1.0, // number | function widthFor(value)\n        fade: 0.96, // 0 to 1\n        duration: 20, // milliseconds per 'frame'\n        maxAge: 200, // number of maximum frames per path\n        velocityScale: 1 / 5000\n    },\n\n    initialize: function(vectorField, options) {\n        L.CanvasLayer.Field.prototype.initialize.call(\n            this,\n            vectorField,\n            options\n        );\n        L.Util.setOptions(this, options);\n\n        this.timer = null;\n    },\n\n    onLayerDidMount: function() {\n        L.CanvasLayer.Field.prototype.onLayerDidMount.call(this);\n        this._map.on('move resize', this._stopAnimation, this);\n    },\n\n    onLayerWillUnmount: function() {\n        L.CanvasLayer.Field.prototype.onLayerWillUnmount.call(this);\n        this._map.off('move resize', this._stopAnimation, this);\n        this._stopAnimation();\n    },\n\n    _hideCanvas: function _showCanvas() {\n        L.CanvasLayer.Field.prototype._hideCanvas.call(this);\n        this._stopAnimation();\n    },\n\n    onDrawLayer: function(viewInfo) {\n        if (!this._field || !this.isVisible()) return;\n\n        this._updateOpacity();\n\n        let ctx = this._getDrawingContext();\n        let paths = this._prepareParticlePaths();\n\n        this.timer = d3.timer(function() {\n            _moveParticles();\n            _drawParticles();\n        }, this.options.duration);\n\n        let self = this;\n\n        /**\n         * Builds the paths, adding 'particles' on each animation step, considering\n         * their properties (age / position source > target)\n         */\n        function _moveParticles() {\n            // let screenFactor = 1 / self._map.getZoom(); // consider using a 'screenFactor' to ponderate velocityScale\n            paths.forEach(function(par) {\n                if (par.age > self.options.maxAge) {\n                    // restart, on a random x,y\n                    par.age = 0;\n                    self._field.randomPosition(par);\n                }\n\n                let vector = self._field.valueAt(par.x, par.y);\n                if (vector === null) {\n                    par.age = self.options.maxAge;\n                } else {\n                    // the next point will be...\n                    let xt = par.x + vector.u * self.options.velocityScale; //* screenFactor;\n                    let yt = par.y + vector.v * self.options.velocityScale; //* screenFactor;\n\n                    if (self._field.hasValueAt(xt, yt)) {\n                        par.xt = xt;\n                        par.yt = yt;\n                        par.m = vector.magnitude();\n                    } else {\n                        // not visible anymore...\n                        par.age = self.options.maxAge;\n                    }\n                }\n                par.age += 1;\n            });\n        }\n\n        /**\n         * Draws the paths on each step\n         */\n        function _drawParticles() {\n            // Previous paths...\n            let prev = ctx.globalCompositeOperation;\n            ctx.globalCompositeOperation = 'destination-in';\n            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n            //ctx.globalCompositeOperation = 'source-over';\n            ctx.globalCompositeOperation = prev;\n\n            // fading paths...\n            ctx.fillStyle = `rgba(0, 0, 0, ${self.options.fade})`;\n            ctx.lineWidth = self.options.width;\n            ctx.strokeStyle = self.options.color;\n\n            // New paths\n            paths.forEach(function(par) {\n                self._drawParticle(viewInfo, ctx, par);\n            });\n        }\n    },\n\n    _drawParticle(viewInfo, ctx, par) {\n        let source = new L.latLng(par.y, par.x);\n        let target = new L.latLng(par.yt, par.xt);\n\n        if (\n            viewInfo.bounds.contains(source) &&\n            par.age <= this.options.maxAge\n        ) {\n            let pA = viewInfo.layer._map.latLngToContainerPoint(source);\n            let pB = viewInfo.layer._map.latLngToContainerPoint(target);\n\n            ctx.beginPath();\n            ctx.moveTo(pA.x, pA.y);\n            ctx.lineTo(pB.x, pB.y);\n\n            // next-step movement\n            par.x = par.xt;\n            par.y = par.yt;\n\n            // colormap vs. simple color\n            let color = this.options.color;\n            if (typeof color === 'function') {\n                ctx.strokeStyle = color(par.m);\n            }\n\n            let width = this.options.width;\n            if (typeof width === 'function') {\n                ctx.lineWidth = width(par.m);\n            }\n\n            ctx.stroke();\n        }\n    },\n\n    _prepareParticlePaths: function() {\n        let paths = [];\n\n        for (var i = 0; i < this.options.paths; i++) {\n            let p = this._field.randomPosition();\n            p.age = this._randomAge();\n            paths.push(p);\n        }\n        return paths;\n    },\n\n    _randomAge: function() {\n        return Math.floor(Math.random() * this.options.maxAge);\n    },\n\n    _stopAnimation: function() {\n        if (this.timer) {\n            this.timer.stop();\n        }\n    }\n});\n\nL.canvasLayer.vectorFieldAnim = function(vectorField, options) {\n    return new L.CanvasLayer.VectorFieldAnim(vectorField, options);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./layer/L.CanvasLayer.VectorFieldAnim.js","/*\n  1.0.1 (downloaded from https://github.com/Sumbera/gLayers.Leaflet/releases/tag/v1.0.1)\n\n  Generic  Canvas Layer for leaflet 0.7 and 1.0-rc,\n  copyright Stanislav Sumbera,  2016 , sumbera.com , license MIT\n  originally created and motivated by L.CanvasOverlay  available here: https://gist.github.com/Sumbera/11114288\n*/\n\nL.CanvasLayer = L.Layer.extend({\n    // -- initialized is called on prototype\n    initialize: function (options) {\n        this._map = null;\n        this._canvas = null;\n        this._frame = null;\n        this._delegate = null;\n        L.setOptions(this, options);\n    },\n\n    delegate: function (del) {\n        this._delegate = del;\n        return this;\n    },\n\n    needRedraw: function () {\n        if (!this._frame) {\n            this._frame = L.Util.requestAnimFrame(this.drawLayer, this);\n        }\n        return this;\n    },\n\n    //-------------------------------------------------------------\n    _onLayerDidResize: function (resizeEvent) {\n        this._canvas.width = resizeEvent.newSize.x;\n        this._canvas.height = resizeEvent.newSize.y;\n    },\n    //-------------------------------------------------------------\n    _onLayerDidMove: function () {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n        this.drawLayer();\n    },\n    //-------------------------------------------------------------\n    getEvents: function () {\n        var events = {\n            resize: this._onLayerDidResize,\n            moveend: this._onLayerDidMove\n        };\n        if (this._map.options.zoomAnimation && L.Browser.any3d) {\n            events.zoomanim = this._animateZoom;\n        }\n\n        return events;\n    },\n    //-------------------------------------------------------------\n    onAdd: function (map) {\n        this._map = map;\n        this._canvas = L.DomUtil.create('canvas', 'leaflet-layer');\n        this.tiles = {};\n\n        var size = this._map.getSize();\n        this._canvas.width = size.x;\n        this._canvas.height = size.y;\n\n        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\n        L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\n\n\n        map._panes.overlayPane.appendChild(this._canvas);\n\n        map.on(this.getEvents(), this);\n\n        var del = this._delegate || this;\n        del.onLayerDidMount && del.onLayerDidMount(); // -- callback\n\n        this.needRedraw();\n    },\n\n    //-------------------------------------------------------------\n    onRemove: function (map) {\n        var del = this._delegate || this;\n        del.onLayerWillUnmount && del.onLayerWillUnmount(); // -- callback\n\n\n        map.getPanes().overlayPane.removeChild(this._canvas);\n\n        map.off(this.getEvents(), this);\n\n        this._canvas = null;\n\n    },\n\n    //------------------------------------------------------------\n    addTo: function (map) {\n        map.addLayer(this);\n        return this;\n    },\n    // --------------------------------------------------------------------------------\n    LatLonToMercator: function (latlon) {\n        return {\n            x: latlon.lng * 6378137 * Math.PI / 180,\n            y: Math.log(Math.tan((90 + latlon.lat) * Math.PI / 360)) * 6378137\n        };\n    },\n\n    //------------------------------------------------------------------------------\n    drawLayer: function () {\n        // -- todo make the viewInfo properties  flat objects.\n        var size = this._map.getSize();\n        var bounds = this._map.getBounds();\n        var zoom = this._map.getZoom();\n\n        var center = this.LatLonToMercator(this._map.getCenter());\n        var corner = this.LatLonToMercator(this._map.containerPointToLatLng(this._map.getSize()));\n\n        var del = this._delegate || this;\n        del.onDrawLayer && del.onDrawLayer({\n            layer: this,\n            canvas: this._canvas,\n            bounds: bounds,\n            size: size,\n            zoom: zoom,\n            center: center,\n            corner: corner\n        });\n        this._frame = null;\n    },\n\n    //------------------------------------------------------------------------------\n    _animateZoom: function (e) {\n        var scale = this._map.getZoomScale(e.zoom);\n        var offset = this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), e.zoom, e.center);\n\n        L.DomUtil.setTransform(this._canvas, offset, scale);\n    }\n});\n\nL.canvasLayer = function () {\n    return new L.CanvasLayer();\n};\n\n\n\n// WEBPACK FOOTER //\n// ./layer/L.CanvasLayer.js","var invariant = require('@turf/invariant');\nvar getCoord = invariant.getCoord;\nvar getCoords = invariant.getCoords;\n\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can\n * be convex or concave. The function accounts for holes.\n *\n * @name inside\n * @param {Feature<Point>} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {boolean} [ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.inside(pt, poly);\n * //= true\n */\nmodule.exports = function (point, polygon, ignoreBoundary) {\n    // validation\n    if (!point) throw new Error('point is required');\n    if (!polygon) throw new Error('polygon is required');\n\n    var pt = getCoord(point);\n    var polys = getCoords(polygon);\n    var type = (polygon.geometry) ? polygon.geometry.type : polygon.type;\n    var bbox = polygon.bbox;\n\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) return false;\n\n    // normalize to multipolygon\n    if (type === 'Polygon') polys = [polys];\n\n    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) insidePoly = true;\n        }\n    }\n    return insidePoly;\n};\n\n/**\n * inRing\n *\n * @private\n * @param {[number, number]} pt [x,y]\n * @param {Array<[number, number]>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0], yi = ring[i][1];\n        var xj = ring[j][0], yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) return !ignoreBoundary;\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\n\n/**\n * inBBox\n *\n * @private\n * @param {[number, number]} pt point [x,y]\n * @param {[number, number, number, number]} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n           bbox[1] <= pt[1] &&\n           bbox[2] >= pt[0] &&\n           bbox[3] >= pt[1];\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@turf/inside/index.js\n// module id = 11\n// module chunks = 0","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {string} GeoJSON Geometry Type\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeomType(point)\n * //=\"Point\"\n */\nfunction getGeomType(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    var geom = getGeom(geojson);\n    if (geom) return geom.type;\n}\n\nmodule.exports = {\n    geojsonType: geojsonType,\n    collectionOf: collectionOf,\n    featureOf: featureOf,\n    getCoord: getCoord,\n    getCoords: getCoords,\n    containsNumber: containsNumber,\n    getGeom: getGeom,\n    getGeomType: getGeomType\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/@turf/invariant/index.js\n// module id = 12\n// module chunks = 0","// base\nimport Vector from './Vector.js';\nwindow.L.Vector = Vector;\n\nimport Cell from './Cell.js';\nwindow.L.Cell = Cell;\n\nimport Field from './Field.js';\nwindow.L.Field = Field;\n\nimport ScalarField from './ScalarField.js';\nwindow.L.ScalarField = ScalarField;\n\nimport VectorField from './VectorField.js';\nwindow.L.VectorField = VectorField;\n\n// layer\nrequire('./layer/L.CanvasLayer.js');\nrequire('./layer/L.CanvasLayer.SimpleLonLat.js');\nrequire('./layer/L.CanvasLayer.Field.js');\nrequire('./layer/L.CanvasLayer.ScalarField.js');\nrequire('./layer/L.CanvasLayer.VectorFieldAnim.js');\n\n// control\nrequire('./control/L.Control.ColorBar.js');\n\n/* eslint-disable no-console */\nconsole.log('leaflet.canvaslayer.field v1.4.1');\n/* eslint-enable no-console */\n\n\n\n// WEBPACK FOOTER //\n// ./_main.js"],"sourceRoot":""}